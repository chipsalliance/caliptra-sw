// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 19dc3e00572423ca5ed03633f38f70a4592cb56c
//
#![allow(clippy::doc_lazy_continuation)]
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Kmac {
    _priv: (),
}
impl Kmac {
    pub const PTR: *mut u32 = 0x10040000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`kmac::regs::IntrStateReadVal`]; Write value: [`kmac::regs::IntrStateWriteVal`]
    #[inline(always)]
    pub fn intr_state(&self) -> ureg::RegRef<crate::kmac::meta::IntrState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::IntrEnableReadVal`]; Write value: [`kmac::regs::IntrEnableWriteVal`]
    #[inline(always)]
    pub fn intr_enable(&self) -> ureg::RegRef<crate::kmac::meta::IntrEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::IntrTestReadVal`]; Write value: [`kmac::regs::IntrTestWriteVal`]
    #[inline(always)]
    pub fn intr_test(&self) -> ureg::RegRef<crate::kmac::meta::IntrTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::AlertTestReadVal`]; Write value: [`kmac::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::kmac::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::CfgRegwenReadVal`]; Write value: [`kmac::regs::CfgRegwenWriteVal`]
    #[inline(always)]
    pub fn cfg_regwen(&self) -> ureg::RegRef<crate::kmac::meta::CfgRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register is shadowed and protected by CFG_REGWEN.en
    /// 1. Two subsequent write operation are required to change its content,
    /// If the two write operations try to set a different value, a recoverable alert is triggered (See Status Register).
    /// 2. A read operation clears the internal phase tracking.
    /// 3. If storage error(~staged_reg!=committed_reg) happen, it will trigger fatal fault alert
    ///
    /// Read value: [`kmac::regs::CfgShadowedReadVal`]; Write value: [`kmac::regs::CfgShadowedWriteVal`]
    #[inline(always)]
    pub fn cfg_shadowed(&self) -> ureg::RegRef<crate::kmac::meta::CfgShadowed, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::CmdReadVal`]; Write value: [`kmac::regs::CmdWriteVal`]
    #[inline(always)]
    pub fn cmd(&self) -> ureg::RegRef<crate::kmac::meta::Cmd, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`kmac::regs::StatusReadVal`]; Write value: [`kmac::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::kmac::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_0(&self) -> ureg::RegRef<crate::kmac::meta::Prefix0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_1(&self) -> ureg::RegRef<crate::kmac::meta::Prefix1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_2(&self) -> ureg::RegRef<crate::kmac::meta::Prefix2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_3(&self) -> ureg::RegRef<crate::kmac::meta::Prefix3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_4(&self) -> ureg::RegRef<crate::kmac::meta::Prefix4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_5(&self) -> ureg::RegRef<crate::kmac::meta::Prefix5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_6(&self) -> ureg::RegRef<crate::kmac::meta::Prefix6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_7(&self) -> ureg::RegRef<crate::kmac::meta::Prefix7, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_8(&self) -> ureg::RegRef<crate::kmac::meta::Prefix8, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_9(&self) -> ureg::RegRef<crate::kmac::meta::Prefix9, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prefix_10(&self) -> ureg::RegRef<crate::kmac::meta::Prefix10, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SHA3 Error Code
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn err_code(&self) -> ureg::RegRef<crate::kmac::meta::ErrCode, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Keccak State (1600 bit) memory.
    /// The software can get the processed digest by reading this memory
    /// region. Unlike MSG_FIFO, STATE memory space sees the addr[9:0].
    /// If Masking feature is enabled, the software reads two shares from
    /// this memory space.
    /// 0x200 - 0x2C7: State share
    /// for Keccak State access:
    /// 1. Output length <= rate length, sha3_done will be raised or software can poll STATUS.squeeze become 1.
    /// 2. Output length > rate length, after software read 1st keccak state, software should issue run cmd to trigger keccak round logic to run full 24 rounds.
    /// And then software should check STATUS.squeeze register field for the readiness of STATE value(SHA3 FSM become MANUAL_RUN before keccak state complete).
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn state(&self) -> ureg::Array<64, ureg::RegRef<crate::kmac::meta::State, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Message FIFO. window size is 2048 bytes.
    /// Any write operation to this window will be appended to MSG_FIFO. SW can
    /// simply write bytes/words to any address within this address range.
    /// Ordering and packing of the incoming bytes/words are handled
    /// internally. Therefore, the least significant 10 bits of the address
    /// are ignored.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn msg_fifo(&self) -> ureg::Array<64, ureg::RegRef<crate::kmac::meta::MsgFifo, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x800 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn recov_operation_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_fault_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CfgRegwenReadVal(u32);
    impl CfgRegwenReadVal {
        /// Configuration enable.
        #[inline(always)]
        pub fn en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for CfgRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CfgRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: CfgRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CfgShadowedReadVal(u32);
    impl CfgShadowedReadVal {
        /// Hashing Strength, Protected by CFG_REGWEN.en
        /// bit field to select the security strength of SHA3 hashing engine.
        /// If mode field is set to SHAKE, only 128 and 256 strength can be selected.
        /// Other value will result error when hashing starts.
        #[inline(always)]
        pub fn kstrength(&self) -> u32 {
            (self.0 >> 1) & 7
        }
        /// Keccak hashing mode, Protected by CFG_REGWEN.en
        /// This module supports SHA3 main hashing algorithm and the part of its derived functions,
        /// SHAKE with limitations. This field is to select the mode.
        #[inline(always)]
        pub fn mode(&self) -> u32 {
            (self.0 >> 4) & 3
        }
        /// Protected by CFG_REGWEN.en
        /// If 1 then each individual multi-byte value, regardless of its alignment,
        /// written to MSG_FIFO will be added to the message in big-endian byte order.
        /// If 0, each value will be added to the message in little-endian byte order.
        /// A message written to MSG_FIFO one byte at a time will not be affected by this setting.
        /// From a hardware perspective byte swaps are performed on a TL-UL word granularity.
        #[inline(always)]
        pub fn msg_endianness(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Protected by CFG_REGWEN.en
        /// If 1 then each individual multi-byte value, regardless of its alignment,
        /// written to MSG_FIFO will be added to the message in big-endian byte order.
        /// If 0, each value will be added to the message in little-endian byte order.
        /// A message written to MSG_FIFO one byte at a time will not be affected by this setting.
        /// From a hardware perspective byte swaps are performed on a TL-UL word granularity.
        #[inline(always)]
        pub fn state_endianness(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CfgShadowedWriteVal {
            CfgShadowedWriteVal(self.0)
        }
    }
    impl From<u32> for CfgShadowedReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CfgShadowedReadVal> for u32 {
        #[inline(always)]
        fn from(val: CfgShadowedReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CfgShadowedWriteVal(u32);
    impl CfgShadowedWriteVal {
        /// Hashing Strength, Protected by CFG_REGWEN.en
        /// bit field to select the security strength of SHA3 hashing engine.
        /// If mode field is set to SHAKE, only 128 and 256 strength can be selected.
        /// Other value will result error when hashing starts.
        #[inline(always)]
        pub fn kstrength(self, val: u32) -> Self {
            Self((self.0 & !(7 << 1)) | ((val & 7) << 1))
        }
        /// Keccak hashing mode, Protected by CFG_REGWEN.en
        /// This module supports SHA3 main hashing algorithm and the part of its derived functions,
        /// SHAKE with limitations. This field is to select the mode.
        #[inline(always)]
        pub fn mode(self, val: u32) -> Self {
            Self((self.0 & !(3 << 4)) | ((val & 3) << 4))
        }
        /// Protected by CFG_REGWEN.en
        /// If 1 then each individual multi-byte value, regardless of its alignment,
        /// written to MSG_FIFO will be added to the message in big-endian byte order.
        /// If 0, each value will be added to the message in little-endian byte order.
        /// A message written to MSG_FIFO one byte at a time will not be affected by this setting.
        /// From a hardware perspective byte swaps are performed on a TL-UL word granularity.
        #[inline(always)]
        pub fn msg_endianness(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Protected by CFG_REGWEN.en
        /// If 1 then each individual multi-byte value, regardless of its alignment,
        /// written to MSG_FIFO will be added to the message in big-endian byte order.
        /// If 0, each value will be added to the message in little-endian byte order.
        /// A message written to MSG_FIFO one byte at a time will not be affected by this setting.
        /// From a hardware perspective byte swaps are performed on a TL-UL word granularity.
        #[inline(always)]
        pub fn state_endianness(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
    }
    impl From<u32> for CfgShadowedWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CfgShadowedWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CfgShadowedWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CmdReadVal(u32);
    impl CmdReadVal {
        /// Issues a command to the SHA3 IP. The command is sparse encoded.
        /// To prevent sw from writing multiple commands at once, the field is defined as enum.
        /// Always return 0 for SW reads.
        /// START: Writing 6'b011101 or dec 29 into this field when SHA3/SHAKE is in idle, SHA3/SHAKE begins its operation and start absorbing.
        /// PROCESS: Writing 6'b101110 or dec 46 into this field when SHA3/SHAKE began its operation and received the entire message, it computes the digest or signing.
        /// RUN: The run field is used in the sponge squeezing stage.
        /// It triggers the keccak round logic to run full 24 rounds.
        /// This is optional and used when software needs more digest bits than the keccak rate.
        /// It only affects when the SHA3/SHAKE operation is completed.
        /// DONE: Writing 6'b010110 or dec 22 into this field when SHA3 squeezing is completed,
        /// SHA3/SHAKE hashing engine clears internal variables and goes back to Idle state for next command.
        #[inline(always)]
        pub fn cmd(&self) -> u32 {
            (self.0 >> 0) & 0x3f
        }
        /// When error occurs and one of the state machine stays at Error handling state,
        /// SW may process the error based on ERR_CODE, then let FSM back to the reset state.
        /// Always return 0 for SW reads.
        #[inline(always)]
        pub fn err_processed(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CmdWriteVal {
            CmdWriteVal(self.0)
        }
    }
    impl From<u32> for CmdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CmdReadVal> for u32 {
        #[inline(always)]
        fn from(val: CmdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CmdWriteVal(u32);
    impl CmdWriteVal {
        /// Issues a command to the SHA3 IP. The command is sparse encoded.
        /// To prevent sw from writing multiple commands at once, the field is defined as enum.
        /// Always return 0 for SW reads.
        /// START: Writing 6'b011101 or dec 29 into this field when SHA3/SHAKE is in idle, SHA3/SHAKE begins its operation and start absorbing.
        /// PROCESS: Writing 6'b101110 or dec 46 into this field when SHA3/SHAKE began its operation and received the entire message, it computes the digest or signing.
        /// RUN: The run field is used in the sponge squeezing stage.
        /// It triggers the keccak round logic to run full 24 rounds.
        /// This is optional and used when software needs more digest bits than the keccak rate.
        /// It only affects when the SHA3/SHAKE operation is completed.
        /// DONE: Writing 6'b010110 or dec 22 into this field when SHA3 squeezing is completed,
        /// SHA3/SHAKE hashing engine clears internal variables and goes back to Idle state for next command.
        #[inline(always)]
        pub fn cmd(self, val: u32) -> Self {
            Self((self.0 & !(0x3f << 0)) | ((val & 0x3f) << 0))
        }
        /// When error occurs and one of the state machine stays at Error handling state,
        /// SW may process the error based on ERR_CODE, then let FSM back to the reset state.
        /// Always return 0 for SW reads.
        #[inline(always)]
        pub fn err_processed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for CmdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CmdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CmdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrEnableReadVal(u32);
    impl IntrEnableReadVal {
        /// SHA3/SHAKE done interrupt
        #[inline(always)]
        pub fn kmac_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FIFO empty interrupt
        #[inline(always)]
        pub fn fifo_empty(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// SHA3/SHAKE error interrupt
        #[inline(always)]
        pub fn kmac_err(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrEnableWriteVal {
            IntrEnableWriteVal(self.0)
        }
    }
    impl From<u32> for IntrEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrEnableWriteVal(u32);
    impl IntrEnableWriteVal {
        /// SHA3/SHAKE done interrupt
        #[inline(always)]
        pub fn kmac_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// FIFO empty interrupt
        #[inline(always)]
        pub fn fifo_empty(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// SHA3/SHAKE error interrupt
        #[inline(always)]
        pub fn kmac_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for IntrEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStateReadVal(u32);
    impl IntrStateReadVal {
        /// SHA3/SHAKE done interrupt
        #[inline(always)]
        pub fn kmac_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FIFO empty interrupt
        #[inline(always)]
        pub fn fifo_empty(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// SHA3/SHAKE error interrupt
        #[inline(always)]
        pub fn kmac_err(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrStateWriteVal {
            IntrStateWriteVal(self.0)
        }
    }
    impl From<u32> for IntrStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStateWriteVal(u32);
    impl IntrStateWriteVal {
        /// SHA3/SHAKE done interrupt
        #[inline(always)]
        pub fn kmac_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// SHA3/SHAKE error interrupt
        #[inline(always)]
        pub fn kmac_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for IntrStateWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStateWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStateWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrTestWriteVal(u32);
    impl IntrTestWriteVal {
        /// SHA3/SHAKE done interrupt
        #[inline(always)]
        pub fn kmac_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// FIFO empty interrupt
        #[inline(always)]
        pub fn fifo_empty(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// SHA3/SHAKE error interrupt
        #[inline(always)]
        pub fn kmac_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for IntrTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// If 1, SHA3 hashing engine is in idle state.
        #[inline(always)]
        pub fn sha3_idle(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// If 1, SHA3 is receiving message stream and processing it
        #[inline(always)]
        pub fn sha3_absorb(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// If 1, SHA3 completes sponge absorbing stage. In this stage, SW can manually run the hashing engine.
        #[inline(always)]
        pub fn sha3_squeeze(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Count of occupied entries in the message FIFO.
        #[inline(always)]
        pub fn fifo_depth(&self) -> u32 {
            (self.0 >> 8) & 0x1f
        }
        /// Message FIFO Empty indicator.
        /// The FIFO's Pass parameter is set to 1'b 1. So, by default, if the SHA engine is ready, the write data to FIFO just passes through.
        /// In this case, fifo_depth remains 0. fifo_empty, however, lowers the value to 0 for a cycle, then goes back to the empty state, 1.
        /// See the Message FIFO section in the spec for the reason.
        #[inline(always)]
        pub fn fifo_empty(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Message FIFO Full indicator.
        #[inline(always)]
        pub fn fifo_full(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// No fatal fault has occurred inside the SHA3 unit (0).
        /// A fatal fault has occured and the SHA3 unit needs to be reset (1),
        /// Examples for such faults include i) TL-UL bus integrity fault
        /// ii) storage errors in the shadow registers
        /// iii) errors in the message, round, or key counter
        /// iv) any internal FSM entering an invalid state.
        #[inline(always)]
        pub fn alert_fatal_fault(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// An update error has not occurred (0) or has occured (1) in the shadowed Control Register.
        /// SHA3 operation needs to be restarted by re-writing the Control Register.
        #[inline(always)]
        pub fn alert_recov_ctrl_update_err(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type IntrState = ureg::ReadWriteReg32<
        0,
        crate::kmac::regs::IntrStateReadVal,
        crate::kmac::regs::IntrStateWriteVal,
    >;
    pub type IntrEnable = ureg::ReadWriteReg32<
        0,
        crate::kmac::regs::IntrEnableReadVal,
        crate::kmac::regs::IntrEnableWriteVal,
    >;
    pub type IntrTest = ureg::WriteOnlyReg32<0, crate::kmac::regs::IntrTestWriteVal>;
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::kmac::regs::AlertTestWriteVal>;
    pub type CfgRegwen = ureg::ReadOnlyReg32<crate::kmac::regs::CfgRegwenReadVal>;
    pub type CfgShadowed = ureg::ReadWriteReg32<
        0,
        crate::kmac::regs::CfgShadowedReadVal,
        crate::kmac::regs::CfgShadowedWriteVal,
    >;
    pub type Cmd =
        ureg::ReadWriteReg32<0, crate::kmac::regs::CmdReadVal, crate::kmac::regs::CmdWriteVal>;
    pub type Status = ureg::ReadOnlyReg32<crate::kmac::regs::StatusReadVal>;
    pub type Prefix0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix6 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix7 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix8 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix9 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Prefix10 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ErrCode = ureg::ReadOnlyReg32<u32>;
    pub type State = ureg::ReadOnlyReg32<u32>;
    pub type MsgFifo = ureg::WriteOnlyReg32<0, u32>;
}

// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at c506fd5a694b2efabd6113172f14b47cb14bd684
//
#![allow(clippy::doc_lazy_continuation)]
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct LcCtrl {
    _priv: (),
}
impl LcCtrl {
    pub const PTR: *mut u32 = 0x70000400 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`lc_ctrl::regs::AlertTestReadVal`]; Write value: [`lc_ctrl::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::lc_ctrl::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`lc_ctrl::regs::StatusReadVal`]; Write value: [`lc_ctrl::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::lc_ctrl::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Register write enable for the hardware mutex register.
    ///
    /// Read value: [`lc_ctrl::regs::ClaimTransitionIfRegwenReadVal`]; Write value: [`lc_ctrl::regs::ClaimTransitionIfRegwenWriteVal`]
    #[inline(always)]
    pub fn claim_transition_if_regwen(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::ClaimTransitionIfRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Hardware mutex to claim exclusive access to the transition interface.
    ///
    /// Read value: [`lc_ctrl::regs::ClaimTransitionIfReadVal`]; Write value: [`lc_ctrl::regs::ClaimTransitionIfWriteVal`]
    #[inline(always)]
    pub fn claim_transition_if(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::ClaimTransitionIf, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Register write enable for the hardware mutex register.
    ///
    /// Read value: [`lc_ctrl::regs::TransitionRegwenReadVal`]; Write value: [`lc_ctrl::regs::TransitionRegwenWriteVal`]
    #[inline(always)]
    pub fn transition_regwen(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Command register for state transition requests.
    ///
    /// Read value: [`lc_ctrl::regs::TransitionCmdReadVal`]; Write value: [`lc_ctrl::regs::TransitionCmdWriteVal`]
    #[inline(always)]
    pub fn transition_cmd(&self) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionCmd, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register for state transition requests.
    ///
    /// Read value: [`lc_ctrl::regs::TransitionCtrlReadVal`]; Write value: [`lc_ctrl::regs::TransitionCtrlWriteVal`]
    #[inline(always)]
    pub fn transition_ctrl(&self) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 128bit token for conditional transitions. Make sure to set this to 0 for unconditional transitions. Note that this register is shared with the life cycle TAP/DMI interface. In order to have exclusive access to this register, SW must first claim the associated hardware mutex via CLAIM_TRANSITION_IF.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn transition_token_0(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionToken0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 128bit token for conditional transitions. Make sure to set this to 0 for unconditional transitions. Note that this register is shared with the life cycle TAP/DMI interface. In order to have exclusive access to this register, SW must first claim the associated hardware mutex via CLAIM_TRANSITION_IF.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn transition_token_1(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionToken1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 128bit token for conditional transitions. Make sure to set this to 0 for unconditional transitions. Note that this register is shared with the life cycle TAP/DMI interface. In order to have exclusive access to this register, SW must first claim the associated hardware mutex via CLAIM_TRANSITION_IF.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn transition_token_2(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionToken2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 128bit token for conditional transitions. Make sure to set this to 0 for unconditional transitions. Note that this register is shared with the life cycle TAP/DMI interface. In order to have exclusive access to this register, SW must first claim the associated hardware mutex via CLAIM_TRANSITION_IF.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn transition_token_3(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionToken3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register exposes the decoded life cycle state.
    ///
    /// Read value: [`lc_ctrl::regs::TransitionTargetReadVal`]; Write value: [`lc_ctrl::regs::TransitionTargetWriteVal`]
    #[inline(always)]
    pub fn transition_target(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::TransitionTarget, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Test/vendor-specific settings for the OTP macro wrapper. These values are only active during RAW, TEST_* and RMA life cycle states. In all other states, these values will be gated to zero before sending them to the OTP macro wrapper - even if this register is programmed to a non-zero value.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn otp_vendor_test_ctrl(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::OtpVendorTestCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Test/vendor-specific settings for the OTP macro wrapper. These values are only active during RAW, TEST_* and RMA life cycle states. In all other states, these values will read as zero.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn otp_vendor_test_status(
        &self,
    ) -> ureg::RegRef<crate::lc_ctrl::meta::OtpVendorTestStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register exposes the decoded life cycle state.
    ///
    /// Read value: [`lc_ctrl::regs::LcStateReadVal`]; Write value: [`lc_ctrl::regs::LcStateWriteVal`]
    #[inline(always)]
    pub fn lc_state(&self) -> ureg::RegRef<crate::lc_ctrl::meta::LcState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register exposes the state of the decoded life cycle transition counter.
    ///
    /// Read value: [`lc_ctrl::regs::LcTransitionCntReadVal`]; Write value: [`lc_ctrl::regs::LcTransitionCntWriteVal`]
    #[inline(always)]
    pub fn lc_transition_cnt(&self) -> ureg::RegRef<crate::lc_ctrl::meta::LcTransitionCnt, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register exposes the id state of the device.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn lc_id_state(&self) -> ureg::RegRef<crate::lc_ctrl::meta::LcIdState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds the SILICON_CREATOR_ID and the PRODUCT_ID.
    ///
    /// Read value: [`lc_ctrl::regs::HwRevision0ReadVal`]; Write value: [`lc_ctrl::regs::HwRevision0WriteVal`]
    #[inline(always)]
    pub fn hw_revision0(&self) -> ureg::RegRef<crate::lc_ctrl::meta::HwRevision0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds the REVISION_ID.
    ///
    /// Read value: [`lc_ctrl::regs::HwRevision1ReadVal`]; Write value: [`lc_ctrl::regs::HwRevision1WriteVal`]
    #[inline(always)]
    pub fn hw_revision1(&self) -> ureg::RegRef<crate::lc_ctrl::meta::HwRevision1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_0(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_1(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_2(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_3(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_4(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_5(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_6(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is the 256bit DEVICE_ID value that is stored in the HW_CFG0 partition in OTP. If this register reads all-one, the HW_CFG0 partition has not been initialized yet or is in error state. If this register reads all-zero, this is indicative that the value has not been programmed to OTP yet.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_7(&self) -> ureg::RegRef<crate::lc_ctrl::meta::DeviceId7, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_0(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x6c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_1(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_2(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x74 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_3(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x78 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_4(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x7c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_5(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_6(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x84 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This is a 256bit field used for keeping track of the manufacturing state.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn manuf_state_7(&self) -> ureg::RegRef<crate::lc_ctrl::meta::ManufState7, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x88 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_prog_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_state_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_bus_integ_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClaimTransitionIfReadVal(u32);
    impl ClaimTransitionIfReadVal {
        /// Mutex
        #[inline(always)]
        pub fn mutex(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ClaimTransitionIfWriteVal {
            ClaimTransitionIfWriteVal(self.0)
        }
    }
    impl From<u32> for ClaimTransitionIfReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ClaimTransitionIfReadVal> for u32 {
        #[inline(always)]
        fn from(val: ClaimTransitionIfReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClaimTransitionIfWriteVal(u32);
    impl ClaimTransitionIfWriteVal {
        /// Mutex
        #[inline(always)]
        pub fn mutex(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for ClaimTransitionIfWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ClaimTransitionIfWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ClaimTransitionIfWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClaimTransitionIfRegwenReadVal(u32);
    impl ClaimTransitionIfRegwenReadVal {
        /// This bit is managed by software and is set to 1 by default. When cleared to 0, the CLAIM_TRANSITION_IF mutex register cannot be written to anymore. Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ClaimTransitionIfRegwenWriteVal {
            ClaimTransitionIfRegwenWriteVal(self.0)
        }
    }
    impl From<u32> for ClaimTransitionIfRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ClaimTransitionIfRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: ClaimTransitionIfRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClaimTransitionIfRegwenWriteVal(u32);
    impl ClaimTransitionIfRegwenWriteVal {
        /// This bit is managed by software and is set to 1 by default. When cleared to 0, the CLAIM_TRANSITION_IF mutex register cannot be written to anymore. Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ClaimTransitionIfRegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ClaimTransitionIfRegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ClaimTransitionIfRegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwRevision0ReadVal(u32);
    impl HwRevision0ReadVal {
        /// Used to identify a class of devices. Assigned by the Silicon Creator. Zero is an invalid value.
        #[inline(always)]
        pub fn product_id(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// ID of the silicon creator. Assigned by the OpenTitan project. Zero is an invalid value.
        #[inline(always)]
        pub fn silicon_creator_id(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for HwRevision0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwRevision0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwRevision0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwRevision1ReadVal(u32);
    impl HwRevision1ReadVal {
        /// Product revision ID. Assigned by the Silicon Creator. The encoding is not specified other than that different tapeouts must be assigned different revision numbers. I.e., each base or metal layer respin must be reflected so that software can rely on it to modify firmware and driver behavior. Zero is an invalid value.
        #[inline(always)]
        pub fn revision_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Reserved bits. Set to zero.
        #[inline(always)]
        pub fn reserved(&self) -> u32 {
            (self.0 >> 8) & 0xffffff
        }
    }
    impl From<u32> for HwRevision1ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwRevision1ReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwRevision1ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct LcStateReadVal(u32);
    impl LcStateReadVal {
        /// OT vendor test control
        #[inline(always)]
        pub fn state(&self) -> u32 {
            (self.0 >> 0) & 0x3fffffff
        }
    }
    impl From<u32> for LcStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<LcStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: LcStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct LcTransitionCntReadVal(u32);
    impl LcTransitionCntReadVal {
        /// OT vendor test control
        #[inline(always)]
        pub fn cnt(&self) -> u32 {
            (self.0 >> 0) & 0x1f
        }
    }
    impl From<u32> for LcTransitionCntReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<LcTransitionCntReadVal> for u32 {
        #[inline(always)]
        fn from(val: LcTransitionCntReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// This bit is set to 1 if the life cycle controller has successfully initialized and the state exposed in LC_STATE and LC_TRANSITION_CNT is valid.
        #[inline(always)]
        pub fn initialized(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit is set to 1 if the life cycle controller has successfully initialized and is ready to accept a life cycle transition command.
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// This bit is set to 1 if the clock manager has successfully switched to the external clock due to EXT_CLOCK_EN being set to 1.
        #[inline(always)]
        pub fn ext_clock_switched(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// This bit is set to 1 if the last life cycle transition request was successful. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
        #[inline(always)]
        pub fn transition_successful(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// This bit is set to 1 if the LC_TRANSITION_CNT has reached its maximum. If this is the case, no more state transitions can be performed. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
        #[inline(always)]
        pub fn transition_count_error(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// This bit is set to 1 if the last transition command requested an invalid state transition (e.g. DEV -> RAW). Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
        #[inline(always)]
        pub fn transition_error(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// This bit is set to 1 if the token supplied for a conditional transition was invalid. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
        #[inline(always)]
        pub fn token_error(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// This bit is set to 1 if flash failed to correctly respond to an RMA request. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
        #[inline(always)]
        pub fn flash_rma_error(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// This bit is set to 1 if an error occurred during an OTP programming operation. This error will move the life cycle state automatically to POST_TRANSITION and raise a fatal_prog_error alert.
        #[inline(always)]
        pub fn otp_error(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// This bit is set to 1 if either the controller FSM state or the life cycle state is invalid or has been corrupted as part of a tampering attempt. This error will move the life cycle state automatically to INVALID and raise a fatal_state_error alert.
        #[inline(always)]
        pub fn state_error(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// This bit is set to 1 if a fatal bus integrity fault is detected. This error triggers a fatal_bus_integ_error alert.
        #[inline(always)]
        pub fn bus_integ_error(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// This bit is set to 1 if the life cycle partition in OTP is in error state. This bit is intended for production testing during the RAW life cycle state, where the OTP control and status registers are not accessible. This error does not trigger an alert in the life cycle controller.
        #[inline(always)]
        pub fn otp_partition_error(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionCmdReadVal(u32);
    impl TransitionCmdReadVal {
        /// Start
        #[inline(always)]
        pub fn start(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TransitionCmdWriteVal {
            TransitionCmdWriteVal(self.0)
        }
    }
    impl From<u32> for TransitionCmdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionCmdReadVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionCmdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionCmdWriteVal(u32);
    impl TransitionCmdWriteVal {
        /// Start
        #[inline(always)]
        pub fn start(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for TransitionCmdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionCmdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionCmdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionCtrlReadVal(u32);
    impl TransitionCtrlReadVal {
        /// When set to 1, the OTP clock will be switched to an externally supplied clock right away when the device is in a non-PROD life cycle state. The clock mux will remain switched until the next system reset.
        #[inline(always)]
        pub fn ext_clock_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Volatile raw unlock
        #[inline(always)]
        pub fn volatile_raw_unlock(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TransitionCtrlWriteVal {
            TransitionCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for TransitionCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionCtrlWriteVal(u32);
    impl TransitionCtrlWriteVal {
        /// When set to 1, the OTP clock will be switched to an externally supplied clock right away when the device is in a non-PROD life cycle state. The clock mux will remain switched until the next system reset.
        #[inline(always)]
        pub fn ext_clock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Volatile raw unlock
        #[inline(always)]
        pub fn volatile_raw_unlock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for TransitionCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionRegwenReadVal(u32);
    impl TransitionRegwenReadVal {
        /// This bit is managed by software and is set to 1 by default. When cleared to 0, the CLAIM_TRANSITION_IF mutex register cannot be written to anymore. Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for TransitionRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionTargetReadVal(u32);
    impl TransitionTargetReadVal {
        /// This field encodes the target life cycle state in a redundant enum format. The 5bit state enum is repeated 6x so that it fills the entire 32bit register. The encoding is straightforward replication: [val, val, val, val, val, val].
        #[inline(always)]
        pub fn state(&self) -> u32 {
            (self.0 >> 0) & 0x3fffffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TransitionTargetWriteVal {
            TransitionTargetWriteVal(self.0)
        }
    }
    impl From<u32> for TransitionTargetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionTargetReadVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionTargetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TransitionTargetWriteVal(u32);
    impl TransitionTargetWriteVal {
        /// This field encodes the target life cycle state in a redundant enum format. The 5bit state enum is repeated 6x so that it fills the entire 32bit register. The encoding is straightforward replication: [val, val, val, val, val, val].
        #[inline(always)]
        pub fn state(self, val: u32) -> Self {
            Self((self.0 & !(0x3fffffff << 0)) | ((val & 0x3fffffff) << 0))
        }
    }
    impl From<u32> for TransitionTargetWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TransitionTargetWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TransitionTargetWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::lc_ctrl::regs::AlertTestWriteVal>;
    pub type Status = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::StatusReadVal>;
    pub type ClaimTransitionIfRegwen = ureg::ReadWriteReg32<
        0,
        crate::lc_ctrl::regs::ClaimTransitionIfRegwenReadVal,
        crate::lc_ctrl::regs::ClaimTransitionIfRegwenWriteVal,
    >;
    pub type ClaimTransitionIf = ureg::ReadWriteReg32<
        0,
        crate::lc_ctrl::regs::ClaimTransitionIfReadVal,
        crate::lc_ctrl::regs::ClaimTransitionIfWriteVal,
    >;
    pub type TransitionRegwen = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::TransitionRegwenReadVal>;
    pub type TransitionCmd = ureg::ReadWriteReg32<
        0,
        crate::lc_ctrl::regs::TransitionCmdReadVal,
        crate::lc_ctrl::regs::TransitionCmdWriteVal,
    >;
    pub type TransitionCtrl = ureg::ReadWriteReg32<
        0,
        crate::lc_ctrl::regs::TransitionCtrlReadVal,
        crate::lc_ctrl::regs::TransitionCtrlWriteVal,
    >;
    pub type TransitionToken0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TransitionToken1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TransitionToken2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TransitionToken3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TransitionTarget = ureg::ReadWriteReg32<
        0,
        crate::lc_ctrl::regs::TransitionTargetReadVal,
        crate::lc_ctrl::regs::TransitionTargetWriteVal,
    >;
    pub type OtpVendorTestCtrl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type OtpVendorTestStatus = ureg::ReadOnlyReg32<u32>;
    pub type LcState = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::LcStateReadVal>;
    pub type LcTransitionCnt = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::LcTransitionCntReadVal>;
    pub type LcIdState = ureg::ReadOnlyReg32<u32>;
    pub type HwRevision0 = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::HwRevision0ReadVal>;
    pub type HwRevision1 = ureg::ReadOnlyReg32<crate::lc_ctrl::regs::HwRevision1ReadVal>;
    pub type DeviceId0 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId1 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId2 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId3 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId4 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId5 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId6 = ureg::ReadOnlyReg32<u32>;
    pub type DeviceId7 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState0 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState1 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState2 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState3 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState4 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState5 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState6 = ureg::ReadOnlyReg32<u32>;
    pub type ManufState7 = ureg::ReadOnlyReg32<u32>;
}

// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 00730026cdf11841d20a6085ea3909ea3bd4a21b
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct AxiDmaReg {
    _priv: (),
}
impl AxiDmaReg {
    pub const PTR: *mut u32 = 0x30022000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Gives a unique identifier that FW can query to verify block base address
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn id(&self) -> ureg::RegRef<crate::axi_dma::meta::Id, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides information about configuration and enabled capabilities for the DMA block.
    ///
    /// Read value: [`axi_dma::regs::CapReadVal`]; Write value: [`axi_dma::regs::CapWriteVal`]
    #[inline(always)]
    pub fn cap(&self) -> ureg::RegRef<crate::axi_dma::meta::Cap, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Used to drive command parameters and initiate operations to DMA block.
    ///
    /// Read value: [`axi_dma::regs::CtrlReadVal`]; Write value: [`axi_dma::regs::CtrlWriteVal`]
    #[inline(always)]
    pub fn ctrl(&self) -> ureg::RegRef<crate::axi_dma::meta::Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports status and diagnostic information for DMA operations.
    ///
    /// Read value: [`axi_dma::regs::Status0ReadVal`]; Write value: [`axi_dma::regs::Status0WriteVal`]
    #[inline(always)]
    pub fn status0(&self) -> ureg::RegRef<crate::axi_dma::meta::Status0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports additional status and diagnostic information for DMA operations.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn status1(&self) -> ureg::RegRef<crate::axi_dma::meta::Status1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Contains lower 32-bits of address from which current operation will read data.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn src_addr_l(&self) -> ureg::RegRef<crate::axi_dma::meta::SrcAddrL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Contains upper 32-bits of address from which current operation will read data.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn src_addr_h(&self) -> ureg::RegRef<crate::axi_dma::meta::SrcAddrH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Contains lower 32-bits of address to which current operation will write data.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn dst_addr_l(&self) -> ureg::RegRef<crate::axi_dma::meta::DstAddrL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Contains upper 32-bits of address to which current operation will write data.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn dst_addr_h(&self) -> ureg::RegRef<crate::axi_dma::meta::DstAddrH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Contains total number of bytes to be transferred by current operation. Must be a multiple of the AXI Data Width. (Narrow/unaligned transfers are not supported)
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn byte_count(&self) -> ureg::RegRef<crate::axi_dma::meta::ByteCount, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Byte size of individual blocks to send as part of the total
    /// Byte Count. This register indicates what granularity of AXI
    /// transactions are issued at a time.
    /// When non-zero, this field instructs the DMA to wait for the
    /// input “WIRE” to pulse high before issuing each transaction.
    /// Total burst is done once “Byte_count/block_size” transactions
    /// have completed.
    /// When zero, DMA issues AXI transactions of maximum size
    /// without any stalls in between transactions.
    /// Must be a multiple of AXI data width. If block size is not
    /// aligned to the AXI data width, it will be rounded down.
    /// Must be a power of 2.
    /// Value of 4096 or larger is unsupported – AXI native maximum size is 4096.
    ///
    /// Read value: [`axi_dma::regs::BlockSizeReadVal`]; Write value: [`axi_dma::regs::BlockSizeWriteVal`]
    #[inline(always)]
    pub fn block_size(&self) -> ureg::RegRef<crate::axi_dma::meta::BlockSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Access point for Caliptra firmware to submit data into the Write
    /// FIFO to be sent as AXI Write transfers.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn write_data(&self) -> ureg::RegRef<crate::axi_dma::meta::WriteData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Access point for Caliptra firmware to read data from the Read
    /// FIFO as it is received via AXI Read transfers.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn read_data(&self) -> ureg::RegRef<crate::axi_dma::meta::ReadData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn intr_block_rf(&self) -> IntrBlockRfBlock<&TMmio> {
        IntrBlockRfBlock {
            ptr: unsafe { self.ptr.add(0x800 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct IntrBlockRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> IntrBlockRfBlock<TMmio> {
    /// Dedicated register with one bit for each event type that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrEnTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrEnTWriteVal`]
    #[inline(always)]
    pub fn global_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfGlobalIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`axi_dma::regs::ErrorIntrEnTReadVal`]; Write value: [`axi_dma::regs::ErrorIntrEnTWriteVal`]
    #[inline(always)]
    pub fn error_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`axi_dma::regs::NotifIntrEnTReadVal`]; Write value: [`axi_dma::regs::NotifIntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn error_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`axi_dma::regs::ErrorIntrTReadVal`]; Write value: [`axi_dma::regs::ErrorIntrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`axi_dma::regs::NotifIntrTReadVal`]; Write value: [`axi_dma::regs::NotifIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`axi_dma::regs::ErrorIntrTrigTReadVal`]; Write value: [`axi_dma::regs::ErrorIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`axi_dma::regs::NotifIntrTrigTReadVal`]; Write value: [`axi_dma::regs::NotifIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_cmd_dec_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorCmdDecIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_axi_rd_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorAxiRdIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_axi_wr_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorAxiWrIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_mbox_lock_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorMboxLockIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_sha_lock_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorShaLockIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_fifo_oflow_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorFifoOflowIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x114 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_fifo_uflow_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorFifoUflowIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x118 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_txn_done_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifTxnDoneIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_fifo_empty_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoEmptyIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x184 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_fifo_not_empty_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoNotEmptyIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x188 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_fifo_full_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoFullIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_fifo_not_full_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoNotFullIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x190 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_cmd_dec_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorCmdDecIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_axi_rd_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorAxiRdIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_axi_wr_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorAxiWrIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x208 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_mbox_lock_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorMboxLockIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_sha_lock_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorShaLockIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x210 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_fifo_oflow_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorFifoOflowIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x214 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_fifo_uflow_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfErrorFifoUflowIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x218 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_txn_done_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifTxnDoneIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x21c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_fifo_empty_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoEmptyIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x220 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_fifo_not_empty_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoNotEmptyIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x224 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_fifo_full_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoFullIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x228 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_fifo_not_full_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::axi_dma::meta::IntrBlockRfNotifFifoNotFullIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x22c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct IntrBlockRf {
    _priv: (),
}
impl IntrBlockRf {
    pub const PTR: *mut u32 = 0x800 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct BlockSizeReadVal(u32);
    impl BlockSizeReadVal {
        /// Block Size
        #[inline(always)]
        pub fn size(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 12) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> BlockSizeWriteVal {
            BlockSizeWriteVal(self.0)
        }
    }
    impl From<u32> for BlockSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<BlockSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: BlockSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct BlockSizeWriteVal(u32);
    impl BlockSizeWriteVal {
        /// Block Size
        #[inline(always)]
        pub fn size(self, val: u32) -> Self {
            Self((self.0 & !(0xfff << 0)) | ((val & 0xfff) << 0))
        }
    }
    impl From<u32> for BlockSizeWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<BlockSizeWriteVal> for u32 {
        #[inline(always)]
        fn from(val: BlockSizeWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CapReadVal(u32);
    impl CapReadVal {
        /// FIFO MAX DEPTH. Indicates number of available slots in the internal FIFO.
        #[inline(always)]
        pub fn fifo_max_depth(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// Reserved
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 12) & 0xfffff
        }
    }
    impl From<u32> for CapReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CapReadVal> for u32 {
        #[inline(always)]
        fn from(val: CapReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CtrlReadVal(u32);
    impl CtrlReadVal {
        /// Initiate current configured operation.
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Flush active operations, reset state machines, clear FIFO data. Any in-flight AXI transactions will be gracefully completed.
        #[inline(always)]
        pub fn flush(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd0(&self) -> u32 {
            (self.0 >> 2) & 0x3fff
        }
        /// Read Route. Configures how the AXI read channel operates for the current operation.
        #[inline(always)]
        pub fn rd_route(&self) -> super::enums::RdRouteE {
            super::enums::RdRouteE::try_from((self.0 >> 16) & 3).unwrap()
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd1(&self) -> u32 {
            (self.0 >> 18) & 3
        }
        /// Read Route uses a FIXED burst type for AXI transaction.
        #[inline(always)]
        pub fn rd_fixed(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd2(&self) -> u32 {
            (self.0 >> 21) & 7
        }
        /// Write Route. Configures how the AXI write channel operates for the current operation.
        #[inline(always)]
        pub fn wr_route(&self) -> super::enums::WrRouteE {
            super::enums::WrRouteE::try_from((self.0 >> 24) & 3).unwrap()
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd3(&self) -> u32 {
            (self.0 >> 26) & 3
        }
        /// Write Route uses a FIXED burst type for AXI transaction.
        #[inline(always)]
        pub fn wr_fixed(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd4(&self) -> u32 {
            (self.0 >> 29) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CtrlWriteVal {
            CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        /// Initiate current configured operation.
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Flush active operations, reset state machines, clear FIFO data. Any in-flight AXI transactions will be gracefully completed.
        #[inline(always)]
        pub fn flush(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Read Route. Configures how the AXI read channel operates for the current operation.
        #[inline(always)]
        pub fn rd_route(
            self,
            f: impl FnOnce(super::enums::selector::RdRouteESelector) -> super::enums::RdRouteE,
        ) -> Self {
            Self(
                (self.0 & !(3 << 16))
                    | (u32::from(f(super::enums::selector::RdRouteESelector())) << 16),
            )
        }
        /// Read Route uses a FIXED burst type for AXI transaction.
        #[inline(always)]
        pub fn rd_fixed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Write Route. Configures how the AXI write channel operates for the current operation.
        #[inline(always)]
        pub fn wr_route(
            self,
            f: impl FnOnce(super::enums::selector::WrRouteESelector) -> super::enums::WrRouteE,
        ) -> Self {
            Self(
                (self.0 & !(3 << 24))
                    | (u32::from(f(super::enums::selector::WrRouteESelector())) << 24),
            )
        }
        /// Write Route uses a FIXED burst type for AXI transaction.
        #[inline(always)]
        pub fn wr_fixed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
    }
    impl From<u32> for CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTReadVal(u32);
    impl ErrorIntrEnTReadVal {
        /// Enable bit for Command Decode Error
        #[inline(always)]
        pub fn error_cmd_dec_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for AXI Read Error
        #[inline(always)]
        pub fn error_axi_rd_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for AXI Write Error
        #[inline(always)]
        pub fn error_axi_wr_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for Mailbox Not Locked Error
        #[inline(always)]
        pub fn error_mbox_lock_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for SHA Accel Not Locked Error
        #[inline(always)]
        pub fn error_sha_lock_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit for FIFO Overflow
        #[inline(always)]
        pub fn error_fifo_oflow_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable bit for FIFO Underflow
        #[inline(always)]
        pub fn error_fifo_uflow_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrEnTWriteVal {
            ErrorIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTWriteVal(u32);
    impl ErrorIntrEnTWriteVal {
        /// Enable bit for Command Decode Error
        #[inline(always)]
        pub fn error_cmd_dec_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for AXI Read Error
        #[inline(always)]
        pub fn error_axi_rd_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for AXI Write Error
        #[inline(always)]
        pub fn error_axi_wr_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for Mailbox Not Locked Error
        #[inline(always)]
        pub fn error_mbox_lock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for SHA Accel Not Locked Error
        #[inline(always)]
        pub fn error_sha_lock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit for FIFO Overflow
        #[inline(always)]
        pub fn error_fifo_oflow_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable bit for FIFO Underflow
        #[inline(always)]
        pub fn error_fifo_uflow_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
    }
    impl From<u32> for ErrorIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTReadVal(u32);
    impl ErrorIntrTReadVal {
        /// Command Decode Error status bit
        #[inline(always)]
        pub fn error_cmd_dec_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// AXI Read Error status bit
        #[inline(always)]
        pub fn error_axi_rd_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// AXI Write Error status bit
        #[inline(always)]
        pub fn error_axi_wr_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Mailbox Not Locked Error status bit
        #[inline(always)]
        pub fn error_mbox_lock_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// SHA Accel Not Locked Error status bit
        #[inline(always)]
        pub fn error_sha_lock_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// FIFO Overflow status bit
        #[inline(always)]
        pub fn error_fifo_oflow_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// FIFO Underflow status bit
        #[inline(always)]
        pub fn error_fifo_uflow_sts(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTWriteVal {
            ErrorIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTWriteVal(u32);
    impl ErrorIntrTWriteVal {
        /// Command Decode Error status bit
        #[inline(always)]
        pub fn error_cmd_dec_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// AXI Read Error status bit
        #[inline(always)]
        pub fn error_axi_rd_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// AXI Write Error status bit
        #[inline(always)]
        pub fn error_axi_wr_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Mailbox Not Locked Error status bit
        #[inline(always)]
        pub fn error_mbox_lock_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// SHA Accel Not Locked Error status bit
        #[inline(always)]
        pub fn error_sha_lock_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// FIFO Overflow status bit
        #[inline(always)]
        pub fn error_fifo_oflow_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// FIFO Underflow status bit
        #[inline(always)]
        pub fn error_fifo_uflow_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
    }
    impl From<u32> for ErrorIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTReadVal(u32);
    impl ErrorIntrTrigTReadVal {
        /// Command Decode Error trigger bit
        #[inline(always)]
        pub fn error_cmd_dec_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// AXI Read Error trigger bit
        #[inline(always)]
        pub fn error_axi_rd_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// AXI Write Error trigger bit
        #[inline(always)]
        pub fn error_axi_wr_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Mailbox Not Locked Error trigger bit
        #[inline(always)]
        pub fn error_mbox_lock_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// SHA Accel Not Locked Error trigger bit
        #[inline(always)]
        pub fn error_sha_lock_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// FIFO Overflow trigger bit
        #[inline(always)]
        pub fn error_fifo_oflow_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// FIFO Underflow trigger bit
        #[inline(always)]
        pub fn error_fifo_uflow_trig(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTrigTWriteVal {
            ErrorIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTWriteVal(u32);
    impl ErrorIntrTrigTWriteVal {
        /// Command Decode Error trigger bit
        #[inline(always)]
        pub fn error_cmd_dec_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// AXI Read Error trigger bit
        #[inline(always)]
        pub fn error_axi_rd_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// AXI Write Error trigger bit
        #[inline(always)]
        pub fn error_axi_wr_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Mailbox Not Locked Error trigger bit
        #[inline(always)]
        pub fn error_mbox_lock_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// SHA Accel Not Locked Error trigger bit
        #[inline(always)]
        pub fn error_sha_lock_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// FIFO Overflow trigger bit
        #[inline(always)]
        pub fn error_fifo_oflow_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// FIFO Underflow trigger bit
        #[inline(always)]
        pub fn error_fifo_uflow_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
    }
    impl From<u32> for ErrorIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTReadVal(u32);
    impl NotifIntrEnTReadVal {
        /// Enable bit for Transaction Done
        #[inline(always)]
        pub fn notif_txn_done_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for FIFO Empty
        #[inline(always)]
        pub fn notif_fifo_empty_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for FIFO Not Empty
        #[inline(always)]
        pub fn notif_fifo_not_empty_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for FIFO Full
        #[inline(always)]
        pub fn notif_fifo_full_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for FIFO Not Full
        #[inline(always)]
        pub fn notif_fifo_not_full_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrEnTWriteVal {
            NotifIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTWriteVal(u32);
    impl NotifIntrEnTWriteVal {
        /// Enable bit for Transaction Done
        #[inline(always)]
        pub fn notif_txn_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for FIFO Empty
        #[inline(always)]
        pub fn notif_fifo_empty_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for FIFO Not Empty
        #[inline(always)]
        pub fn notif_fifo_not_empty_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for FIFO Full
        #[inline(always)]
        pub fn notif_fifo_full_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for FIFO Not Full
        #[inline(always)]
        pub fn notif_fifo_not_full_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for NotifIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTReadVal(u32);
    impl NotifIntrTReadVal {
        /// Transaction Done status bit
        #[inline(always)]
        pub fn notif_txn_done_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FIFO Empty status bit
        #[inline(always)]
        pub fn notif_fifo_empty_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// FIFO Not Empty status bit
        #[inline(always)]
        pub fn notif_fifo_not_empty_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// FIFO Full status bit
        #[inline(always)]
        pub fn notif_fifo_full_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// FIFO Not Full status bit
        #[inline(always)]
        pub fn notif_fifo_not_full_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTWriteVal {
            NotifIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTWriteVal(u32);
    impl NotifIntrTWriteVal {
        /// Transaction Done status bit
        #[inline(always)]
        pub fn notif_txn_done_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// FIFO Empty status bit
        #[inline(always)]
        pub fn notif_fifo_empty_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// FIFO Not Empty status bit
        #[inline(always)]
        pub fn notif_fifo_not_empty_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// FIFO Full status bit
        #[inline(always)]
        pub fn notif_fifo_full_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// FIFO Not Full status bit
        #[inline(always)]
        pub fn notif_fifo_not_full_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for NotifIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTReadVal(u32);
    impl NotifIntrTrigTReadVal {
        /// Transaction Done trigger bit
        #[inline(always)]
        pub fn notif_txn_done_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FIFO Empty trigger bit
        #[inline(always)]
        pub fn notif_fifo_empty_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// FIFO Not Empty trigger bit
        #[inline(always)]
        pub fn notif_fifo_not_empty_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// FIFO Full trigger bit
        #[inline(always)]
        pub fn notif_fifo_full_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// FIFO Not Full trigger bit
        #[inline(always)]
        pub fn notif_fifo_not_full_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTrigTWriteVal {
            NotifIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTWriteVal(u32);
    impl NotifIntrTrigTWriteVal {
        /// Transaction Done trigger bit
        #[inline(always)]
        pub fn notif_txn_done_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// FIFO Empty trigger bit
        #[inline(always)]
        pub fn notif_fifo_empty_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// FIFO Not Empty trigger bit
        #[inline(always)]
        pub fn notif_fifo_not_empty_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// FIFO Full trigger bit
        #[inline(always)]
        pub fn notif_fifo_full_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// FIFO Not Full trigger bit
        #[inline(always)]
        pub fn notif_fifo_not_full_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for NotifIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Status0ReadVal(u32);
    impl Status0ReadVal {
        /// Indicates if an operation is in progress. When 1, new requests are ignored. When 0, new requests are accepted.
        #[inline(always)]
        pub fn busy(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Indicates if an operation has failed due to an error in decoding the command.
        /// When set, this field will prevent any further operations until it is cleared by setting the ctrl.flush field.
        #[inline(always)]
        pub fn error(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd0(&self) -> u32 {
            (self.0 >> 2) & 3
        }
        /// FIFO DEPTH. Indicates number of populated slots in the internal FIFO.
        #[inline(always)]
        pub fn fifo_depth(&self) -> u32 {
            (self.0 >> 4) & 0xfff
        }
        /// Indicates the present state of the Caliptra AXI DMA FSM.
        #[inline(always)]
        pub fn axi_dma_fsm_ps(&self) -> super::enums::AxiDmaFsmE {
            super::enums::AxiDmaFsmE::try_from((self.0 >> 16) & 3).unwrap()
        }
        /// Payload Available. Signal indicates data is available.
        /// When the DMA is active and was armed with nonzero block
        /// size, this is used by the hardware to automatically
        /// trigger AXI transactions of the specified block
        /// size, until the total byte count is transferred.
        #[inline(always)]
        pub fn payload_available(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Image Activated. Signal indicates image activation status
        /// reported by Recovery Interface (from Caliptra Subsystem).
        #[inline(always)]
        pub fn image_activated(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// RESERVED.
        #[inline(always)]
        pub fn rsvd1(&self) -> u32 {
            (self.0 >> 20) & 0xfff
        }
    }
    impl From<u32> for Status0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Status0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Status0ReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum AxiDmaFsmE {
        DmaIdle = 0,
        DmaWaitData = 1,
        DmaDone = 2,
        DmaError = 3,
    }
    impl AxiDmaFsmE {
        #[inline(always)]
        pub fn dma_idle(&self) -> bool {
            *self == Self::DmaIdle
        }
        #[inline(always)]
        pub fn dma_wait_data(&self) -> bool {
            *self == Self::DmaWaitData
        }
        #[inline(always)]
        pub fn dma_done(&self) -> bool {
            *self == Self::DmaDone
        }
        #[inline(always)]
        pub fn dma_error(&self) -> bool {
            *self == Self::DmaError
        }
    }
    impl TryFrom<u32> for AxiDmaFsmE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<AxiDmaFsmE, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute::<u32, AxiDmaFsmE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<AxiDmaFsmE> for u32 {
        fn from(val: AxiDmaFsmE) -> Self {
            val as u32
        }
    }
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum RdRouteE {
        Disable = 0,
        Mbox = 1,
        AhbFifo = 2,
        AxiWr = 3,
    }
    impl RdRouteE {
        #[inline(always)]
        pub fn disable(&self) -> bool {
            *self == Self::Disable
        }
        #[inline(always)]
        pub fn mbox(&self) -> bool {
            *self == Self::Mbox
        }
        #[inline(always)]
        pub fn ahb_fifo(&self) -> bool {
            *self == Self::AhbFifo
        }
        #[inline(always)]
        pub fn axi_wr(&self) -> bool {
            *self == Self::AxiWr
        }
    }
    impl TryFrom<u32> for RdRouteE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<RdRouteE, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute::<u32, RdRouteE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<RdRouteE> for u32 {
        fn from(val: RdRouteE) -> Self {
            val as u32
        }
    }
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum WrRouteE {
        Disable = 0,
        Mbox = 1,
        AhbFifo = 2,
        AxiRd = 3,
    }
    impl WrRouteE {
        #[inline(always)]
        pub fn disable(&self) -> bool {
            *self == Self::Disable
        }
        #[inline(always)]
        pub fn mbox(&self) -> bool {
            *self == Self::Mbox
        }
        #[inline(always)]
        pub fn ahb_fifo(&self) -> bool {
            *self == Self::AhbFifo
        }
        #[inline(always)]
        pub fn axi_rd(&self) -> bool {
            *self == Self::AxiRd
        }
    }
    impl TryFrom<u32> for WrRouteE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<WrRouteE, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute::<u32, WrRouteE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<WrRouteE> for u32 {
        fn from(val: WrRouteE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct AxiDmaFsmESelector();
        impl AxiDmaFsmESelector {
            #[inline(always)]
            pub fn dma_idle(&self) -> super::AxiDmaFsmE {
                super::AxiDmaFsmE::DmaIdle
            }
            #[inline(always)]
            pub fn dma_wait_data(&self) -> super::AxiDmaFsmE {
                super::AxiDmaFsmE::DmaWaitData
            }
            #[inline(always)]
            pub fn dma_done(&self) -> super::AxiDmaFsmE {
                super::AxiDmaFsmE::DmaDone
            }
            #[inline(always)]
            pub fn dma_error(&self) -> super::AxiDmaFsmE {
                super::AxiDmaFsmE::DmaError
            }
        }
        pub struct RdRouteESelector();
        impl RdRouteESelector {
            #[inline(always)]
            pub fn disable(&self) -> super::RdRouteE {
                super::RdRouteE::Disable
            }
            #[inline(always)]
            pub fn mbox(&self) -> super::RdRouteE {
                super::RdRouteE::Mbox
            }
            #[inline(always)]
            pub fn ahb_fifo(&self) -> super::RdRouteE {
                super::RdRouteE::AhbFifo
            }
            #[inline(always)]
            pub fn axi_wr(&self) -> super::RdRouteE {
                super::RdRouteE::AxiWr
            }
        }
        pub struct WrRouteESelector();
        impl WrRouteESelector {
            #[inline(always)]
            pub fn disable(&self) -> super::WrRouteE {
                super::WrRouteE::Disable
            }
            #[inline(always)]
            pub fn mbox(&self) -> super::WrRouteE {
                super::WrRouteE::Mbox
            }
            #[inline(always)]
            pub fn ahb_fifo(&self) -> super::WrRouteE {
                super::WrRouteE::AhbFifo
            }
            #[inline(always)]
            pub fn axi_rd(&self) -> super::WrRouteE {
                super::WrRouteE::AxiRd
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type Id = ureg::ReadOnlyReg32<u32>;
    pub type Cap = ureg::ReadOnlyReg32<crate::axi_dma::regs::CapReadVal>;
    pub type Ctrl = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::CtrlReadVal,
        crate::axi_dma::regs::CtrlWriteVal,
    >;
    pub type Status0 = ureg::ReadOnlyReg32<crate::axi_dma::regs::Status0ReadVal>;
    pub type Status1 = ureg::ReadOnlyReg32<u32>;
    pub type SrcAddrL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SrcAddrH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DstAddrL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DstAddrH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ByteCount = ureg::ReadWriteReg32<0, u32, u32>;
    pub type BlockSize = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::BlockSizeReadVal,
        crate::axi_dma::regs::BlockSizeWriteVal,
    >;
    pub type WriteData = ureg::WriteOnlyReg32<0, u32>;
    pub type ReadData = ureg::ReadOnlyReg32<u32>;
    pub type IntrBlockRfGlobalIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::GlobalIntrEnTReadVal,
        crate::sha512_acc::regs::GlobalIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::ErrorIntrEnTReadVal,
        crate::axi_dma::regs::ErrorIntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::NotifIntrEnTReadVal,
        crate::axi_dma::regs::NotifIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfNotifGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfErrorInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::ErrorIntrTReadVal,
        crate::axi_dma::regs::ErrorIntrTWriteVal,
    >;
    pub type IntrBlockRfNotifInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::NotifIntrTReadVal,
        crate::axi_dma::regs::NotifIntrTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::ErrorIntrTrigTReadVal,
        crate::axi_dma::regs::ErrorIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::axi_dma::regs::NotifIntrTrigTReadVal,
        crate::axi_dma::regs::NotifIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfErrorCmdDecIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAxiRdIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAxiWrIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorMboxLockIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorShaLockIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorFifoOflowIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorFifoUflowIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifTxnDoneIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifFifoEmptyIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifFifoNotEmptyIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifFifoFullIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifFifoNotFullIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorCmdDecIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAxiRdIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAxiWrIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorMboxLockIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorShaLockIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorFifoOflowIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorFifoUflowIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifTxnDoneIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifFifoEmptyIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifFifoNotEmptyIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifFifoFullIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifFifoNotFullIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
}

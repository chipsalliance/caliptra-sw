// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 19dc3e00572423ca5ed03633f38f70a4592cb56c
//
#![allow(clippy::doc_lazy_continuation)]
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct MciReg {
    _priv: (),
}
impl MciReg {
    pub const PTR: *mut u32 = 0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// MCU HW Capabilities. Initialized with reset values, rewritable by MCU FW.
    /// [br]Read-only once locked.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hw_capabilities(&self) -> ureg::RegRef<crate::mci::meta::HwCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU FW Capabilities. Initialized with reset values. rewrtitable by MCU FW.
    /// [br]Read-only once locked.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_capabilities(&self) -> ureg::RegRef<crate::mci::meta::FwCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Lock register to disable further firmware modifications to capabilities registers.
    /// [br]Once set, this register may not be cleared until a warm reset. If set, the values in HW_CAPABILITIES and FW_CAPABILITIES may not be modified.
    /// [br]Read-only once locked.
    ///
    /// Read value: [`mci::regs::CapLockReadVal`]; Write value: [`mci::regs::CapLockWriteVal`]
    #[inline(always)]
    pub fn cap_lock(&self) -> ureg::RegRef<crate::mci::meta::CapLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// HW revision ID for Manufacturer Control components (MCU & MCI) that matches the official
    /// final release milestone of Caliptra Subsystem.
    ///
    /// Read value: [`mci::regs::HwRevIdReadVal`]; Write value: [`mci::regs::HwRevIdWriteVal`]
    #[inline(always)]
    pub fn hw_rev_id(&self) -> ureg::RegRef<crate::mci::meta::HwRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU FW revision ID
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_rev_id(&self) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::FwRevId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU HW Configuration
    ///
    /// Read value: [`mci::regs::HwConfig0ReadVal`]; Write value: [`mci::regs::HwConfig0WriteVal`]
    #[inline(always)]
    pub fn hw_config0(&self) -> ureg::RegRef<crate::mci::meta::HwConfig0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU HW Configuration
    ///
    /// Read value: [`mci::regs::HwConfig1ReadVal`]; Write value: [`mci::regs::HwConfig1WriteVal`]
    #[inline(always)]
    pub fn hw_config1(&self) -> ureg::RegRef<crate::mci::meta::HwConfig1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU IFU AXI USER Strap
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_ifu_axi_user(&self) -> ureg::RegRef<crate::mci::meta::McuIfuAxiUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU LSU AXI USER Strap
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_lsu_axi_user(&self) -> ureg::RegRef<crate::mci::meta::McuLsuAxiUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Agent with access to MCU SRAM Execution region. Typically Caliptra Core
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_sram_config_axi_user(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::McuSramConfigAxiUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SOC agent with special access to MCI register bank
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_config_axi_user(&self) -> ureg::RegRef<crate::mci::meta::SocConfigAxiUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of the firmware flows.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_flow_status(&self) -> ureg::RegRef<crate::mci::meta::FwFlowStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of HW FSMs and other flows.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::HwFlowStatusReadVal`]; Write value: [`mci::regs::HwFlowStatusWriteVal`]
    #[inline(always)]
    pub fn hw_flow_status(&self) -> ureg::RegRef<crate::mci::meta::HwFlowStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates to ROM the originating cause for the PC to be reset to 0.
    /// Firmware Update Reset indicator is reset by the warm reset and updated by SW applying MCU FW updated.
    /// Warm Reset indicator is reset by the cold reset.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::ResetReasonReadVal`]; Write value: [`mci::regs::ResetReasonWriteVal`]
    #[inline(always)]
    pub fn reset_reason(&self) -> ureg::RegRef<crate::mci::meta::ResetReason, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of the rests controlled by MCI.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::ResetStatusReadVal`]; Write value: [`mci::regs::ResetStatusWriteVal`]
    #[inline(always)]
    pub fn reset_status(&self) -> ureg::RegRef<crate::mci::meta::ResetStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates current hardware security state.
    ///
    /// Read value: [`mci::regs::SecurityStateReadVal`]; Write value: [`mci::regs::SecurityStateWriteVal`]
    #[inline(always)]
    pub fn security_state(&self) -> ureg::RegRef<crate::mci::meta::SecurityState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only an MCI reset will clear the fatal error interrupt.
    /// [br]AXI Access:      RW1C
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::HwErrorFatalReadVal`]; Write value: [`mci::regs::HwErrorFatalWriteVal`]
    #[inline(always)]
    pub fn hw_error_fatal(&self) -> ureg::RegRef<crate::mci::meta::HwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal error from another IP within Caliptra SS. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only an MCI reset will clear the fatal error interrupt.
    /// [br]AXI Access: RW1C
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::AggErrorFatalReadVal`]; Write value: [`mci::regs::AggErrorFatalWriteVal`]
    #[inline(always)]
    pub fn agg_error_fatal(&self) -> ureg::RegRef<crate::mci::meta::AggErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    /// [br]AXI Access:      RW1C
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::HwErrorNonFatalReadVal`]; Write value: [`mci::regs::HwErrorNonFatalWriteVal`]
    #[inline(always)]
    pub fn hw_error_non_fatal(&self) -> ureg::RegRef<crate::mci::meta::HwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal error from another IP within the Caliptra SS. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    /// [br]AXI Access:      RW1C
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`mci::regs::AggErrorNonFatalReadVal`]; Write value: [`mci::regs::AggErrorNonFatalWriteVal`]
    #[inline(always)]
    pub fn agg_error_non_fatal(&self) -> ureg::RegRef<crate::mci::meta::AggErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only an MCI reset will clear the fatal error interrupt.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_error_fatal(&self) -> ureg::RegRef<crate::mci::meta::FwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_error_non_fatal(&self) -> ureg::RegRef<crate::mci::meta::FwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for hardware errors.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hw_error_enc(&self) -> ureg::RegRef<crate::mci::meta::HwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for firmware errors.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_error_enc(&self) -> ureg::RegRef<crate::mci::meta::FwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x6c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Firmware Extended Error information for firmware errors.
    /// [br]TAP Access [with debug intent set]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_extended_error_info(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::mci::meta::FwExtendedErrorInfo, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register HW_ERROR_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in HW_ERROR_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set and was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Firmware can not cause the interrupt output to deassert by setting
    /// mask bits for fatal error conditions that have already triggered the
    /// interrupt.
    ///
    /// Read value: [`mci::regs::InternalHwErrorFatalMaskReadVal`]; Write value: [`mci::regs::InternalHwErrorFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_hw_error_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalHwErrorFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x90 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register HW_ERROR_NON_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_non_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in HW_ERROR_NON_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set that was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Any change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    ///
    /// Read value: [`mci::regs::InternalHwErrorNonFatalMaskReadVal`]; Write value: [`mci::regs::InternalHwErrorNonFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_hw_error_non_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalHwErrorNonFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x94 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register AGG_ERROR_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in AGG_ERROR_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set and was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Firmware can not cause the interrupt output to deassert by setting
    /// mask bits for fatal error conditions that have already triggered the
    /// interrupt.
    ///
    /// Read value: [`mci::regs::InternalAggErrorFatalMaskReadVal`]; Write value: [`mci::regs::InternalAggErrorFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_agg_error_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalAggErrorFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x98 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register AGG_ERROR_NON_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_non_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in AGG_ERROR_NON_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set that was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Any change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    ///
    /// Read value: [`mci::regs::InternalAggErrorNonFatalMaskReadVal`]; Write value: [`mci::regs::InternalAggErrorNonFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_agg_error_non_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalAggErrorNonFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x9c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register FW_ERROR_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in FW_ERROR_FATAL will not produce an interrupt
    /// output assertion. If a firmware error bit is set and was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error bit being cleared then set again while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Firmware can not cause the interrupt output to deassert by setting
    /// mask bits for fatal error conditions that have already triggered the
    /// interrupt.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_fw_error_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalFwErrorFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register FW_ERROR_NON_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// mci_error_non_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in FW_ERROR_NON_FATAL will not produce an interrupt
    /// output assertion. If a firmware error bit is set that was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error bit being cleared then set again while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Any change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] AGG_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] agg_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_fw_error_non_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::InternalFwErrorNonFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 enable register
    ///
    /// Read value: [`mci::regs::WdtTimer1EnReadVal`]; Write value: [`mci::regs::WdtTimer1EnWriteVal`]
    #[inline(always)]
    pub fn wdt_timer1_en(&self) -> ureg::RegRef<crate::mci::meta::WdtTimer1En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 control register
    ///
    /// Read value: [`mci::regs::WdtTimer1CtrlReadVal`]; Write value: [`mci::regs::WdtTimer1CtrlWriteVal`]
    #[inline(always)]
    pub fn wdt_timer1_ctrl(&self) -> ureg::RegRef<crate::mci::meta::WdtTimer1Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 timeout register
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_timer1_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::WdtTimer1TimeoutPeriod, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xb8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 enable register. Note: Setting this to 1 will disable the default cascaded mode and will have both timers count independently.
    ///
    /// Read value: [`mci::regs::WdtTimer2EnReadVal`]; Write value: [`mci::regs::WdtTimer2EnWriteVal`]
    #[inline(always)]
    pub fn wdt_timer2_en(&self) -> ureg::RegRef<crate::mci::meta::WdtTimer2En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 control register
    ///
    /// Read value: [`mci::regs::WdtTimer2CtrlReadVal`]; Write value: [`mci::regs::WdtTimer2CtrlWriteVal`]
    #[inline(always)]
    pub fn wdt_timer2_ctrl(&self) -> ureg::RegRef<crate::mci::meta::WdtTimer2Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 timeout register
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_timer2_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::WdtTimer2TimeoutPeriod, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xc8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer status register
    ///
    /// Read value: [`mci::regs::WdtStatusReadVal`]; Write value: [`mci::regs::WdtStatusWriteVal`]
    #[inline(always)]
    pub fn wdt_status(&self) -> ureg::RegRef<crate::mci::meta::WdtStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SOC provided count in cycles for WDT1 timeout.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_cfg(&self) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::WdtCfg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xd4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides the clock period of the system clock.
    /// Used to standardize the RISC-V Standard MTIME count register.
    /// Clock Period is indicated as an integer number of picoseconds.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_timer_config(&self) -> ureg::RegRef<crate::mci::meta::McuTimerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter, lower 32-bits.
    /// [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_rv_mtime_l(&self) -> ureg::RegRef<crate::mci::meta::McuRvMtimeL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter, upper 32-bits.
    /// [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_rv_mtime_h(&self) -> ureg::RegRef<crate::mci::meta::McuRvMtimeH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter Compare Value, lower 32-bits.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_rv_mtimecmp_l(&self) -> ureg::RegRef<crate::mci::meta::McuRvMtimecmpL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xec / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter Compare Value, upper 32-bits.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_rv_mtimecmp_h(&self) -> ureg::RegRef<crate::mci::meta::McuRvMtimecmpH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xf0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci::regs::ResetRequestReadVal`]; Write value: [`mci::regs::ResetRequestWriteVal`]
    #[inline(always)]
    pub fn reset_request(&self) -> ureg::RegRef<crate::mci::meta::ResetRequest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Request MCI BootFSM to continue past the breakpoint allowing MCU and Caliptra to be brought out of reset.
    /// [br]TAP Access [with debug intent set]: RW
    ///
    /// Read value: [`mci::regs::GoReadVal`]; Write value: [`mci::regs::GoWriteVal`]
    #[inline(always)]
    pub fn bootfsm_go(&self) -> ureg::RegRef<crate::mci::meta::BootfsmGo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Request Caliptra Reset to be deasserted by the MCI Boot FSM.
    /// [br]TAP Access [in debug mode]: RW
    ///
    /// Read value: [`mci::regs::GoReadVal`]; Write value: [`mci::regs::GoWriteVal`]
    #[inline(always)]
    pub fn cptra_boot_go(&self) -> ureg::RegRef<crate::mci::meta::CptraBootGo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dynamic size assignment for the region of sram that contains executable instructions for MCU. Locked when SS_CONFIG_DONE is set.
    /// [br]TAP Access [in debug mode]: RW
    ///
    /// Read value: [`mci::regs::FwSramExecRegionSizeReadVal`]; Write value: [`mci::regs::FwSramExecRegionSizeWriteVal`]
    #[inline(always)]
    pub fn fw_sram_exec_region_size(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::FwSramExecRegionSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
    /// Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
    /// Bit [0] is ignored to enforce half-word alignment of address.
    /// [br]TAP Access [in debug mode]: RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_nmi_vector(&self) -> ureg::RegRef<crate::mci::meta::McuNmiVector, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit register providing the reset vector for RISC-V do the initial fetch.
    /// Default is determined by a HW strap strap_mcu_reset_vector and is sampled on mci_rst_b deassertions, but may be modified by SW while in debug mode.
    /// Bit [0] is ignored to enforce half-word alignment of address.
    /// [br]TAP Access [in debug mode]: RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_reset_vector(&self) -> ureg::RegRef<crate::mci::meta::McuResetVector, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x114 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid AXI USER attributes for requests from SoC AXI Interface. Only valid once LOCK is set.
    /// [br]Read-Only once locked by AXI_USER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox0_valid_axi_user(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci::meta::Mbox0ValidAxiUser, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid AXI_USER attributes for requests from SoC AXI Interface.
    /// [br]Each bit corresponds to locking the associated MBO0X_VALID_AXI_USER register.
    /// [br]Associated MBOX0_VALID_AXI_USER register is only valid once locked by this bit.
    /// [br]AXI Access:      RW1-S
    /// [br]Read-Only once locked.
    ///
    /// Read value: [`mci::regs::MboxxAxiUserLockReadVal`]; Write value: [`mci::regs::MboxxAxiUserLockWriteVal`]
    #[inline(always)]
    pub fn mbox0_axi_user_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci::meta::Mbox0AxiUserLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1a0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid AXI USER attributes for requests from SoC AXI Interface. Only valid once LOCK is set.
    /// [br]Read-Only once locked by AXI_USER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox1_valid_axi_user(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci::meta::Mbox1ValidAxiUser, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1c0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid AXI_USER attributes for requests from SoC AXI Interface.
    /// [br]Each bit corresponds to locking the associated MBO0X_VALID_AXI_USER register.
    /// [br]Associated MBOX0_VALID_AXI_USER register is only valid once locked by this bit.
    /// [br]AXI Access:      RW1-S
    /// [br]Read-Only once locked.
    ///
    /// Read value: [`mci::regs::MboxxAxiUserLockReadVal`]; Write value: [`mci::regs::MboxxAxiUserLockWriteVal`]
    #[inline(always)]
    pub fn mbox1_axi_user_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci::meta::Mbox1AxiUserLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1e0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable DFT for the SOC.
    /// [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, SOC_DFT_EN will be enabled.
    /// [br]Otherwise SOC_DFT_EN can only be set via LCC.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_dft_en(&self) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::SocDftEn, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x300 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable HW Debug for the SOC.
    /// [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, SOC_HW_DEBUG_EN will be enabled.
    /// [br]Otherwise SOC_HW_DEBUG_EN can only be set via LCC.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_hw_debug_en(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::SocHwDebugEn, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x308 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable Production Debug Mode State.
    /// [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, Security State will transition to Production Debug Mode from Production Non-Debug state.
    /// [br]Otherwise Production Debug Mode can only be entered via LCC.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_prod_debug_state(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::SocProdDebugState, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x310 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Masks SOC's cptra_ss_FIPS_ZEROIZATION_PPD_i to send zeroization request to the Fuse Controller. This bit shall be set by MCU ROM and is locked via SS_CONFIG_DONE.
    /// [br]If any bit is set to 0, FIPS_ZEROIZATION_PPD_i is masked and no command is sent to the Fuse Controller.
    /// [br]If all bits are set to 1 and FPIS_ZEROIZATION_PPD_i is set, FIPS zeriozation command sent to the Fuse Controller.
    /// [br]Once SS_CONFIG_DONE is set, this register is read-only.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fc_fips_zerozation(&self) -> ureg::RegRef<crate::mci::meta::FcFipsZerozation, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x318 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic input wires connected to SoC interface.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn generic_input_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::GenericInputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic output wires connected to SoC interface.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn generic_output_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci::meta::GenericOutputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x408 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn debug_in(&self) -> ureg::RegRef<crate::mci::meta::DebugIn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x410 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn debug_out(&self) -> ureg::RegRef<crate::mci::meta::DebugOut, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x414 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Strap from SoC in Subsystem configuration that indicates if this boot cycle will be used for debug. In passive mode this register always reflects a value of 0.
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`mci::regs::SsDebugIntentReadVal`]; Write value: [`mci::regs::SsDebugIntentWriteVal`]
    #[inline(always)]
    pub fn ss_debug_intent(&self) -> ureg::RegRef<crate::mci::meta::SsDebugIntent, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x418 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set to indicate that all sticky configuration registers have been populated in MCI.
    /// Locks configuration registers from further modification.
    /// [br]Sticky until cold reset once set.
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`mci::regs::SsConfigDoneReadVal`]; Write value: [`mci::regs::SsConfigDoneWriteVal`]
    #[inline(always)]
    pub fn ss_config_done_sticky(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::SsConfigDoneSticky, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x440 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set to indicate that all configuration registers have been populated in MCI.
    /// Locks configuration registers from further modification.
    /// [br]Sticky until warm reset once set.
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`mci::regs::SsConfigDoneReadVal`]; Write value: [`mci::regs::SsConfigDoneWriteVal`]
    #[inline(always)]
    pub fn ss_config_done(&self) -> ureg::RegRef<crate::mci::meta::SsConfigDone, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x444 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Production Debug Unlock PK HASH. Configured by MCU and locked when SS_CONFIG_DONE_STICKY is set.
    /// Once SS_CONFIG_DONE_STICKY is set value persists until cold reset.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prod_debug_unlock_pk_hash_reg(
        &self,
    ) -> ureg::Array<
        8,
        ureg::Array<12, ureg::RegRef<crate::mci::meta::ProdDebugUnlockPkHashReg, &TMmio>>,
    > {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x480 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn intr_block_rf(&self) -> IntrBlockRfBlock<&TMmio> {
        IntrBlockRfBlock {
            ptr: unsafe { self.ptr.add(0x1000 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct IntrBlockRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> IntrBlockRfBlock<TMmio> {
    /// Dedicated register with one bit for each event type that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrEnTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrEnTWriteVal`]
    #[inline(always)]
    pub fn global_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfGlobalIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`mci::regs::Error0IntrEnTReadVal`]; Write value: [`mci::regs::Error0IntrEnTWriteVal`]
    #[inline(always)]
    pub fn error0_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError0IntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`mci::regs::Error1IntrEnTReadVal`]; Write value: [`mci::regs::Error1IntrEnTWriteVal`]
    #[inline(always)]
    pub fn error1_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError1IntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`mci::regs::Notif0IntrEnTReadVal`]; Write value: [`mci::regs::Notif0IntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif0_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif0IntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`mci::regs::Notif1IntrEnTReadVal`]; Write value: [`mci::regs::Notif1IntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif1_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif1IntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`mci::regs::GlobalIntrTReadVal`]; Write value: [`mci::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn error_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`mci::regs::GlobalIntrTReadVal`]; Write value: [`mci::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`mci::regs::Error0IntrTReadVal`]; Write value: [`mci::regs::Error0IntrTWriteVal`]
    #[inline(always)]
    pub fn error0_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError0InternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`mci::regs::Error1IntrTReadVal`]; Write value: [`mci::regs::Error1IntrTWriteVal`]
    #[inline(always)]
    pub fn error1_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError1InternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`mci::regs::Notif0IntrTReadVal`]; Write value: [`mci::regs::Notif0IntrTWriteVal`]
    #[inline(always)]
    pub fn notif0_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif0InternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`mci::regs::Notif1IntrTReadVal`]; Write value: [`mci::regs::Notif1IntrTWriteVal`]
    #[inline(always)]
    pub fn notif1_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif1InternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`mci::regs::Error0IntrTrigTReadVal`]; Write value: [`mci::regs::Error0IntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error0_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError0IntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`mci::regs::Error1IntrTrigTReadVal`]; Write value: [`mci::regs::Error1IntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error1_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfError1IntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`mci::regs::Notif0IntrTrigTReadVal`]; Write value: [`mci::regs::Notif0IntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif0_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif0IntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`mci::regs::Notif1IntrTrigTReadVal`]; Write value: [`mci::regs::Notif1IntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif1_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotif1IntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_internal_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorInternalIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_mbox0_ecc_unc_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMbox0EccUncIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_mbox1_ecc_unc_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMbox1EccUncIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_mcu_sram_dmi_axi_collision_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMcuSramDmiAxiCollisionIntrCountR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_wdt_timer1_timeout_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorWdtTimer1TimeoutIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_wdt_timer2_timeout_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorWdtTimer2TimeoutIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x114 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal0_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal0IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x118 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal1_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal1IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x11c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal2_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal2IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x120 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal3_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal3IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x124 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal4_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal4IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x128 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal5_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal5IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x12c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal6_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal6IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x130 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal7_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal7IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x134 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal8_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal8IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x138 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal9_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal9IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x13c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal10_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal10IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x140 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal11_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal11IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x144 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal12_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal12IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x148 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal13_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal13IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal14_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal14IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x150 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal15_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal15IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x154 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal16_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal16IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x158 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal17_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal17IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x15c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal18_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal18IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x160 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal19_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal19IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x164 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal20_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal20IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x168 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal21_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal21IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x16c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal22_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal22IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x170 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal23_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal23IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x174 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal24_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal24IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x178 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal25_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal25IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x17c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal26_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal26IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal27_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal27IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x184 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal28_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal28IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x188 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal29_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal29IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal30_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal30IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x190 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_agg_error_fatal31_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal31IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x194 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mcu_sram_ecc_cor_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMcuSramEccCorIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_cptra_mcu_reset_req_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifCptraMcuResetReqIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_gen_in_toggle_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifGenInToggleIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x208 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal0_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal0IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal1_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal1IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x210 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal2_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal2IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x214 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal3_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal3IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x218 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal4_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal4IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x21c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal5_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal5IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x220 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal6_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal6IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x224 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal7_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal7IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x228 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal8_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal8IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x22c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal9_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal9IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x230 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal10_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal10IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x234 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal11_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal11IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x238 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal12_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal12IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x23c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal13_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal13IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x240 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal14_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal14IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x244 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal15_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal15IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x248 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal16_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal16IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal17_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal17IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x250 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal18_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal18IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x254 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal19_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal19IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x258 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal20_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal20IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x25c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal21_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal21IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x260 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal22_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal22IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x264 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal23_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal23IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x268 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal24_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal24IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x26c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal25_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal25IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x270 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal26_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal26IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x274 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal27_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal27IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x278 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal28_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal28IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x27c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal29_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal29IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x280 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal30_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal30IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x284 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal31_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal31IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x288 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox0_target_done_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0TargetDoneIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox1_target_done_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1TargetDoneIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x290 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox0_cmd_avail_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0CmdAvailIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x294 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox1_cmd_avail_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1CmdAvailIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x298 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_cptra_mbox_cmd_avail_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifCptraMboxCmdAvailIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x29c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox0_ecc_cor_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0EccCorIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2a0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox1_ecc_cor_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1EccCorIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2a4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_debug_locked_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifDebugLockedIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2a8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_scan_mode_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifScanModeIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2ac / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox0_soc_req_lock_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0SocReqLockIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2b0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox1_soc_req_lock_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1SocReqLockIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2b4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorInternalIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x300 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_mbox0_ecc_unc_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMbox0EccUncIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x304 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_mbox1_ecc_unc_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMbox1EccUncIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x308 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_wdt_timer1_timeout_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorWdtTimer1TimeoutIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_wdt_timer2_timeout_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorWdtTimer2TimeoutIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x310 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_mcu_sram_dmi_axi_collision_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorMcuSramDmiAxiCollisionIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x314 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal0_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal0IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x318 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal1_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal1IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x31c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal2_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal2IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x320 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal3_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal3IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x324 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal4_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal4IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x328 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal5_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal5IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x32c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal6_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal6IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x330 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal7_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal7IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x334 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal8_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal8IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x338 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal9_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal9IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x33c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal10_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal10IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x340 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal11_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal11IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x344 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal12_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal12IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x348 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal13_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal13IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal14_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal14IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x350 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal15_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal15IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x354 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal16_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal16IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x358 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal17_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal17IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x35c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal18_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal18IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x360 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal19_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal19IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x364 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal20_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal20IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x368 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal21_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal21IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x36c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal22_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal22IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x370 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal23_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal23IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x374 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal24_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal24IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x378 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal25_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal25IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x37c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal26_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal26IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x380 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal27_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal27IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x384 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal28_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal28IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x388 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal29_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal29IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal30_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal30IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x390 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_agg_error_fatal31_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfErrorAggErrorFatal31IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x394 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mcu_sram_ecc_cor_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMcuSramEccCorIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x398 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_cptra_mcu_reset_req_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifCptraMcuResetReqIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x39c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_gen_in_toggle_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifGenInToggleIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3a0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal0_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal0IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3a4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal1_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal1IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3a8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal2_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal2IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3ac / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal3_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal3IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3b0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal4_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal4IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3b4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal5_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal5IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3b8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal6_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal6IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3bc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal7_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal7IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal8_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal8IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal9_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal9IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal10_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal10IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3cc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal11_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal11IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3d0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal12_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal12IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3d4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal13_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal13IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3d8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal14_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal14IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3dc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal15_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal15IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3e0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal16_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal16IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3e4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal17_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal17IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3e8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal18_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal18IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3ec / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal19_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal19IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3f0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal20_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal20IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3f4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal21_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal21IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3f8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal22_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal22IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3fc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal23_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal23IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal24_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal24IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x404 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal25_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal25IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x408 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal26_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal26IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal27_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal27IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x410 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal28_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal28IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x414 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal29_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal29IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x418 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal30_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal30IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x41c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_agg_error_non_fatal31_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifAggErrorNonFatal31IntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x420 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox0_target_done_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0TargetDoneIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x424 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox1_target_done_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1TargetDoneIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x428 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox0_cmd_avail_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0CmdAvailIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x42c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox1_cmd_avail_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1CmdAvailIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x430 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_cptra_mbox_cmd_avail_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifCptraMboxCmdAvailIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x434 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox0_ecc_cor_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0EccCorIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x438 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox1_ecc_cor_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1EccCorIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x43c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_debug_locked_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifDebugLockedIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x440 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_scan_mode_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifScanModeIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x444 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox0_soc_req_lock_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox0SocReqLockIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x448 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox1_soc_req_lock_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::mci::meta::IntrBlockRfNotifMbox1SocReqLockIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct IntrBlockRf {
    _priv: (),
}
impl IntrBlockRf {
    pub const PTR: *mut u32 = 0x1000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AggErrorFatalReadVal(u32);
    impl AggErrorFatalReadVal {
        #[inline(always)]
        pub fn agg_error_fatal31(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal30(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal29(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal28(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal27(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal26(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal25(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal24(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal23(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal22(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal21(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal20(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal19(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal18(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal17(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal16(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal15(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal14(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal13(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal12(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal11(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal10(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal9(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal8(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal7(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal6(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal5(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal4(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal3(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal2(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal1(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_fatal0(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> AggErrorFatalWriteVal {
            AggErrorFatalWriteVal(self.0)
        }
    }
    impl From<u32> for AggErrorFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AggErrorFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: AggErrorFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AggErrorFatalWriteVal(u32);
    impl AggErrorFatalWriteVal {
        #[inline(always)]
        pub fn agg_error_fatal31(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn agg_error_fatal30(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn agg_error_fatal29(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn agg_error_fatal28(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn agg_error_fatal27(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        #[inline(always)]
        pub fn agg_error_fatal26(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        #[inline(always)]
        pub fn agg_error_fatal25(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        #[inline(always)]
        pub fn agg_error_fatal24(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        #[inline(always)]
        pub fn agg_error_fatal23(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        #[inline(always)]
        pub fn agg_error_fatal22(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        #[inline(always)]
        pub fn agg_error_fatal21(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn agg_error_fatal20(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn agg_error_fatal19(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn agg_error_fatal18(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn agg_error_fatal17(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn agg_error_fatal16(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        #[inline(always)]
        pub fn agg_error_fatal15(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn agg_error_fatal14(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn agg_error_fatal13(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn agg_error_fatal12(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn agg_error_fatal11(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        #[inline(always)]
        pub fn agg_error_fatal10(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        #[inline(always)]
        pub fn agg_error_fatal9(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        #[inline(always)]
        pub fn agg_error_fatal8(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        #[inline(always)]
        pub fn agg_error_fatal7(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        #[inline(always)]
        pub fn agg_error_fatal6(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        #[inline(always)]
        pub fn agg_error_fatal5(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        #[inline(always)]
        pub fn agg_error_fatal4(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        #[inline(always)]
        pub fn agg_error_fatal3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        #[inline(always)]
        pub fn agg_error_fatal2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        #[inline(always)]
        pub fn agg_error_fatal1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        #[inline(always)]
        pub fn agg_error_fatal0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for AggErrorFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AggErrorFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AggErrorFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AggErrorNonFatalReadVal(u32);
    impl AggErrorNonFatalReadVal {
        #[inline(always)]
        pub fn agg_error_non_fatal31(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal30(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal29(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal28(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal27(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal26(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal25(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal24(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal23(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal22(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal21(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal20(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal19(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal18(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal17(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal16(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal15(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal14(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal13(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal12(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal11(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal10(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal9(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal8(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal7(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal6(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal5(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal4(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal3(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal2(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal1(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        #[inline(always)]
        pub fn agg_error_non_fatal0(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> AggErrorNonFatalWriteVal {
            AggErrorNonFatalWriteVal(self.0)
        }
    }
    impl From<u32> for AggErrorNonFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AggErrorNonFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: AggErrorNonFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AggErrorNonFatalWriteVal(u32);
    impl AggErrorNonFatalWriteVal {
        #[inline(always)]
        pub fn agg_error_non_fatal31(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal30(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal29(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal28(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal27(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal26(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal25(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal24(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal23(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal22(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal21(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal20(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal19(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal18(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal17(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal16(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal15(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal14(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal13(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal12(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal11(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal10(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal9(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal8(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal7(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal6(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal5(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal4(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        #[inline(always)]
        pub fn agg_error_non_fatal0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for AggErrorNonFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AggErrorNonFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AggErrorNonFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CapLockReadVal(u32);
    impl CapLockReadVal {
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CapLockWriteVal {
            CapLockWriteVal(self.0)
        }
    }
    impl From<u32> for CapLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CapLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: CapLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CapLockWriteVal(u32);
    impl CapLockWriteVal {
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CapLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CapLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CapLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwSramExecRegionSizeReadVal(u32);
    impl FwSramExecRegionSizeReadVal {
        /// Size (in multiples of 4KiB)
        #[inline(always)]
        pub fn size(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FwSramExecRegionSizeWriteVal {
            FwSramExecRegionSizeWriteVal(self.0)
        }
    }
    impl From<u32> for FwSramExecRegionSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwSramExecRegionSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwSramExecRegionSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwSramExecRegionSizeWriteVal(u32);
    impl FwSramExecRegionSizeWriteVal {
        /// Size (in multiples of 4KiB)
        #[inline(always)]
        pub fn size(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
    }
    impl From<u32> for FwSramExecRegionSizeWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwSramExecRegionSizeWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FwSramExecRegionSizeWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwConfig0ReadVal(u32);
    impl HwConfig0ReadVal {
        /// MCU MBOX1 SRAM SIZE KB. If 0 there is no mailbox
        #[inline(always)]
        pub fn mcu_mbox1_sram_size(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// MCU MBOX0 SRAM SIZE KB. If 0 there is no mailbox
        #[inline(always)]
        pub fn mcu_mbox0_sram_size(&self) -> u32 {
            (self.0 >> 12) & 0xfff
        }
    }
    impl From<u32> for HwConfig0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwConfig0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwConfig0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwConfig1ReadVal(u32);
    impl HwConfig1ReadVal {
        /// Size of MCU reset counter
        #[inline(always)]
        pub fn min_mcu_rst_counter_width(&self) -> u32 {
            (self.0 >> 0) & 0x1f
        }
        /// MCU SRAM Size KB
        #[inline(always)]
        pub fn mcu_sram_size(&self) -> u32 {
            (self.0 >> 5) & 0xfff
        }
    }
    impl From<u32> for HwConfig1ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwConfig1ReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwConfig1ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwErrorFatalReadVal(u32);
    impl HwErrorFatalReadVal {
        #[inline(always)]
        pub fn mcu_sram_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn nmi_pin(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn mcu_sram_dmi_axi_collision(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HwErrorFatalWriteVal {
            HwErrorFatalWriteVal(self.0)
        }
    }
    impl From<u32> for HwErrorFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwErrorFatalWriteVal(u32);
    impl HwErrorFatalWriteVal {
        #[inline(always)]
        pub fn mcu_sram_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn nmi_pin(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn mcu_sram_dmi_axi_collision(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for HwErrorFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwErrorNonFatalReadVal(u32);
    impl HwErrorNonFatalReadVal {
        #[inline(always)]
        pub fn mbox0_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn mbox1_ecc_unc(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HwErrorNonFatalWriteVal {
            HwErrorNonFatalWriteVal(self.0)
        }
    }
    impl From<u32> for HwErrorNonFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorNonFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorNonFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwErrorNonFatalWriteVal(u32);
    impl HwErrorNonFatalWriteVal {
        #[inline(always)]
        pub fn mbox0_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn mbox1_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for HwErrorNonFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorNonFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorNonFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwFlowStatusReadVal(u32);
    impl HwFlowStatusReadVal {
        /// MCI Boot FSM State
        #[inline(always)]
        pub fn boot_fsm(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
    }
    impl From<u32> for HwFlowStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwFlowStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwFlowStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwRevIdReadVal(u32);
    impl HwRevIdReadVal {
        /// Official release version. Bit field encoding is:
        /// [br][lb]15:12[rb] Major version
        /// [br][lb]11: 8[rb] Minor version
        /// [br][lb] 7: 0[rb] Patch version
        #[inline(always)]
        pub fn mc_generation(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for HwRevIdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwRevIdReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwRevIdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxxAxiUserLockReadVal(u32);
    impl MboxxAxiUserLockReadVal {
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MboxxAxiUserLockWriteVal {
            MboxxAxiUserLockWriteVal(self.0)
        }
    }
    impl From<u32> for MboxxAxiUserLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxxAxiUserLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxxAxiUserLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxxAxiUserLockWriteVal(u32);
    impl MboxxAxiUserLockWriteVal {
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for MboxxAxiUserLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxxAxiUserLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MboxxAxiUserLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetReasonReadVal(u32);
    impl ResetReasonReadVal {
        /// FW update reset has been executed for the second+ time since MCI reset
        #[inline(always)]
        pub fn fw_hitless_upd_reset(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// FW update reset has been executed first time since MCI reset
        #[inline(always)]
        pub fn fw_boot_upd_reset(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetReasonWriteVal {
            ResetReasonWriteVal(self.0)
        }
    }
    impl From<u32> for ResetReasonReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetReasonReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetReasonReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetReasonWriteVal(u32);
    impl ResetReasonWriteVal {
        /// FW update reset has been executed for the second+ time since MCI reset
        #[inline(always)]
        pub fn fw_hitless_upd_reset(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// FW update reset has been executed first time since MCI reset
        #[inline(always)]
        pub fn fw_boot_upd_reset(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for ResetReasonWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetReasonWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetReasonWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetRequestReadVal(u32);
    impl ResetRequestReadVal {
        /// Request. Writable by MCU. Causes MCU reset to be asserted by MCI. Cleared when reset is asserted.
        #[inline(always)]
        pub fn mcu_req(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetRequestWriteVal {
            ResetRequestWriteVal(self.0)
        }
    }
    impl From<u32> for ResetRequestReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetRequestReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetRequestReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetRequestWriteVal(u32);
    impl ResetRequestWriteVal {
        /// Request. Writable by MCU. Causes MCU reset to be asserted by MCI. Cleared when reset is asserted.
        #[inline(always)]
        pub fn mcu_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ResetRequestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetRequestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetRequestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetStatusReadVal(u32);
    impl ResetStatusReadVal {
        /// caliptra reset status. 1: Reset asserted. 0: Reset deasserted
        #[inline(always)]
        pub fn cptra_reset_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// MCU reset status. 1: Reset asserted. 0: Reset deasserted
        #[inline(always)]
        pub fn mcu_reset_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for ResetStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SecurityStateReadVal(u32);
    impl SecurityStateReadVal {
        /// Device Lifecycle
        #[inline(always)]
        pub fn device_lifecycle(&self) -> super::enums::DeviceLifecycleE {
            super::enums::DeviceLifecycleE::try_from((self.0 >> 0) & 3).unwrap()
        }
        /// Debug Locked
        #[inline(always)]
        pub fn debug_locked(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// scan mode signal observed at caliptra interface - only for debug mode as its used to flush assets -
        /// when truly in scan mode, everything will be BROKEN for functional reads!
        #[inline(always)]
        pub fn scan_mode(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
    }
    impl From<u32> for SecurityStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SecurityStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: SecurityStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SsConfigDoneReadVal(u32);
    impl SsConfigDoneReadVal {
        #[inline(always)]
        pub fn done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SsConfigDoneWriteVal {
            SsConfigDoneWriteVal(self.0)
        }
    }
    impl From<u32> for SsConfigDoneReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SsConfigDoneReadVal> for u32 {
        #[inline(always)]
        fn from(val: SsConfigDoneReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SsConfigDoneWriteVal(u32);
    impl SsConfigDoneWriteVal {
        #[inline(always)]
        pub fn done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SsConfigDoneWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SsConfigDoneWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SsConfigDoneWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SsDebugIntentReadVal(u32);
    impl SsDebugIntentReadVal {
        #[inline(always)]
        pub fn debug_intent(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for SsDebugIntentReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SsDebugIntentReadVal> for u32 {
        #[inline(always)]
        fn from(val: SsDebugIntentReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtStatusReadVal(u32);
    impl WdtStatusReadVal {
        /// Timer1 timed out, timer2 enabled
        #[inline(always)]
        pub fn t1_timeout(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Timer2 timed out
        #[inline(always)]
        pub fn t2_timeout(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for WdtStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer1CtrlReadVal(u32);
    impl WdtTimer1CtrlReadVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer1CtrlWriteVal {
            WdtTimer1CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer1CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer1CtrlWriteVal(u32);
    impl WdtTimer1CtrlWriteVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for WdtTimer1CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer1EnReadVal(u32);
    impl WdtTimer1EnReadVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer1EnWriteVal {
            WdtTimer1EnWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer1EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer1EnWriteVal(u32);
    impl WdtTimer1EnWriteVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for WdtTimer1EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer2CtrlReadVal(u32);
    impl WdtTimer2CtrlReadVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer2CtrlWriteVal {
            WdtTimer2CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer2CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer2CtrlWriteVal(u32);
    impl WdtTimer2CtrlWriteVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for WdtTimer2CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer2EnReadVal(u32);
    impl WdtTimer2EnReadVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer2EnWriteVal {
            WdtTimer2EnWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer2EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct WdtTimer2EnWriteVal(u32);
    impl WdtTimer2EnWriteVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for WdtTimer2EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GoReadVal(u32);
    impl GoReadVal {
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> GoWriteVal {
            GoWriteVal(self.0)
        }
    }
    impl From<u32> for GoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GoReadVal> for u32 {
        #[inline(always)]
        fn from(val: GoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GoWriteVal(u32);
    impl GoWriteVal {
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for GoWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GoWriteVal> for u32 {
        #[inline(always)]
        fn from(val: GoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrEnTReadVal(u32);
    impl Error0IntrEnTReadVal {
        /// Enable bit for Collision between AXI and DMI port in MCU SRAM.
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for WDT Timer1 timeout
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error0IntrEnTWriteVal {
            Error0IntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for Error0IntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrEnTWriteVal(u32);
    impl Error0IntrEnTWriteVal {
        /// Enable bit for Collision between AXI and DMI port in MCU SRAM.
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for WDT Timer1 timeout
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for Error0IntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrTReadVal(u32);
    impl Error0IntrTReadVal {
        /// Collision between AXI and DMI port in MCU SRAM.
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// WDT Timer1 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// WDT Timer2 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error0IntrTWriteVal {
            Error0IntrTWriteVal(self.0)
        }
    }
    impl From<u32> for Error0IntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrTWriteVal(u32);
    impl Error0IntrTWriteVal {
        /// Collision between AXI and DMI port in MCU SRAM.
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// WDT Timer1 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// WDT Timer2 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for Error0IntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrTrigTReadVal(u32);
    impl Error0IntrTrigTReadVal {
        /// Collision between AXI and DMI port in MCU SRAM trigger bit
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// WDT Timer1 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// WDT Timer2 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error0IntrTrigTWriteVal {
            Error0IntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for Error0IntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error0IntrTrigTWriteVal(u32);
    impl Error0IntrTrigTWriteVal {
        /// Collision between AXI and DMI port in MCU SRAM trigger bit
        #[inline(always)]
        pub fn error_mcu_sram_dmi_axi_collision_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox0_ecc_unc_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox1_ecc_unc_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// WDT Timer1 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// WDT Timer2 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for Error0IntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error0IntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error0IntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrEnTReadVal(u32);
    impl Error1IntrEnTReadVal {
        /// Enable bit MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_en(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_en(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_en(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_en(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_en(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_en(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_en(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_en(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_en(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_en(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_en(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_en(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_en(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_en(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_en(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_en(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_en(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error1IntrEnTWriteVal {
            Error1IntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for Error1IntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrEnTWriteVal(u32);
    impl Error1IntrEnTWriteVal {
        /// Enable bit MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable bit MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Enable bit MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Enable bit MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Enable bit MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable bit MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Enable bit MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable bit MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable bit MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable bit MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable bit MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Enable bit MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// Enable bit MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// Enable bit MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// Enable bit MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// Enable bit MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Enable bit MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// Enable bit MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// Enable bit MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// Enable bit MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// Enable bit MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Enable bit MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// Enable bit MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// Enable bit MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Enable bit MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Enable bit MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Enable bit MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Error1IntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrTReadVal(u32);
    impl Error1IntrTReadVal {
        /// MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_sts(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_sts(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_sts(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_sts(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_sts(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_sts(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_sts(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_sts(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_sts(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_sts(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_sts(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_sts(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_sts(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_sts(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_sts(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_sts(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_sts(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_sts(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_sts(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_sts(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_sts(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_sts(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_sts(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_sts(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_sts(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_sts(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error1IntrTWriteVal {
            Error1IntrTWriteVal(self.0)
        }
    }
    impl From<u32> for Error1IntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrTWriteVal(u32);
    impl Error1IntrTWriteVal {
        /// MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Error1IntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrTrigTReadVal(u32);
    impl Error1IntrTrigTReadVal {
        /// Trigger bit MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_trig(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_trig(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_trig(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_trig(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_trig(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_trig(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_trig(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_trig(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_trig(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_trig(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_trig(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_trig(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_trig(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_trig(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_trig(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_trig(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_trig(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_trig(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_trig(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_trig(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_trig(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_trig(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_trig(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_trig(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_trig(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_trig(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Error1IntrTrigTWriteVal {
            Error1IntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for Error1IntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Error1IntrTrigTWriteVal(u32);
    impl Error1IntrTrigTWriteVal {
        /// Trigger bit MCI Aggregate Error fatal bit 31
        #[inline(always)]
        pub fn error_agg_error_fatal31_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 30
        #[inline(always)]
        pub fn error_agg_error_fatal30_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 29
        #[inline(always)]
        pub fn error_agg_error_fatal29_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 28
        #[inline(always)]
        pub fn error_agg_error_fatal28_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 27
        #[inline(always)]
        pub fn error_agg_error_fatal27_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 26
        #[inline(always)]
        pub fn error_agg_error_fatal26_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 25
        #[inline(always)]
        pub fn error_agg_error_fatal25_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 24
        #[inline(always)]
        pub fn error_agg_error_fatal24_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 23
        #[inline(always)]
        pub fn error_agg_error_fatal23_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 22
        #[inline(always)]
        pub fn error_agg_error_fatal22_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 21
        #[inline(always)]
        pub fn error_agg_error_fatal21_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 20
        #[inline(always)]
        pub fn error_agg_error_fatal20_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 19
        #[inline(always)]
        pub fn error_agg_error_fatal19_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 18
        #[inline(always)]
        pub fn error_agg_error_fatal18_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 17
        #[inline(always)]
        pub fn error_agg_error_fatal17_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 16
        #[inline(always)]
        pub fn error_agg_error_fatal16_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 15
        #[inline(always)]
        pub fn error_agg_error_fatal15_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 14
        #[inline(always)]
        pub fn error_agg_error_fatal14_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 13
        #[inline(always)]
        pub fn error_agg_error_fatal13_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 12
        #[inline(always)]
        pub fn error_agg_error_fatal12_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 11
        #[inline(always)]
        pub fn error_agg_error_fatal11_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 10
        #[inline(always)]
        pub fn error_agg_error_fatal10_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 9
        #[inline(always)]
        pub fn error_agg_error_fatal9_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 8
        #[inline(always)]
        pub fn error_agg_error_fatal8_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 7
        #[inline(always)]
        pub fn error_agg_error_fatal7_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 6
        #[inline(always)]
        pub fn error_agg_error_fatal6_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 5
        #[inline(always)]
        pub fn error_agg_error_fatal5_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 4
        #[inline(always)]
        pub fn error_agg_error_fatal4_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 3
        #[inline(always)]
        pub fn error_agg_error_fatal3_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 2
        #[inline(always)]
        pub fn error_agg_error_fatal2_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 1
        #[inline(always)]
        pub fn error_agg_error_fatal1_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Trigger bit MCI Aggregate Error fatal bit 0
        #[inline(always)]
        pub fn error_agg_error_fatal0_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Error1IntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Error1IntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Error1IntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GlobalIntrTReadVal(u32);
    impl GlobalIntrTReadVal {
        /// Interrupt Event Aggregation status bit
        #[inline(always)]
        pub fn agg_sts0(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Interrupt Event Aggregation status bit
        #[inline(always)]
        pub fn agg_sts1(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for GlobalIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GlobalIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: GlobalIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalAggErrorFatalMaskReadVal(u32);
    impl InternalAggErrorFatalMaskReadVal {
        #[inline(always)]
        pub fn mask_agg_error_fatal31(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal30(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal29(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal28(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal27(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal26(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal25(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal24(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal23(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal22(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal21(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal20(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal19(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal18(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal17(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal16(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal15(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal14(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal13(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal12(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal11(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal10(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal9(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal8(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal7(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal6(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal5(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal4(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal3(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal2(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal1(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal0(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalAggErrorFatalMaskWriteVal {
            InternalAggErrorFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalAggErrorFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalAggErrorFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalAggErrorFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalAggErrorFatalMaskWriteVal(u32);
    impl InternalAggErrorFatalMaskWriteVal {
        #[inline(always)]
        pub fn mask_agg_error_fatal31(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal30(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal29(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal28(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal27(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal26(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal25(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal24(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal23(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal22(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal21(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal20(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal19(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal18(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal17(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal16(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal15(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal14(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal13(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal12(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal11(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal10(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal9(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal8(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal7(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal6(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal5(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal4(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        #[inline(always)]
        pub fn mask_agg_error_fatal0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for InternalAggErrorFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalAggErrorFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalAggErrorFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalAggErrorNonFatalMaskReadVal(u32);
    impl InternalAggErrorNonFatalMaskReadVal {
        #[inline(always)]
        pub fn mask_agg_error_non_fatal31(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal30(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal29(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal28(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal27(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal26(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal25(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal24(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal23(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal22(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal21(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal20(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal19(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal18(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal17(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal16(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal15(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal14(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal13(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal12(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal11(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal10(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal9(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal8(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal7(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal6(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal5(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal4(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal3(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal2(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal1(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal0(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalAggErrorNonFatalMaskWriteVal {
            InternalAggErrorNonFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalAggErrorNonFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalAggErrorNonFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalAggErrorNonFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalAggErrorNonFatalMaskWriteVal(u32);
    impl InternalAggErrorNonFatalMaskWriteVal {
        #[inline(always)]
        pub fn mask_agg_error_non_fatal31(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal30(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal29(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal28(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal27(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal26(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal25(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal24(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal23(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal22(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal21(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal20(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal19(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal18(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal17(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal16(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal15(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal14(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal13(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal12(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal11(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal10(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal9(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal8(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal7(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal6(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal5(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal4(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        #[inline(always)]
        pub fn mask_agg_error_non_fatal0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for InternalAggErrorNonFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalAggErrorNonFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalAggErrorNonFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorFatalMaskReadVal(u32);
    impl InternalHwErrorFatalMaskReadVal {
        #[inline(always)]
        pub fn mask_mcu_sram_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_nmi_pin(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_mcu_sram_dmi_axi_collision(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalHwErrorFatalMaskWriteVal {
            InternalHwErrorFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalHwErrorFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorFatalMaskWriteVal(u32);
    impl InternalHwErrorFatalMaskWriteVal {
        #[inline(always)]
        pub fn mask_mcu_sram_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn mask_nmi_pin(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn mask_mcu_sram_dmi_axi_collision(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for InternalHwErrorFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorNonFatalMaskReadVal(u32);
    impl InternalHwErrorNonFatalMaskReadVal {
        #[inline(always)]
        pub fn mask_mbox0_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn mask_mbox1_ecc_unc(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalHwErrorNonFatalMaskWriteVal {
            InternalHwErrorNonFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalHwErrorNonFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorNonFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorNonFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorNonFatalMaskWriteVal(u32);
    impl InternalHwErrorNonFatalMaskWriteVal {
        #[inline(always)]
        pub fn mask_mbox0_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn mask_mbox1_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InternalHwErrorNonFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorNonFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorNonFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrEnTReadVal(u32);
    impl Notif0IntrEnTReadVal {
        /// Enable bit for MCUS SRAM ECC Single-bit Error (corretable)
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for Caliptra requests MCU to reset itself
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for Generic Input Wires Toggle
        #[inline(always)]
        pub fn notif_gen_in_toggle_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for MBOX0 Target done and status available
        #[inline(always)]
        pub fn notif_mbox0_target_done_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for MBOX1 Target done and status available
        #[inline(always)]
        pub fn notif_mbox1_target_done_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit for MBOX0 Command Available
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable bit for MBOX1 Command Available
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Enable bit for Caliptra MBOX Command Available
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_en(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable bit for Security State, Debug Locked transition
        #[inline(always)]
        pub fn notif_debug_locked_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Enable bit for Scan mode asserted
        #[inline(always)]
        pub fn notif_scan_mode_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable bit for SoC requested the mailbox while mcu has lock
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable bit for SoC requested the mailbox while mcu has lock
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif0IntrEnTWriteVal {
            Notif0IntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif0IntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrEnTWriteVal(u32);
    impl Notif0IntrEnTWriteVal {
        /// Enable bit for MCUS SRAM ECC Single-bit Error (corretable)
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for Caliptra requests MCU to reset itself
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for Generic Input Wires Toggle
        #[inline(always)]
        pub fn notif_gen_in_toggle_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for MBOX0 Target done and status available
        #[inline(always)]
        pub fn notif_mbox0_target_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for MBOX1 Target done and status available
        #[inline(always)]
        pub fn notif_mbox1_target_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit for MBOX0 Command Available
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable bit for MBOX1 Command Available
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Enable bit for Caliptra MBOX Command Available
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable bit for Security State, Debug Locked transition
        #[inline(always)]
        pub fn notif_debug_locked_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Enable bit for Scan mode asserted
        #[inline(always)]
        pub fn notif_scan_mode_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable bit for SoC requested the mailbox while mcu has lock
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable bit for SoC requested the mailbox while mcu has lock
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
    }
    impl From<u32> for Notif0IntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrTReadVal(u32);
    impl Notif0IntrTReadVal {
        /// MCU SRAM ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Caliptra requests MCU to reset itself status bit
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Generic Input Wires Toggle status bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// MBOX0 Target done and status available bit
        #[inline(always)]
        pub fn notif_mbox0_target_done_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// MBOX1 Target done and status available bit
        #[inline(always)]
        pub fn notif_mbox1_target_done_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// MBOX0 Command Available status bit
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// MBOX1 Command Available status bit
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_sts(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Caliptra MBOX Command Available status bit
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_sts(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_sts(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_sts(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Security State, Debug Locked transition status bit
        #[inline(always)]
        pub fn notif_debug_locked_sts(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Scan mode asserted status bit
        #[inline(always)]
        pub fn notif_scan_mode_sts(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// SoC requested the mailbox while mcu has lock status bit
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_sts(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// SoC requested the mailbox while mcu has lock status bit
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_sts(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif0IntrTWriteVal {
            Notif0IntrTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif0IntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrTWriteVal(u32);
    impl Notif0IntrTWriteVal {
        /// MCU SRAM ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Caliptra requests MCU to reset itself status bit
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Generic Input Wires Toggle status bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// MBOX0 Target done and status available bit
        #[inline(always)]
        pub fn notif_mbox0_target_done_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// MBOX1 Target done and status available bit
        #[inline(always)]
        pub fn notif_mbox1_target_done_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// MBOX0 Command Available status bit
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// MBOX1 Command Available status bit
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Caliptra MBOX Command Available status bit
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Security State, Debug Locked transition status bit
        #[inline(always)]
        pub fn notif_debug_locked_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Scan mode asserted status bit
        #[inline(always)]
        pub fn notif_scan_mode_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// SoC requested the mailbox while mcu has lock status bit
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// SoC requested the mailbox while mcu has lock status bit
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
    }
    impl From<u32> for Notif0IntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrTrigTReadVal(u32);
    impl Notif0IntrTrigTReadVal {
        /// MCU SRAM ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Caliptra requests MCU to reset itself trigger bit
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Generic Input Wires Toggle trigger bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// MBOX0 Target done and status available trigger bit
        #[inline(always)]
        pub fn notif_mbox0_target_done_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// MBOX1 Target done and status available trigger bit
        #[inline(always)]
        pub fn notif_mbox1_target_done_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// MBOX0 Command Available trigger bit
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// MBOX1 Command Available trigger bit
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_trig(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Caliptra MBOX Command Available trigger bit
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_trig(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_trig(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_trig(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Security State, Debug Locked transition trigger bit
        #[inline(always)]
        pub fn notif_debug_locked_trig(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Scan mode asserted trigger bit
        #[inline(always)]
        pub fn notif_scan_mode_trig(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// SoC requested the mailbox while mcu has lock trigger bit
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_trig(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// SoC requested the mailbox while mcu has lock trigger bit
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_trig(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif0IntrTrigTWriteVal {
            Notif0IntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif0IntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif0IntrTrigTWriteVal(u32);
    impl Notif0IntrTrigTWriteVal {
        /// MCU SRAM ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mcu_sram_ecc_cor_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Caliptra requests MCU to reset itself trigger bit
        #[inline(always)]
        pub fn notif_cptra_mcu_reset_req_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Generic Input Wires Toggle trigger bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// MBOX0 Target done and status available trigger bit
        #[inline(always)]
        pub fn notif_mbox0_target_done_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// MBOX1 Target done and status available trigger bit
        #[inline(always)]
        pub fn notif_mbox1_target_done_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// MBOX0 Command Available trigger bit
        #[inline(always)]
        pub fn notif_mbox0_cmd_avail_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// MBOX1 Command Available trigger bit
        #[inline(always)]
        pub fn notif_mbox1_cmd_avail_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Caliptra MBOX Command Available trigger bit
        #[inline(always)]
        pub fn notif_cptra_mbox_cmd_avail_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox0_ecc_cor_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox1_ecc_cor_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Security State, Debug Locked transition trigger bit
        #[inline(always)]
        pub fn notif_debug_locked_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Scan mode asserted trigger bit
        #[inline(always)]
        pub fn notif_scan_mode_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// SoC requested the mailbox while mcu has lock trigger bit
        #[inline(always)]
        pub fn notif_mbox0_soc_req_lock_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// SoC requested the mailbox while mcu has lock trigger bit
        #[inline(always)]
        pub fn notif_mbox1_soc_req_lock_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
    }
    impl From<u32> for Notif0IntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif0IntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif0IntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrEnTReadVal(u32);
    impl Notif1IntrEnTReadVal {
        /// Enable bit MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_en(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_en(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_en(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_en(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_en(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_en(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_en(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_en(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_en(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_en(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_en(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_en(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_en(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_en(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_en(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_en(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Enable bit MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_en(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif1IntrEnTWriteVal {
            Notif1IntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif1IntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrEnTWriteVal(u32);
    impl Notif1IntrEnTWriteVal {
        /// Enable bit MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Enable bit MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Notif1IntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrTReadVal(u32);
    impl Notif1IntrTReadVal {
        /// MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_sts(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_sts(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_sts(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_sts(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_sts(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_sts(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_sts(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_sts(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_sts(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_sts(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_sts(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_sts(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_sts(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_sts(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_sts(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_sts(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_sts(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_sts(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_sts(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_sts(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_sts(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_sts(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_sts(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_sts(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_sts(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_sts(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif1IntrTWriteVal {
            Notif1IntrTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif1IntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrTWriteVal(u32);
    impl Notif1IntrTWriteVal {
        /// MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Notif1IntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrTrigTReadVal(u32);
    impl Notif1IntrTrigTReadVal {
        /// Trigger bit MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_trig(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_trig(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_trig(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_trig(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_trig(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_trig(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_trig(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_trig(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_trig(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_trig(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_trig(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_trig(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_trig(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_trig(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_trig(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_trig(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_trig(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_trig(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_trig(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_trig(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_trig(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_trig(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_trig(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_trig(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_trig(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_trig(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Notif1IntrTrigTWriteVal {
            Notif1IntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for Notif1IntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Notif1IntrTrigTWriteVal(u32);
    impl Notif1IntrTrigTWriteVal {
        /// Trigger bit MCI Aggregate Error non fatal bit 31
        #[inline(always)]
        pub fn notif_agg_error_non_fatal31_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 30
        #[inline(always)]
        pub fn notif_agg_error_non_fatal30_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 29
        #[inline(always)]
        pub fn notif_agg_error_non_fatal29_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 28
        #[inline(always)]
        pub fn notif_agg_error_non_fatal28_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 27
        #[inline(always)]
        pub fn notif_agg_error_non_fatal27_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 26
        #[inline(always)]
        pub fn notif_agg_error_non_fatal26_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 25
        #[inline(always)]
        pub fn notif_agg_error_non_fatal25_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 24
        #[inline(always)]
        pub fn notif_agg_error_non_fatal24_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 23
        #[inline(always)]
        pub fn notif_agg_error_non_fatal23_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 22
        #[inline(always)]
        pub fn notif_agg_error_non_fatal22_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 21
        #[inline(always)]
        pub fn notif_agg_error_non_fatal21_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 20
        #[inline(always)]
        pub fn notif_agg_error_non_fatal20_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 19
        #[inline(always)]
        pub fn notif_agg_error_non_fatal19_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 18
        #[inline(always)]
        pub fn notif_agg_error_non_fatal18_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 17
        #[inline(always)]
        pub fn notif_agg_error_non_fatal17_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 16
        #[inline(always)]
        pub fn notif_agg_error_non_fatal16_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 15
        #[inline(always)]
        pub fn notif_agg_error_non_fatal15_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 14
        #[inline(always)]
        pub fn notif_agg_error_non_fatal14_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 13
        #[inline(always)]
        pub fn notif_agg_error_non_fatal13_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 12
        #[inline(always)]
        pub fn notif_agg_error_non_fatal12_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 11
        #[inline(always)]
        pub fn notif_agg_error_non_fatal11_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 10
        #[inline(always)]
        pub fn notif_agg_error_non_fatal10_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 21)) | (u32::from(val) << 21))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 9
        #[inline(always)]
        pub fn notif_agg_error_non_fatal9_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 8
        #[inline(always)]
        pub fn notif_agg_error_non_fatal8_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 7
        #[inline(always)]
        pub fn notif_agg_error_non_fatal7_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 6
        #[inline(always)]
        pub fn notif_agg_error_non_fatal6_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 5
        #[inline(always)]
        pub fn notif_agg_error_non_fatal5_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 4
        #[inline(always)]
        pub fn notif_agg_error_non_fatal4_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 3
        #[inline(always)]
        pub fn notif_agg_error_non_fatal3_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 2
        #[inline(always)]
        pub fn notif_agg_error_non_fatal2_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 1
        #[inline(always)]
        pub fn notif_agg_error_non_fatal1_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Trigger bit MCI Aggregate Error non fatal bit 0
        #[inline(always)]
        pub fn notif_agg_error_non_fatal0_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for Notif1IntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Notif1IntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: Notif1IntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum DeviceLifecycleE {
        DeviceUnprovisioned = 0,
        DeviceManufacturing = 1,
        Reserved2 = 2,
        DeviceProduction = 3,
    }
    impl DeviceLifecycleE {
        #[inline(always)]
        pub fn device_unprovisioned(&self) -> bool {
            *self == Self::DeviceUnprovisioned
        }
        #[inline(always)]
        pub fn device_manufacturing(&self) -> bool {
            *self == Self::DeviceManufacturing
        }
        #[inline(always)]
        pub fn device_production(&self) -> bool {
            *self == Self::DeviceProduction
        }
    }
    impl TryFrom<u32> for DeviceLifecycleE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<DeviceLifecycleE, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute::<u32, DeviceLifecycleE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<DeviceLifecycleE> for u32 {
        fn from(val: DeviceLifecycleE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct DeviceLifecycleESelector();
        impl DeviceLifecycleESelector {
            #[inline(always)]
            pub fn device_unprovisioned(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceUnprovisioned
            }
            #[inline(always)]
            pub fn device_manufacturing(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceManufacturing
            }
            #[inline(always)]
            pub fn device_production(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceProduction
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type HwCapabilities = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwCapabilities = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CapLock = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::CapLockReadVal,
        crate::mci::regs::CapLockWriteVal,
    >;
    pub type HwRevId = ureg::ReadOnlyReg32<crate::mci::regs::HwRevIdReadVal>;
    pub type FwRevId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type HwConfig0 = ureg::ReadOnlyReg32<crate::mci::regs::HwConfig0ReadVal>;
    pub type HwConfig1 = ureg::ReadOnlyReg32<crate::mci::regs::HwConfig1ReadVal>;
    pub type McuIfuAxiUser = ureg::ReadOnlyReg32<u32>;
    pub type McuLsuAxiUser = ureg::ReadOnlyReg32<u32>;
    pub type McuSramConfigAxiUser = ureg::ReadOnlyReg32<u32>;
    pub type SocConfigAxiUser = ureg::ReadOnlyReg32<u32>;
    pub type FwFlowStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type HwFlowStatus = ureg::ReadOnlyReg32<crate::mci::regs::HwFlowStatusReadVal>;
    pub type ResetReason = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::ResetReasonReadVal,
        crate::mci::regs::ResetReasonWriteVal,
    >;
    pub type ResetStatus = ureg::ReadOnlyReg32<crate::mci::regs::ResetStatusReadVal>;
    pub type SecurityState = ureg::ReadOnlyReg32<crate::mci::regs::SecurityStateReadVal>;
    pub type HwErrorFatal = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::HwErrorFatalReadVal,
        crate::mci::regs::HwErrorFatalWriteVal,
    >;
    pub type AggErrorFatal = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::AggErrorFatalReadVal,
        crate::mci::regs::AggErrorFatalWriteVal,
    >;
    pub type HwErrorNonFatal = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::HwErrorNonFatalReadVal,
        crate::mci::regs::HwErrorNonFatalWriteVal,
    >;
    pub type AggErrorNonFatal = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::AggErrorNonFatalReadVal,
        crate::mci::regs::AggErrorNonFatalWriteVal,
    >;
    pub type FwErrorFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwErrorNonFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type HwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwExtendedErrorInfo = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalHwErrorFatalMask = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::InternalHwErrorFatalMaskReadVal,
        crate::mci::regs::InternalHwErrorFatalMaskWriteVal,
    >;
    pub type InternalHwErrorNonFatalMask = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::InternalHwErrorNonFatalMaskReadVal,
        crate::mci::regs::InternalHwErrorNonFatalMaskWriteVal,
    >;
    pub type InternalAggErrorFatalMask = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::InternalAggErrorFatalMaskReadVal,
        crate::mci::regs::InternalAggErrorFatalMaskWriteVal,
    >;
    pub type InternalAggErrorNonFatalMask = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::InternalAggErrorNonFatalMaskReadVal,
        crate::mci::regs::InternalAggErrorNonFatalMaskWriteVal,
    >;
    pub type InternalFwErrorFatalMask = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalFwErrorNonFatalMask = ureg::ReadWriteReg32<0, u32, u32>;
    pub type WdtTimer1En = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::WdtTimer1EnReadVal,
        crate::mci::regs::WdtTimer1EnWriteVal,
    >;
    pub type WdtTimer1Ctrl = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::WdtTimer1CtrlReadVal,
        crate::mci::regs::WdtTimer1CtrlWriteVal,
    >;
    pub type WdtTimer1TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type WdtTimer2En = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::WdtTimer2EnReadVal,
        crate::mci::regs::WdtTimer2EnWriteVal,
    >;
    pub type WdtTimer2Ctrl = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::WdtTimer2CtrlReadVal,
        crate::mci::regs::WdtTimer2CtrlWriteVal,
    >;
    pub type WdtTimer2TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type WdtStatus = ureg::ReadOnlyReg32<crate::mci::regs::WdtStatusReadVal>;
    pub type WdtCfg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuTimerConfig = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuRvMtimeL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuRvMtimeH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuRvMtimecmpL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuRvMtimecmpH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ResetRequest = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::ResetRequestReadVal,
        crate::mci::regs::ResetRequestWriteVal,
    >;
    pub type BootfsmGo =
        ureg::ReadWriteReg32<0, crate::mci::regs::GoReadVal, crate::mci::regs::GoWriteVal>;
    pub type CptraBootGo =
        ureg::ReadWriteReg32<0, crate::mci::regs::GoReadVal, crate::mci::regs::GoWriteVal>;
    pub type FwSramExecRegionSize = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::FwSramExecRegionSizeReadVal,
        crate::mci::regs::FwSramExecRegionSizeWriteVal,
    >;
    pub type McuNmiVector = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuResetVector = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Mbox0ValidAxiUser = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type Mbox0AxiUserLock = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::MboxxAxiUserLockReadVal,
        crate::mci::regs::MboxxAxiUserLockWriteVal,
    >;
    pub type Mbox1ValidAxiUser = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type Mbox1AxiUserLock = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::MboxxAxiUserLockReadVal,
        crate::mci::regs::MboxxAxiUserLockWriteVal,
    >;
    pub type SocDftEn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocHwDebugEn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocProdDebugState = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FcFipsZerozation = ureg::ReadWriteReg32<0, u32, u32>;
    pub type GenericInputWires = ureg::ReadOnlyReg32<u32>;
    pub type GenericOutputWires = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DebugIn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DebugOut = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SsDebugIntent = ureg::ReadOnlyReg32<crate::mci::regs::SsDebugIntentReadVal>;
    pub type SsConfigDoneSticky = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::SsConfigDoneReadVal,
        crate::mci::regs::SsConfigDoneWriteVal,
    >;
    pub type SsConfigDone = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::SsConfigDoneReadVal,
        crate::mci::regs::SsConfigDoneWriteVal,
    >;
    pub type ProdDebugUnlockPkHashReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfGlobalIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::GlobalIntrEnTReadVal,
        crate::sha512_acc::regs::GlobalIntrEnTWriteVal,
    >;
    pub type IntrBlockRfError0IntrEnR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error0IntrEnTReadVal,
        crate::mci::regs::Error0IntrEnTWriteVal,
    >;
    pub type IntrBlockRfError1IntrEnR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error1IntrEnTReadVal,
        crate::mci::regs::Error1IntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotif0IntrEnR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif0IntrEnTReadVal,
        crate::mci::regs::Notif0IntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotif1IntrEnR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif1IntrEnTReadVal,
        crate::mci::regs::Notif1IntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorGlobalIntrR =
        ureg::ReadOnlyReg32<crate::mci::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfNotifGlobalIntrR =
        ureg::ReadOnlyReg32<crate::mci::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfError0InternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error0IntrTReadVal,
        crate::mci::regs::Error0IntrTWriteVal,
    >;
    pub type IntrBlockRfError1InternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error1IntrTReadVal,
        crate::mci::regs::Error1IntrTWriteVal,
    >;
    pub type IntrBlockRfNotif0InternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif0IntrTReadVal,
        crate::mci::regs::Notif0IntrTWriteVal,
    >;
    pub type IntrBlockRfNotif1InternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif1IntrTReadVal,
        crate::mci::regs::Notif1IntrTWriteVal,
    >;
    pub type IntrBlockRfError0IntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error0IntrTrigTReadVal,
        crate::mci::regs::Error0IntrTrigTWriteVal,
    >;
    pub type IntrBlockRfError1IntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Error1IntrTrigTReadVal,
        crate::mci::regs::Error1IntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotif0IntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif0IntrTrigTReadVal,
        crate::mci::regs::Notif0IntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotif1IntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::mci::regs::Notif1IntrTrigTReadVal,
        crate::mci::regs::Notif1IntrTrigTWriteVal,
    >;
    pub type IntrBlockRfErrorInternalIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorMbox0EccUncIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorMbox1EccUncIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorMcuSramDmiAxiCollisionIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorWdtTimer1TimeoutIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorWdtTimer2TimeoutIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal0IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal1IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal2IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal3IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal4IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal5IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal6IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal7IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal8IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal9IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal10IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal11IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal12IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal13IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal14IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal15IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal16IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal17IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal18IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal19IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal20IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal21IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal22IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal23IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal24IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal25IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal26IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal27IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal28IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal29IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal30IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorAggErrorFatal31IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMcuSramEccCorIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifCptraMcuResetReqIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifGenInToggleIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal0IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal1IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal2IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal3IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal4IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal5IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal6IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal7IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal8IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal9IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal10IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal11IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal12IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal13IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal14IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal15IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal16IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal17IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal18IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal19IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal20IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal21IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal22IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal23IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal24IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal25IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal26IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal27IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal28IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal29IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal30IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifAggErrorNonFatal31IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox0TargetDoneIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox1TargetDoneIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox0CmdAvailIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox1CmdAvailIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifCptraMboxCmdAvailIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox0EccCorIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox1EccCorIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifDebugLockedIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifScanModeIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox0SocReqLockIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMbox1SocReqLockIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorInternalIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorMbox0EccUncIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorMbox1EccUncIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorWdtTimer1TimeoutIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorWdtTimer2TimeoutIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorMcuSramDmiAxiCollisionIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal0IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal1IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal2IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal3IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal4IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal5IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal6IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal7IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal8IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal9IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal10IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal11IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal12IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal13IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal14IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal15IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal16IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal17IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal18IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal19IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal20IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal21IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal22IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal23IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal24IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal25IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal26IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal27IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal28IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal29IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal30IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorAggErrorFatal31IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMcuSramEccCorIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifCptraMcuResetReqIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifGenInToggleIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal0IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal1IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal2IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal3IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal4IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal5IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal6IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal7IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal8IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal9IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal10IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal11IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal12IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal13IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal14IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal15IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal16IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal17IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal18IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal19IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal20IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal21IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal22IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal23IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal24IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal25IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal26IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal27IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal28IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal29IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal30IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifAggErrorNonFatal31IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox0TargetDoneIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox1TargetDoneIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox0CmdAvailIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox1CmdAvailIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifCptraMboxCmdAvailIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox0EccCorIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox1EccCorIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifDebugLockedIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifScanModeIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox0SocReqLockIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMbox1SocReqLockIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
}

// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at f6d35180615eb1908ba719e3296e82a610ebd31e
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct OtpCtrl {
    _priv: (),
}
impl OtpCtrl {
    pub const PTR: *mut u32 = 0x10060000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`otp_ctrl::regs::InterruptStateReadVal`]; Write value: [`otp_ctrl::regs::InterruptStateWriteVal`]
    #[inline(always)]
    pub fn interrupt_state(&self) -> ureg::RegRef<crate::otp_ctrl::meta::InterruptState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::InterruptEnableReadVal`]; Write value: [`otp_ctrl::regs::InterruptEnableWriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(&self) -> ureg::RegRef<crate::otp_ctrl::meta::InterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::InterruptTestReadVal`]; Write value: [`otp_ctrl::regs::InterruptTestWriteVal`]
    #[inline(always)]
    pub fn interrupt_test(&self) -> ureg::RegRef<crate::otp_ctrl::meta::InterruptTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::AlertTestReadVal`]; Write value: [`otp_ctrl::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::otp_ctrl::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::StatusReadVal`]; Write value: [`otp_ctrl::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Register write enable for all direct access interface registers.
    ///
    /// Read value: [`otp_ctrl::regs::DirectAccessRegwenReadVal`]; Write value: [`otp_ctrl::regs::DirectAccessRegwenWriteVal`]
    #[inline(always)]
    pub fn direct_access_regwen(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DirectAccessRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Command register for direct accesses.
    ///
    /// Read value: [`otp_ctrl::regs::DirectAccessCmdReadVal`]; Write value: [`otp_ctrl::regs::DirectAccessCmdWriteVal`]
    #[inline(always)]
    pub fn direct_access_cmd(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DirectAccessCmd, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Address register for direct accesses.
    ///
    /// Read value: [`otp_ctrl::regs::DirectAccessAddressReadVal`]; Write value: [`otp_ctrl::regs::DirectAccessAddressWriteVal`]
    #[inline(always)]
    pub fn direct_access_address(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DirectAccessAddress, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Register write enable for !!CHECK_TRIGGER.
    ///
    /// Read value: [`otp_ctrl::regs::CheckTriggerRegwenReadVal`]; Write value: [`otp_ctrl::regs::CheckTriggerRegwenWriteVal`]
    #[inline(always)]
    pub fn check_trigger_regwen(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::CheckTriggerRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x78 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Command register for direct accesses.
    ///
    /// Read value: [`otp_ctrl::regs::CheckTriggerReadVal`]; Write value: [`otp_ctrl::regs::CheckTriggerWriteVal`]
    #[inline(always)]
    pub fn check_trigger(&self) -> ureg::RegRef<crate::otp_ctrl::meta::CheckTrigger, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x7c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Register write enable for !!INTEGRITY_CHECK_PERIOD and !!CONSISTENCY_CHECK_PERIOD.
    ///
    /// Read value: [`otp_ctrl::regs::CheckRegwenReadVal`]; Write value: [`otp_ctrl::regs::CheckRegwenWriteVal`]
    #[inline(always)]
    pub fn check_regwen(&self) -> ureg::RegRef<crate::otp_ctrl::meta::CheckRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Timeout value for the integrity and consistency checks.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn check_timeout(&self) -> ureg::RegRef<crate::otp_ctrl::meta::CheckTimeout, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x84 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This value specifies the maximum period that can be generated pseudo-randomly.Only applies to the HW_CFG* and SECRET* partitions once they are locked.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn integrity_check_period(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::IntegrityCheckPeriod, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x88 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This value specifies the maximum period that can be generated pseudo-randomly.This applies to the LIFE_CYCLE partition and the HW_CFG* and SECRET* partitions once they are locked.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn consistency_check_period(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::ConsistencyCheckPeriod, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x8c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the SW_MANUF_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::SwManufPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::SwManufPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn sw_manuf_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SwManufPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x90 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the SVN_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::SvnPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::SvnPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn svn_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SvnPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x94 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the VENDOR_TEST_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::VendorTestPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::VendorTestPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn vendor_test_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorTestPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x98 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the VENDOR_HASHES_MANUF_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::VendorHashesManufPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::VendorHashesManufPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn vendor_hashes_manuf_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesManufPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x9c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the VENDOR_HASHES_PROD_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::VendorHashesProdPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::VendorHashesProdPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn vendor_hashes_prod_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesProdPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the VENDOR_REVOCATIONS_PROD_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::VendorRevocationsProdPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::VendorRevocationsProdPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn vendor_revocations_prod_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorRevocationsProdPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime read lock for the VENDOR_NON_SECRET_PROD_PARTITION partition.
    ///
    /// Read value: [`otp_ctrl::regs::VendorNonSecretProdPartitionReadLockReadVal`]; Write value: [`otp_ctrl::regs::VendorNonSecretProdPartitionReadLockWriteVal`]
    #[inline(always)]
    pub fn vendor_non_secret_prod_partition_read_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorNonSecretProdPartitionReadLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Volatile write lock for vendor public key hashes.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn vendor_pk_hash_volatile_lock(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorPkHashVolatileLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xac / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr0ReadVal`]; Write value: [`otp_ctrl::regs::Csr0WriteVal`]
    #[inline(always)]
    pub fn csr0(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x120 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr1ReadVal`]; Write value: [`otp_ctrl::regs::Csr1WriteVal`]
    #[inline(always)]
    pub fn csr1(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x124 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr2ReadVal`]; Write value: [`otp_ctrl::regs::Csr2WriteVal`]
    #[inline(always)]
    pub fn csr2(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x128 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr3ReadVal`]; Write value: [`otp_ctrl::regs::Csr3WriteVal`]
    #[inline(always)]
    pub fn csr3(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x12c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr4ReadVal`]; Write value: [`otp_ctrl::regs::Csr4WriteVal`]
    #[inline(always)]
    pub fn csr4(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x130 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr5ReadVal`]; Write value: [`otp_ctrl::regs::Csr5WriteVal`]
    #[inline(always)]
    pub fn csr5(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x134 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr6ReadVal`]; Write value: [`otp_ctrl::regs::Csr6WriteVal`]
    #[inline(always)]
    pub fn csr6(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x138 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`otp_ctrl::regs::Csr7ReadVal`]; Write value: [`otp_ctrl::regs::Csr7WriteVal`]
    #[inline(always)]
    pub fn csr7(&self) -> ureg::RegRef<crate::otp_ctrl::meta::Csr7, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x13c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn err_code_rf(&self) -> ErrCodeRfBlock<&TMmio> {
        ErrCodeRfBlock {
            ptr: unsafe { self.ptr.add(0x14 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn dai_wdata_rf(&self) -> DaiWdataRfBlock<&TMmio> {
        DaiWdataRfBlock {
            ptr: unsafe { self.ptr.add(0x68 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn dai_rdata_rf(&self) -> DaiRdataRfBlock<&TMmio> {
        DaiRdataRfBlock {
            ptr: unsafe { self.ptr.add(0x70 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_test_unlock_partition_digest(
        &self,
    ) -> SecretTestUnlockPartitionDigestBlock<&TMmio> {
        SecretTestUnlockPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xb0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_manuf_partition_digest(&self) -> SecretManufPartitionDigestBlock<&TMmio> {
        SecretManufPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xb8 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_prod_partition_0_digest(&self) -> SecretProdPartition0DigestBlock<&TMmio> {
        SecretProdPartition0DigestBlock {
            ptr: unsafe { self.ptr.add(0xc0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_prod_partition_1_digest(&self) -> SecretProdPartition1DigestBlock<&TMmio> {
        SecretProdPartition1DigestBlock {
            ptr: unsafe { self.ptr.add(0xc8 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_prod_partition_2_digest(&self) -> SecretProdPartition2DigestBlock<&TMmio> {
        SecretProdPartition2DigestBlock {
            ptr: unsafe { self.ptr.add(0xd0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_prod_partition_3_digest(&self) -> SecretProdPartition3DigestBlock<&TMmio> {
        SecretProdPartition3DigestBlock {
            ptr: unsafe { self.ptr.add(0xd8 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn sw_manuf_partition_digest(&self) -> SwManufPartitionDigestBlock<&TMmio> {
        SwManufPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xe0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn secret_lc_transition_partition_digest(
        &self,
    ) -> SecretLcTransitionPartitionDigestBlock<&TMmio> {
        SecretLcTransitionPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xe8 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_test_partition_digest(&self) -> VendorTestPartitionDigestBlock<&TMmio> {
        VendorTestPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xf0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_hashes_manuf_partition_digest(
        &self,
    ) -> VendorHashesManufPartitionDigestBlock<&TMmio> {
        VendorHashesManufPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0xf8 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_hashes_prod_partition_digest(
        &self,
    ) -> VendorHashesProdPartitionDigestBlock<&TMmio> {
        VendorHashesProdPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0x100 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_revocations_prod_partition_digest(
        &self,
    ) -> VendorRevocationsProdPartitionDigestBlock<&TMmio> {
        VendorRevocationsProdPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0x108 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_secret_prod_partition_digest(
        &self,
    ) -> VendorSecretProdPartitionDigestBlock<&TMmio> {
        VendorSecretProdPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0x110 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn vendor_non_secret_prod_partition_digest(
        &self,
    ) -> VendorNonSecretProdPartitionDigestBlock<&TMmio> {
        VendorNonSecretProdPartitionDigestBlock {
            ptr: unsafe { self.ptr.add(0x118 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct ErrCodeRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> ErrCodeRfBlock<TMmio> {
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_0(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_1(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_2(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_3(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_4(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_5(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_6(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_7(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode7, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_8(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode8, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_9(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode9, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_10(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode10, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_11(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode11, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_12(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode12, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_13(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode13, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_14(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode14, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_15(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode15, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_16(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode16, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// This register holds information about error conditions that occurred in the agents
    /// interacting with the OTP macr via the internal bus. The error codes should be checked
    /// if the partitions, DAI or LCI flag an error in the !!STATUS register, or when an
    /// !!INTR_STATE.otp_error has been triggered. Note that all errors trigger an otp_error
    /// interrupt, and in addition some errors may trigger either an fatal_macr_error or an
    /// fatal_check_error alert.
    ///
    /// Read value: [`otp_ctrl::regs::ErrCodeRegTReadVal`]; Write value: [`otp_ctrl::regs::ErrCodeRegTWriteVal`]
    #[inline(always)]
    pub fn err_code_17(&self) -> ureg::RegRef<crate::otp_ctrl::meta::ErrCodeRfErrCode17, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct DaiWdataRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> DaiWdataRfBlock<TMmio> {
    /// Write data for direct accesses.
    /// Hardware automatically determines the access granule (32bit or 64bit) based on which
    /// partition is being written to.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn direct_access_wdata_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DaiWdataRfDirectAccessWdata0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Write data for direct accesses.
    /// Hardware automatically determines the access granule (32bit or 64bit) based on which
    /// partition is being written to.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn direct_access_wdata_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DaiWdataRfDirectAccessWdata1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct DaiRdataRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> DaiRdataRfBlock<TMmio> {
    /// Read data for direct accesses.
    /// Hardware automatically determines the access granule (32bit or 64bit) based on which
    /// partition is read from.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn direct_access_rdata_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DaiRdataRfDirectAccessRdata0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read data for direct accesses.
    /// Hardware automatically determines the access granule (32bit or 64bit) based on which
    /// partition is read from.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn direct_access_rdata_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::DaiRdataRfDirectAccessRdata1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretTestUnlockPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretTestUnlockPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretTestUnlockPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretTestUnlockPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretManufPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretManufPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretManufPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretManufPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretProdPartition0DigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretProdPartition0DigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition0DigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition0DigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretProdPartition1DigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretProdPartition1DigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition1DigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition1DigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretProdPartition2DigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretProdPartition2DigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition2DigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition2DigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretProdPartition3DigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretProdPartition3DigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition3DigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretProdPartition3DigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SwManufPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SwManufPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SwManufPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SwManufPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecretLcTransitionPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecretLcTransitionPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretLcTransitionPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::SecretLcTransitionPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorTestPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorTestPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorTestPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorTestPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorHashesManufPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorHashesManufPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesManufPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesManufPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorHashesProdPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorHashesProdPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesProdPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorHashesProdPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorRevocationsProdPartitionDigestBlock<
    TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>,
> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorRevocationsProdPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorRevocationsProdPartitionDigestDigest0, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorRevocationsProdPartitionDigestDigest1, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorSecretProdPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorSecretProdPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorSecretProdPartitionDigestDigest0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorSecretProdPartitionDigestDigest1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct VendorNonSecretProdPartitionDigestBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>>
{
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> VendorNonSecretProdPartitionDigestBlock<TMmio> {
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_0(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorNonSecretProdPartitionDigestDigest0, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Integrity digest for partition.
    /// The integrity digest is 0 by default. Software must write this
    /// digest value via the direct access interface in order to lock the partition.
    /// After a reset, write access to the VENDOR_TEST partition is locked and  the digest becomes visible in this CSR.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn digest_1(
        &self,
    ) -> ureg::RegRef<crate::otp_ctrl::meta::VendorNonSecretProdPartitionDigestDigest1, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct ErrCodeRf {
    _priv: (),
}
impl ErrCodeRf {
    pub const PTR: *mut u32 = 0x14 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct DaiWdataRf {
    _priv: (),
}
impl DaiWdataRf {
    pub const PTR: *mut u32 = 0x68 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct DaiRdataRf {
    _priv: (),
}
impl DaiRdataRf {
    pub const PTR: *mut u32 = 0x70 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretTestUnlockPartitionDigest {
    _priv: (),
}
impl SecretTestUnlockPartitionDigest {
    pub const PTR: *mut u32 = 0xb0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretManufPartitionDigest {
    _priv: (),
}
impl SecretManufPartitionDigest {
    pub const PTR: *mut u32 = 0xb8 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretProdPartition0Digest {
    _priv: (),
}
impl SecretProdPartition0Digest {
    pub const PTR: *mut u32 = 0xc0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretProdPartition1Digest {
    _priv: (),
}
impl SecretProdPartition1Digest {
    pub const PTR: *mut u32 = 0xc8 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretProdPartition2Digest {
    _priv: (),
}
impl SecretProdPartition2Digest {
    pub const PTR: *mut u32 = 0xd0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretProdPartition3Digest {
    _priv: (),
}
impl SecretProdPartition3Digest {
    pub const PTR: *mut u32 = 0xd8 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SwManufPartitionDigest {
    _priv: (),
}
impl SwManufPartitionDigest {
    pub const PTR: *mut u32 = 0xe0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SecretLcTransitionPartitionDigest {
    _priv: (),
}
impl SecretLcTransitionPartitionDigest {
    pub const PTR: *mut u32 = 0xe8 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorTestPartitionDigest {
    _priv: (),
}
impl VendorTestPartitionDigest {
    pub const PTR: *mut u32 = 0xf0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorHashesManufPartitionDigest {
    _priv: (),
}
impl VendorHashesManufPartitionDigest {
    pub const PTR: *mut u32 = 0xf8 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorHashesProdPartitionDigest {
    _priv: (),
}
impl VendorHashesProdPartitionDigest {
    pub const PTR: *mut u32 = 0x100 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorRevocationsProdPartitionDigest {
    _priv: (),
}
impl VendorRevocationsProdPartitionDigest {
    pub const PTR: *mut u32 = 0x108 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorSecretProdPartitionDigest {
    _priv: (),
}
impl VendorSecretProdPartitionDigest {
    pub const PTR: *mut u32 = 0x110 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct VendorNonSecretProdPartitionDigest {
    _priv: (),
}
impl VendorNonSecretProdPartitionDigest {
    pub const PTR: *mut u32 = 0x118 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_macr_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_check_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_bus_integ_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_prim_otp_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn recov_prim_otp_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CheckRegwenWriteVal(u32);
    impl CheckRegwenWriteVal {
        /// When cleared to 0, !!INTEGRITY_CHECK_PERIOD and !!CONSISTENCY_CHECK_PERIOD registers cannot be written anymore.Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CheckRegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CheckRegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CheckRegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CheckTriggerWriteVal(u32);
    impl CheckTriggerWriteVal {
        /// Writing 1 to this bit triggers an integrity check. SW should monitor !!STATUS.CHECK_PENDING
        /// and wait until the check has been completed. If there are any errors, those will be flagged
        /// in the !!STATUS and !!ERR_CODE registers, and via the interrupts and alerts.
        #[inline(always)]
        pub fn integrity(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Writing 1 to this bit triggers a consistency check. SW should monitor !!STATUS.CHECK_PENDINGand wait until the check has been completed. If there are any errors, those will be flaggedin the !!STATUS and !!ERR_CODE registers, and via interrupts and alerts.
        #[inline(always)]
        pub fn consistency(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CheckTriggerWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CheckTriggerWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CheckTriggerWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CheckTriggerRegwenReadVal(u32);
    impl CheckTriggerRegwenReadVal {
        /// When cleared to 0, the !!CHECK_TRIGGER register cannot be written anymore.
        /// Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CheckTriggerRegwenWriteVal {
            CheckTriggerRegwenWriteVal(self.0)
        }
    }
    impl From<u32> for CheckTriggerRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CheckTriggerRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: CheckTriggerRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CheckTriggerRegwenWriteVal(u32);
    impl CheckTriggerRegwenWriteVal {
        /// When cleared to 0, the !!CHECK_TRIGGER register cannot be written anymore.
        /// Write 0 to clear this bit.
        #[inline(always)]
        pub fn regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CheckTriggerRegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CheckTriggerRegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CheckTriggerRegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr0ReadVal(u32);
    impl Csr0ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        #[inline(always)]
        pub fn field1(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> u32 {
            (self.0 >> 4) & 0x3ff
        }
        #[inline(always)]
        pub fn field4(&self) -> u32 {
            (self.0 >> 16) & 0x7ff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr0WriteVal {
            Csr0WriteVal(self.0)
        }
    }
    impl From<u32> for Csr0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr0WriteVal(u32);
    impl Csr0WriteVal {
        #[inline(always)]
        pub fn field0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn field2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn field3(self, val: u32) -> Self {
            Self((self.0 & !(0x3ff << 4)) | ((val & 0x3ff) << 4))
        }
        #[inline(always)]
        pub fn field4(self, val: u32) -> Self {
            Self((self.0 & !(0x7ff << 16)) | ((val & 0x7ff) << 16))
        }
    }
    impl From<u32> for Csr0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr1ReadVal(u32);
    impl Csr1ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
        #[inline(always)]
        pub fn field1(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        #[inline(always)]
        pub fn field2(&self) -> u32 {
            (self.0 >> 8) & 0x7f
        }
        #[inline(always)]
        pub fn field3(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        #[inline(always)]
        pub fn field4(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr1WriteVal {
            Csr1WriteVal(self.0)
        }
    }
    impl From<u32> for Csr1ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr1ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr1ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr1WriteVal(u32);
    impl Csr1WriteVal {
        #[inline(always)]
        pub fn field0(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 0)) | ((val & 0x7f) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        #[inline(always)]
        pub fn field2(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 8)) | ((val & 0x7f) << 8))
        }
        #[inline(always)]
        pub fn field3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        #[inline(always)]
        pub fn field4(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for Csr1WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr1WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr1WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr2ReadVal(u32);
    impl Csr2ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr2WriteVal {
            Csr2WriteVal(self.0)
        }
    }
    impl From<u32> for Csr2ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr2ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr2ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr2WriteVal(u32);
    impl Csr2WriteVal {
        #[inline(always)]
        pub fn field0(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for Csr2WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr2WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr2WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr3ReadVal(u32);
    impl Csr3ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        #[inline(always)]
        pub fn field1(&self) -> u32 {
            (self.0 >> 4) & 0x3ff
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn field4(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn field5(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn field6(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        #[inline(always)]
        pub fn field7(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        #[inline(always)]
        pub fn field8(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr3WriteVal {
            Csr3WriteVal(self.0)
        }
    }
    impl From<u32> for Csr3ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr3ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr3ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr3WriteVal(u32);
    impl Csr3WriteVal {
        #[inline(always)]
        pub fn field0(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: u32) -> Self {
            Self((self.0 & !(0x3ff << 4)) | ((val & 0x3ff) << 4))
        }
        #[inline(always)]
        pub fn field2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
    }
    impl From<u32> for Csr3WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr3WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr3WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr4ReadVal(u32);
    impl Csr4ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 0x3ff
        }
        #[inline(always)]
        pub fn field1(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr4WriteVal {
            Csr4WriteVal(self.0)
        }
    }
    impl From<u32> for Csr4ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr4ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr4ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr4WriteVal(u32);
    impl Csr4WriteVal {
        #[inline(always)]
        pub fn field0(self, val: u32) -> Self {
            Self((self.0 & !(0x3ff << 0)) | ((val & 0x3ff) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn field2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn field3(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
    }
    impl From<u32> for Csr4WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr4WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr4WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr5ReadVal(u32);
    impl Csr5ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 0x3f
        }
        #[inline(always)]
        pub fn field1(&self) -> u32 {
            (self.0 >> 6) & 3
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> u32 {
            (self.0 >> 9) & 7
        }
        #[inline(always)]
        pub fn field4(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn field5(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn field6(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr5WriteVal {
            Csr5WriteVal(self.0)
        }
    }
    impl From<u32> for Csr5ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr5ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr5ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr5WriteVal(u32);
    impl Csr5WriteVal {
        #[inline(always)]
        pub fn field0(self, val: u32) -> Self {
            Self((self.0 & !(0x3f << 0)) | ((val & 0x3f) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: u32) -> Self {
            Self((self.0 & !(3 << 6)) | ((val & 3) << 6))
        }
        #[inline(always)]
        pub fn field6(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for Csr5WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr5WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr5WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr6ReadVal(u32);
    impl Csr6ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 0x3ff
        }
        #[inline(always)]
        pub fn field1(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Csr6WriteVal {
            Csr6WriteVal(self.0)
        }
    }
    impl From<u32> for Csr6ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr6ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr6ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr6WriteVal(u32);
    impl Csr6WriteVal {
        #[inline(always)]
        pub fn field0(self, val: u32) -> Self {
            Self((self.0 & !(0x3ff << 0)) | ((val & 0x3ff) << 0))
        }
        #[inline(always)]
        pub fn field1(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn field2(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn field3(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for Csr6WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr6WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Csr6WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Csr7ReadVal(u32);
    impl Csr7ReadVal {
        #[inline(always)]
        pub fn field0(&self) -> u32 {
            (self.0 >> 0) & 0x3f
        }
        #[inline(always)]
        pub fn field1(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        #[inline(always)]
        pub fn field2(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn field3(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
    }
    impl From<u32> for Csr7ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Csr7ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Csr7ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DirectAccessAddressReadVal(u32);
    impl DirectAccessAddressReadVal {
        /// This is the address for the OTP word to be read or written thrughthe direct access interface. Note that the address is aligned to the access sizeinternally, hence bits 1:0 are ignored for 32bit accesses, and bits 2:0 are ignoredfor 64bit accesses.For the digest calculation command, set this register to the partition base offset.
        #[inline(always)]
        pub fn address(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DirectAccessAddressWriteVal {
            DirectAccessAddressWriteVal(self.0)
        }
    }
    impl From<u32> for DirectAccessAddressReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DirectAccessAddressReadVal> for u32 {
        #[inline(always)]
        fn from(val: DirectAccessAddressReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DirectAccessAddressWriteVal(u32);
    impl DirectAccessAddressWriteVal {
        /// This is the address for the OTP word to be read or written thrughthe direct access interface. Note that the address is aligned to the access sizeinternally, hence bits 1:0 are ignored for 32bit accesses, and bits 2:0 are ignoredfor 64bit accesses.For the digest calculation command, set this register to the partition base offset.
        #[inline(always)]
        pub fn address(self, val: u32) -> Self {
            Self((self.0 & !(0xfff << 0)) | ((val & 0xfff) << 0))
        }
    }
    impl From<u32> for DirectAccessAddressWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DirectAccessAddressWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DirectAccessAddressWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DirectAccessCmdWriteVal(u32);
    impl DirectAccessCmdWriteVal {
        /// Initiates a readout sequence that reads the location specifiedby !!DIRECT_ACCESS_ADDRESS. The command places the data read into!!DIRECT_ACCESS_RDATA_0 and !!DIRECT_ACCESS_RDATA_1 (for 64bit partitions).
        #[inline(always)]
        pub fn rd(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Initiates a prgramming sequence that writes the data in !!DIRECT_ACCESS_WDATA_0and !!DIRECT_ACCESS_WDATA_1 (for 64bit partitions) to the location specified by!!DIRECT_ACCESS_ADDRESS.
        #[inline(always)]
        pub fn wr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Initiates the digest calculation and locking sequence for the partition specified by!!DIRECT_ACCESS_ADDRESS.
        #[inline(always)]
        pub fn digest(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for DirectAccessCmdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DirectAccessCmdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DirectAccessCmdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DirectAccessRegwenReadVal(u32);
    impl DirectAccessRegwenReadVal {
        /// This bit contrls whether the DAI registers can be written.Write 0 to it in order to clear the bit.Note that the hardware also modulates this bit and sets it to 0 temporarilyduring an OTP operation such that the corresponding address and data registerscannot be modified while an operation is pending. The !!DAI_IDLE status bitwill also be set to 0 in such a case.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DirectAccessRegwenWriteVal {
            DirectAccessRegwenWriteVal(self.0)
        }
    }
    impl From<u32> for DirectAccessRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DirectAccessRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: DirectAccessRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DirectAccessRegwenWriteVal(u32);
    impl DirectAccessRegwenWriteVal {
        /// This bit contrls whether the DAI registers can be written.Write 0 to it in order to clear the bit.Note that the hardware also modulates this bit and sets it to 0 temporarilyduring an OTP operation such that the corresponding address and data registerscannot be modified while an operation is pending. The !!DAI_IDLE status bitwill also be set to 0 in such a case.
        #[inline(always)]
        pub fn regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for DirectAccessRegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DirectAccessRegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DirectAccessRegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableReadVal(u32);
    impl InterruptEnableReadVal {
        /// Enable interrupt when otp_operation_done is set.
        #[inline(always)]
        pub fn otp_operation_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable interrupt when otp_error is set.
        #[inline(always)]
        pub fn otp_error(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableWriteVal {
            InterruptEnableWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableWriteVal(u32);
    impl InterruptEnableWriteVal {
        /// Enable interrupt when otp_operation_done is set.
        #[inline(always)]
        pub fn otp_operation_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable interrupt when otp_error is set.
        #[inline(always)]
        pub fn otp_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateReadVal(u32);
    impl InterruptStateReadVal {
        /// A direct access command or digest calculation operation has completed.
        #[inline(always)]
        pub fn otp_operation_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// An error has occurred in the OTP contrller. Check the !!ERR_CODE register to get more information.
        #[inline(always)]
        pub fn otp_error(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStateWriteVal {
            InterruptStateWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateWriteVal(u32);
    impl InterruptStateWriteVal {
        /// A direct access command or digest calculation operation has completed.
        #[inline(always)]
        pub fn otp_operation_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// An error has occurred in the OTP contrller. Check the !!ERR_CODE register to get more information.
        #[inline(always)]
        pub fn otp_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptStateWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptTestWriteVal(u32);
    impl InterruptTestWriteVal {
        /// Write 1 to force otp_operation_done to 1.
        #[inline(always)]
        pub fn otp_operation_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to force otp_error to 1.
        #[inline(always)]
        pub fn otp_error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_test_unlock_partition_error(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_manuf_partition_error(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_prod_partition_0_error(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_prod_partition_1_error(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_prod_partition_2_error(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_prod_partition_3_error(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn sw_manuf_partition_error(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn secret_lc_transition_partition_error(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn svn_partition_error(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_test_partition_error(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_hashes_manuf_partition_error(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_hashes_prod_partition_error(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_revocations_prod_partition_error(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_secret_prod_partition_error(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn vendor_non_secret_prod_partition_error(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn life_cycle_error(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn dai_error(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn lci_error(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// Set to 1 if an error occurred in this partition. If set to 1, SW should check the !!ERR_CODE register at the corresponding index.
        #[inline(always)]
        pub fn timeout_error(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        /// Set to 1 if the LFSR timer FSM has reached an invalid state. This raises an fatal_check_error alert and is an unrecoverable error condition.
        #[inline(always)]
        pub fn lfsr_fsm_error(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        /// Set to 1 if the scrambling datapath FSM has reached an invalid state. This raises an fatal_check_error alert and is an unrecoverable error condition.
        #[inline(always)]
        pub fn scrambling_fsm_error(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// This bit is set to 1 if a fatal bus integrity fault is detected. This error triggers a fatal_bus_integ_error alert.
        #[inline(always)]
        pub fn bus_integ_error(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// Set to 1 if the DAI is idle and ready to accept commands.
        #[inline(always)]
        pub fn dai_idle(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// Set to 1 if an integrity or consistency check triggered by the LFSR timer or via !!CHECK_TRIGGER is pending.
        #[inline(always)]
        pub fn check_pending(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SvnPartitionReadLockReadVal(u32);
    impl SvnPartitionReadLockReadVal {
        /// When cleared to 0, read access to the SVN_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SvnPartitionReadLockWriteVal {
            SvnPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for SvnPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SvnPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: SvnPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SvnPartitionReadLockWriteVal(u32);
    impl SvnPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the SVN_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SvnPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SvnPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SvnPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SwManufPartitionReadLockReadVal(u32);
    impl SwManufPartitionReadLockReadVal {
        /// When cleared to 0, read access to the SW_MANUF_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SwManufPartitionReadLockWriteVal {
            SwManufPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for SwManufPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SwManufPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: SwManufPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SwManufPartitionReadLockWriteVal(u32);
    impl SwManufPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the SW_MANUF_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SwManufPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SwManufPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SwManufPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorHashesManufPartitionReadLockReadVal(u32);
    impl VendorHashesManufPartitionReadLockReadVal {
        /// When cleared to 0, read access to the VENDOR_HASHES_MANUF_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> VendorHashesManufPartitionReadLockWriteVal {
            VendorHashesManufPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for VendorHashesManufPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorHashesManufPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: VendorHashesManufPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorHashesManufPartitionReadLockWriteVal(u32);
    impl VendorHashesManufPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the VENDOR_HASHES_MANUF_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for VendorHashesManufPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorHashesManufPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: VendorHashesManufPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorHashesProdPartitionReadLockReadVal(u32);
    impl VendorHashesProdPartitionReadLockReadVal {
        /// When cleared to 0, read access to the VENDOR_HASHES_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> VendorHashesProdPartitionReadLockWriteVal {
            VendorHashesProdPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for VendorHashesProdPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorHashesProdPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: VendorHashesProdPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorHashesProdPartitionReadLockWriteVal(u32);
    impl VendorHashesProdPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the VENDOR_HASHES_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for VendorHashesProdPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorHashesProdPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: VendorHashesProdPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorNonSecretProdPartitionReadLockReadVal(u32);
    impl VendorNonSecretProdPartitionReadLockReadVal {
        /// When cleared to 0, read access to the VENDOR_NON_SECRET_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> VendorNonSecretProdPartitionReadLockWriteVal {
            VendorNonSecretProdPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for VendorNonSecretProdPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorNonSecretProdPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: VendorNonSecretProdPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorNonSecretProdPartitionReadLockWriteVal(u32);
    impl VendorNonSecretProdPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the VENDOR_NON_SECRET_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for VendorNonSecretProdPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorNonSecretProdPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: VendorNonSecretProdPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorRevocationsProdPartitionReadLockReadVal(u32);
    impl VendorRevocationsProdPartitionReadLockReadVal {
        /// When cleared to 0, read access to the VENDOR_REVOCATIONS_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> VendorRevocationsProdPartitionReadLockWriteVal {
            VendorRevocationsProdPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for VendorRevocationsProdPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorRevocationsProdPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: VendorRevocationsProdPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorRevocationsProdPartitionReadLockWriteVal(u32);
    impl VendorRevocationsProdPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the VENDOR_REVOCATIONS_PROD_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for VendorRevocationsProdPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorRevocationsProdPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: VendorRevocationsProdPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorTestPartitionReadLockReadVal(u32);
    impl VendorTestPartitionReadLockReadVal {
        /// When cleared to 0, read access to the VENDOR_TEST_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> VendorTestPartitionReadLockWriteVal {
            VendorTestPartitionReadLockWriteVal(self.0)
        }
    }
    impl From<u32> for VendorTestPartitionReadLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorTestPartitionReadLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: VendorTestPartitionReadLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct VendorTestPartitionReadLockWriteVal(u32);
    impl VendorTestPartitionReadLockWriteVal {
        /// When cleared to 0, read access to the VENDOR_TEST_PARTITION partition is locked.Write 0 to clear this bit.
        #[inline(always)]
        pub fn read_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for VendorTestPartitionReadLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<VendorTestPartitionReadLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: VendorTestPartitionReadLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeRegTReadVal(u32);
    impl ErrCodeRegTReadVal {
        /// This register holds information about error conditions that occurred in the agents interacting with the OTP macro via the internal bus.
        #[inline(always)]
        pub fn err_code(&self) -> u32 {
            (self.0 >> 0) & 7
        }
    }
    impl From<u32> for ErrCodeRegTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeRegTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeRegTReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type InterruptState = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::InterruptStateReadVal,
        crate::otp_ctrl::regs::InterruptStateWriteVal,
    >;
    pub type InterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::InterruptEnableReadVal,
        crate::otp_ctrl::regs::InterruptEnableWriteVal,
    >;
    pub type InterruptTest = ureg::WriteOnlyReg32<0, crate::otp_ctrl::regs::InterruptTestWriteVal>;
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::otp_ctrl::regs::AlertTestWriteVal>;
    pub type Status = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::StatusReadVal>;
    pub type DirectAccessRegwen = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::DirectAccessRegwenReadVal,
        crate::otp_ctrl::regs::DirectAccessRegwenWriteVal,
    >;
    pub type DirectAccessCmd =
        ureg::WriteOnlyReg32<0, crate::otp_ctrl::regs::DirectAccessCmdWriteVal>;
    pub type DirectAccessAddress = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::DirectAccessAddressReadVal,
        crate::otp_ctrl::regs::DirectAccessAddressWriteVal,
    >;
    pub type CheckTriggerRegwen = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::CheckTriggerRegwenReadVal,
        crate::otp_ctrl::regs::CheckTriggerRegwenWriteVal,
    >;
    pub type CheckTrigger = ureg::WriteOnlyReg32<0, crate::otp_ctrl::regs::CheckTriggerWriteVal>;
    pub type CheckRegwen = ureg::WriteOnlyReg32<0, crate::otp_ctrl::regs::CheckRegwenWriteVal>;
    pub type CheckTimeout = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntegrityCheckPeriod = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ConsistencyCheckPeriod = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SwManufPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::SwManufPartitionReadLockReadVal,
        crate::otp_ctrl::regs::SwManufPartitionReadLockWriteVal,
    >;
    pub type SvnPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::SvnPartitionReadLockReadVal,
        crate::otp_ctrl::regs::SvnPartitionReadLockWriteVal,
    >;
    pub type VendorTestPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::VendorTestPartitionReadLockReadVal,
        crate::otp_ctrl::regs::VendorTestPartitionReadLockWriteVal,
    >;
    pub type VendorHashesManufPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::VendorHashesManufPartitionReadLockReadVal,
        crate::otp_ctrl::regs::VendorHashesManufPartitionReadLockWriteVal,
    >;
    pub type VendorHashesProdPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::VendorHashesProdPartitionReadLockReadVal,
        crate::otp_ctrl::regs::VendorHashesProdPartitionReadLockWriteVal,
    >;
    pub type VendorRevocationsProdPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::VendorRevocationsProdPartitionReadLockReadVal,
        crate::otp_ctrl::regs::VendorRevocationsProdPartitionReadLockWriteVal,
    >;
    pub type VendorNonSecretProdPartitionReadLock = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::VendorNonSecretProdPartitionReadLockReadVal,
        crate::otp_ctrl::regs::VendorNonSecretProdPartitionReadLockWriteVal,
    >;
    pub type VendorPkHashVolatileLock = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Csr0 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr0ReadVal,
        crate::otp_ctrl::regs::Csr0WriteVal,
    >;
    pub type Csr1 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr1ReadVal,
        crate::otp_ctrl::regs::Csr1WriteVal,
    >;
    pub type Csr2 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr2ReadVal,
        crate::otp_ctrl::regs::Csr2WriteVal,
    >;
    pub type Csr3 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr3ReadVal,
        crate::otp_ctrl::regs::Csr3WriteVal,
    >;
    pub type Csr4 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr4ReadVal,
        crate::otp_ctrl::regs::Csr4WriteVal,
    >;
    pub type Csr5 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr5ReadVal,
        crate::otp_ctrl::regs::Csr5WriteVal,
    >;
    pub type Csr6 = ureg::ReadWriteReg32<
        0,
        crate::otp_ctrl::regs::Csr6ReadVal,
        crate::otp_ctrl::regs::Csr6WriteVal,
    >;
    pub type Csr7 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::Csr7ReadVal>;
    pub type ErrCodeRfErrCode0 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode1 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode2 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode3 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode4 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode5 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode6 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode7 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode8 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode9 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode10 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode11 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode12 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode13 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode14 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode15 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode16 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type ErrCodeRfErrCode17 = ureg::ReadOnlyReg32<crate::otp_ctrl::regs::ErrCodeRegTReadVal>;
    pub type DaiWdataRfDirectAccessWdata0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DaiWdataRfDirectAccessWdata1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DaiRdataRfDirectAccessRdata0 = ureg::ReadOnlyReg32<u32>;
    pub type DaiRdataRfDirectAccessRdata1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretTestUnlockPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretTestUnlockPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretManufPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretManufPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition0DigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition0DigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition1DigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition1DigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition2DigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition2DigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition3DigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretProdPartition3DigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SwManufPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SwManufPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type SecretLcTransitionPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type SecretLcTransitionPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorTestPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorTestPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorHashesManufPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorHashesManufPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorHashesProdPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorHashesProdPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorRevocationsProdPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorRevocationsProdPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorSecretProdPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorSecretProdPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
    pub type VendorNonSecretProdPartitionDigestDigest0 = ureg::ReadOnlyReg32<u32>;
    pub type VendorNonSecretProdPartitionDigestDigest1 = ureg::ReadOnlyReg32<u32>;
}

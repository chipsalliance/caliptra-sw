// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at c8aa4673b2564d952e51549ef93b6539d9c0a65f
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct CsrngReg {
    _priv: (),
}
impl CsrngReg {
    pub const PTR: *mut u32 = 0x20002000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`csrng::regs::InterruptStateReadVal`]; Write value: [`csrng::regs::InterruptStateWriteVal`]
    #[inline(always)]
    pub fn interrupt_state(&self) -> ureg::RegRef<crate::csrng::meta::InterruptState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::InterruptEnableReadVal`]; Write value: [`csrng::regs::InterruptEnableWriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(&self) -> ureg::RegRef<crate::csrng::meta::InterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::InterruptTestReadVal`]; Write value: [`csrng::regs::InterruptTestWriteVal`]
    #[inline(always)]
    pub fn interrupt_test(&self) -> ureg::RegRef<crate::csrng::meta::InterruptTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::AlertTestReadVal`]; Write value: [`csrng::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::csrng::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::RegwenReadVal`]; Write value: [`csrng::regs::RegwenWriteVal`]
    #[inline(always)]
    pub fn regwen(&self) -> ureg::RegRef<crate::csrng::meta::Regwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::CtrlReadVal`]; Write value: [`csrng::regs::CtrlWriteVal`]
    #[inline(always)]
    pub fn ctrl(&self) -> ureg::RegRef<crate::csrng::meta::Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::CmdReqReadVal`]; Write value: [`csrng::regs::CmdReqWriteVal`]
    #[inline(always)]
    pub fn cmd_req(&self) -> ureg::RegRef<crate::csrng::meta::CmdReq, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::SwCmdStsReadVal`]; Write value: [`csrng::regs::SwCmdStsWriteVal`]
    #[inline(always)]
    pub fn sw_cmd_sts(&self) -> ureg::RegRef<crate::csrng::meta::SwCmdSts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::GenbitsVldReadVal`]; Write value: [`csrng::regs::GenbitsVldWriteVal`]
    #[inline(always)]
    pub fn genbits_vld(&self) -> ureg::RegRef<crate::csrng::meta::GenbitsVld, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn genbits(&self) -> ureg::RegRef<crate::csrng::meta::Genbits, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::IntStateNumReadVal`]; Write value: [`csrng::regs::IntStateNumWriteVal`]
    #[inline(always)]
    pub fn int_state_num(&self) -> ureg::RegRef<crate::csrng::meta::IntStateNum, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn int_state_val(&self) -> ureg::RegRef<crate::csrng::meta::IntStateVal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::HwExcStsReadVal`]; Write value: [`csrng::regs::HwExcStsWriteVal`]
    #[inline(always)]
    pub fn hw_exc_sts(&self) -> ureg::RegRef<crate::csrng::meta::HwExcSts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::RecovAlertStsReadVal`]; Write value: [`csrng::regs::RecovAlertStsWriteVal`]
    #[inline(always)]
    pub fn recov_alert_sts(&self) -> ureg::RegRef<crate::csrng::meta::RecovAlertSts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::ErrCodeReadVal`]; Write value: [`csrng::regs::ErrCodeWriteVal`]
    #[inline(always)]
    pub fn err_code(&self) -> ureg::RegRef<crate::csrng::meta::ErrCode, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::ErrCodeTestReadVal`]; Write value: [`csrng::regs::ErrCodeTestWriteVal`]
    #[inline(always)]
    pub fn err_code_test(&self) -> ureg::RegRef<crate::csrng::meta::ErrCodeTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`csrng::regs::MainSmStateReadVal`]; Write value: [`csrng::regs::MainSmStateWriteVal`]
    #[inline(always)]
    pub fn main_sm_state(&self) -> ureg::RegRef<crate::csrng::meta::MainSmState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn recov_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CmdReqWriteVal(u32);
    impl CmdReqWriteVal {
        /// Application Command: Selects one of five operations to perform.
        /// The commands supported are instantiate, reseed, generate, update,
        /// and uninstantiate. Each application interface port used by peripheral
        /// hardware commands a unique instance number in CSRNG.
        #[inline(always)]
        pub fn acmd(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        /// Command Length: Number of 32-bit words that can optionally be appended
        /// to the command. A value of zero will only transfer the command header.
        /// A value of 4'hc will transfer the header plus an additional twelve
        /// 32-bit words of data.
        #[inline(always)]
        pub fn clen(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
        /// Command Flag0: flag0 is associated with current command. Setting this
        /// field to kMultiBitBool4True will enable flag0 to be enabled. Note that
        /// flag0 is used for the instantiate and reseed commands only, for all other commands its value is ignored.
        #[inline(always)]
        pub fn flag0(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
        }
        /// Generate Length: Only defined for the generate command, this field
        /// is the total number of cryptographic entropy blocks requested. Each
        /// unit represents 128 bits of entropy returned. The NIST reference name
        /// is max_number_of_bit_per_request, and this field size supports the
        /// maximum size of 219 bits. For the maximum size, this field should be
        /// set to 4096, resulting in a max_number_of_bit_per_request value of
        /// 4096 x 128 bits. For a smaller example, a value of 8 would return
        /// a total of 1024 bits.
        #[inline(always)]
        pub fn glen(self, val: u32) -> Self {
            Self((self.0 & !(0x1fff << 12)) | ((val & 0x1fff) << 12))
        }
    }
    impl From<u32> for CmdReqWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CmdReqWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CmdReqWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CtrlReadVal(u32);
    impl CtrlReadVal {
        /// Setting this field to kMultiBitBool4True will enable the CSRNG module. The modules
        /// of the entropy complex may only be enabled and disabled in a specific order, see
        /// Programmers Guide for details.
        #[inline(always)]
        pub fn enable(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Setting this field to kMultiBitBool4True will enable reading from the !!GENBITS register.
        /// This application interface for software (register based) will be enabled
        /// only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
        #[inline(always)]
        pub fn sw_app_enable(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        /// Setting this field to kMultiBitBool4True will enable reading from the !!INT_STATE_VAL register.
        /// Reading the internal state of the enable instances will be enabled
        /// only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
        #[inline(always)]
        pub fn read_int_state(&self) -> u32 {
            (self.0 >> 8) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CtrlWriteVal {
            CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        /// Setting this field to kMultiBitBool4True will enable the CSRNG module. The modules
        /// of the entropy complex may only be enabled and disabled in a specific order, see
        /// Programmers Guide for details.
        #[inline(always)]
        pub fn enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        /// Setting this field to kMultiBitBool4True will enable reading from the !!GENBITS register.
        /// This application interface for software (register based) will be enabled
        /// only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
        #[inline(always)]
        pub fn sw_app_enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
        /// Setting this field to kMultiBitBool4True will enable reading from the !!INT_STATE_VAL register.
        /// Reading the internal state of the enable instances will be enabled
        /// only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
        #[inline(always)]
        pub fn read_int_state(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
        }
    }
    impl From<u32> for CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeReadVal(u32);
    impl ErrCodeReadVal {
        /// This bit will be set to one when an error has been detected for the
        /// command stage command FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_cmd_err(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// command stage genbits FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_genbits_err(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// cmdreq FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_cmdreq_err(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// rcstage FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_rcstage_err(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// keyvrc FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_keyvrc_err(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// updreq FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_updreq_err(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// bencreq FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_bencreq_err(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// bencack FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_bencack_err(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// pdata FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_pdata_err(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// final FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_final_err(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// gbencack FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_gbencack_err(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// grcstage FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_grcstage_err(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// ggenreq FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_ggenreq_err(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// gadstage FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_gadstage_err(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// ggenbits FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_ggenbits_err(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// blkenc FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_blkenc_err(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// command stage state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn cmd_stage_sm_err(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// main state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn main_sm_err(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// ctr_drbg gen state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn drbg_gen_sm_err(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// ctr_drbg update block encode state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn drbg_updbe_sm_err(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// ctr_drbg update out block state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn drbg_updob_sm_err(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// This bit will be set to one when an AES fatal error has been detected.
        /// This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn aes_cipher_sm_err(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// This bit will be set to one when a mismatch in any of the hardened counters
        /// has been detected.
        /// This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn cmd_gen_cnt_err(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 15 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any full FIFO that has been recieved a write pulse.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_write_err(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 15 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any empty FIFO that has recieved a read pulse.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_read_err(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 15 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any FIFO where both the empty and full status bits are set.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_state_err(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
    }
    impl From<u32> for ErrCodeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeTestReadVal(u32);
    impl ErrCodeTestReadVal {
        /// Setting this field will set the bit number for which an error
        /// will be forced in the hardware. This bit number is that same one
        /// found in the !!ERR_CODE register. The action of writing this
        /// register will force an error pulse. The sole purpose of this
        /// register is to test that any error properly propagates to either
        /// an interrupt or an alert.
        #[inline(always)]
        pub fn err_code_test(&self) -> u32 {
            (self.0 >> 0) & 0x1f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrCodeTestWriteVal {
            ErrCodeTestWriteVal(self.0)
        }
    }
    impl From<u32> for ErrCodeTestReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeTestReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeTestReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeTestWriteVal(u32);
    impl ErrCodeTestWriteVal {
        /// Setting this field will set the bit number for which an error
        /// will be forced in the hardware. This bit number is that same one
        /// found in the !!ERR_CODE register. The action of writing this
        /// register will force an error pulse. The sole purpose of this
        /// register is to test that any error properly propagates to either
        /// an interrupt or an alert.
        #[inline(always)]
        pub fn err_code_test(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 0)) | ((val & 0x1f) << 0))
        }
    }
    impl From<u32> for ErrCodeTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GenbitsVldReadVal(u32);
    impl GenbitsVldReadVal {
        /// This bit is set when genbits are available on this application interface.
        #[inline(always)]
        pub fn genbits_vld(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit is set when genbits are FIPS/CC compliant.
        #[inline(always)]
        pub fn genbits_fips(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for GenbitsVldReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GenbitsVldReadVal> for u32 {
        #[inline(always)]
        fn from(val: GenbitsVldReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwExcStsReadVal(u32);
    impl HwExcStsReadVal {
        /// Reading this register indicates whether one of the CSRNG HW instances has
        /// encountered an exception.  Each bit corresponds to a particular hardware
        /// instance, with bit 0 corresponding to instance HW0, bit 1 corresponding
        /// to instance HW1, and so forth. (To monitor the status of requests made
        /// to the SW instance, check the !!SW_CMD_STS register). Writing a zero to this register
        /// resets the status bits.
        #[inline(always)]
        pub fn hw_exc_sts(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HwExcStsWriteVal {
            HwExcStsWriteVal(self.0)
        }
    }
    impl From<u32> for HwExcStsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwExcStsReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwExcStsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwExcStsWriteVal(u32);
    impl HwExcStsWriteVal {
        /// Reading this register indicates whether one of the CSRNG HW instances has
        /// encountered an exception.  Each bit corresponds to a particular hardware
        /// instance, with bit 0 corresponding to instance HW0, bit 1 corresponding
        /// to instance HW1, and so forth. (To monitor the status of requests made
        /// to the SW instance, check the !!SW_CMD_STS register). Writing a zero to this register
        /// resets the status bits.
        #[inline(always)]
        pub fn hw_exc_sts(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
    }
    impl From<u32> for HwExcStsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwExcStsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HwExcStsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableReadVal(u32);
    impl InterruptEnableReadVal {
        /// Enable interrupt when cs_cmd_req_done is set.
        #[inline(always)]
        pub fn cs_cmd_req_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable interrupt when cs_entropy_req is set.
        #[inline(always)]
        pub fn cs_entropy_req(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable interrupt when cs_hw_inst_exc is set.
        #[inline(always)]
        pub fn cs_hw_inst_exc(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable interrupt when cs_fatal_err is set.
        #[inline(always)]
        pub fn cs_fatal_err(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableWriteVal {
            InterruptEnableWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableWriteVal(u32);
    impl InterruptEnableWriteVal {
        /// Enable interrupt when cs_cmd_req_done is set.
        #[inline(always)]
        pub fn cs_cmd_req_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable interrupt when cs_entropy_req is set.
        #[inline(always)]
        pub fn cs_entropy_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable interrupt when cs_hw_inst_exc is set.
        #[inline(always)]
        pub fn cs_hw_inst_exc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable interrupt when cs_fatal_err is set.
        #[inline(always)]
        pub fn cs_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateReadVal(u32);
    impl InterruptStateReadVal {
        /// Asserted when a command request is completed.
        #[inline(always)]
        pub fn cs_cmd_req_done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Asserted when a request for entropy has been made.
        #[inline(always)]
        pub fn cs_entropy_req(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Asserted when a hardware-attached CSRNG instance encounters a command exception
        #[inline(always)]
        pub fn cs_hw_inst_exc(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Asserted when a FIFO error or a fatal alert occurs. Check the !!ERR_CODE register to get more information.
        #[inline(always)]
        pub fn cs_fatal_err(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStateWriteVal {
            InterruptStateWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateWriteVal(u32);
    impl InterruptStateWriteVal {
        /// Asserted when a command request is completed.
        #[inline(always)]
        pub fn cs_cmd_req_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Asserted when a request for entropy has been made.
        #[inline(always)]
        pub fn cs_entropy_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Asserted when a hardware-attached CSRNG instance encounters a command exception
        #[inline(always)]
        pub fn cs_hw_inst_exc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Asserted when a FIFO error or a fatal alert occurs. Check the !!ERR_CODE register to get more information.
        #[inline(always)]
        pub fn cs_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptStateWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptTestWriteVal(u32);
    impl InterruptTestWriteVal {
        /// Write 1 to force cs_cmd_req_done to 1.
        #[inline(always)]
        pub fn cs_cmd_req_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to force cs_entropy_req to 1.
        #[inline(always)]
        pub fn cs_entropy_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Write 1 to force cs_hw_inst_exc to 1.
        #[inline(always)]
        pub fn cs_hw_inst_exc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Write 1 to force cs_fatal_err to 1.
        #[inline(always)]
        pub fn cs_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntStateNumReadVal(u32);
    impl IntStateNumReadVal {
        /// Setting this field will set the number for which internal state can be
        /// selected for a read access. Up to 16 internal state values can be chosen
        /// from this register. The actual number of valid internal state fields
        /// is set by parameter NHwApps plus 1 software app. For those selections that point
        /// to reserved locations (greater than NHwApps plus 1), the returned value
        /// will be zero. Writing this register will also reset the internal read
        /// pointer for the !!INT_STATE_VAL register.
        /// Note: This register should be read back after being written to ensure
        /// that the !!INT_STATE_VAL read back is accurate.
        #[inline(always)]
        pub fn int_state_num(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntStateNumWriteVal {
            IntStateNumWriteVal(self.0)
        }
    }
    impl From<u32> for IntStateNumReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntStateNumReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntStateNumReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntStateNumWriteVal(u32);
    impl IntStateNumWriteVal {
        /// Setting this field will set the number for which internal state can be
        /// selected for a read access. Up to 16 internal state values can be chosen
        /// from this register. The actual number of valid internal state fields
        /// is set by parameter NHwApps plus 1 software app. For those selections that point
        /// to reserved locations (greater than NHwApps plus 1), the returned value
        /// will be zero. Writing this register will also reset the internal read
        /// pointer for the !!INT_STATE_VAL register.
        /// Note: This register should be read back after being written to ensure
        /// that the !!INT_STATE_VAL read back is accurate.
        #[inline(always)]
        pub fn int_state_num(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for IntStateNumWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntStateNumWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntStateNumWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MainSmStateReadVal(u32);
    impl MainSmStateReadVal {
        /// This is the state of the CSRNG main state machine.
        /// See the RTL file `csrng_main_sm` for the meaning of the values.
        #[inline(always)]
        pub fn main_sm_state(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for MainSmStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MainSmStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: MainSmStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecovAlertStsReadVal(u32);
    impl RecovAlertStsReadVal {
        /// This bit is set when the ENABLE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn enable_field_alert(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit is set when the SW_APP_ENABLE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn sw_app_enable_field_alert(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// This bit is set when the READ_INT_STATE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn read_int_state_field_alert(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// This bit is set when the FLAG0 field in the Application Command is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn acmd_flag0_field_alert(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// This bit is set when the software application port genbits bus value is equal
        /// to the prior valid value on the bus, indicating a possible attack.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn cs_bus_cmp_alert(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// This bit is set when an unsupported/illegal CSRNG command is being processed.
        /// The main FSM will hang unless the module enable field is set to the disabled state.
        #[inline(always)]
        pub fn cs_main_sm_alert(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RecovAlertStsWriteVal {
            RecovAlertStsWriteVal(self.0)
        }
    }
    impl From<u32> for RecovAlertStsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecovAlertStsReadVal> for u32 {
        #[inline(always)]
        fn from(val: RecovAlertStsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecovAlertStsWriteVal(u32);
    impl RecovAlertStsWriteVal {
        /// This bit is set when the ENABLE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn enable_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// This bit is set when the SW_APP_ENABLE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn sw_app_enable_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// This bit is set when the READ_INT_STATE field in the !!CTRL register is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn read_int_state_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// This bit is set when the FLAG0 field in the Application Command is set to
        /// a value other than kMultiBitBool4True or kMultiBitBool4False.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn acmd_flag0_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// This bit is set when the software application port genbits bus value is equal
        /// to the prior valid value on the bus, indicating a possible attack.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn cs_bus_cmp_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// This bit is set when an unsupported/illegal CSRNG command is being processed.
        /// The main FSM will hang unless the module enable field is set to the disabled state.
        #[inline(always)]
        pub fn cs_main_sm_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
    }
    impl From<u32> for RecovAlertStsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecovAlertStsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RecovAlertStsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RegwenReadVal(u32);
    impl RegwenReadVal {
        /// When true, all writeable registers can be modified.
        /// When false, they become read-only.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RegwenWriteVal {
            RegwenWriteVal(self.0)
        }
    }
    impl From<u32> for RegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: RegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RegwenWriteVal(u32);
    impl RegwenWriteVal {
        /// When true, all writeable registers can be modified.
        /// When false, they become read-only.
        #[inline(always)]
        pub fn regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for RegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SwCmdStsReadVal(u32);
    impl SwCmdStsReadVal {
        /// This bit indicates when the command interface is ready to accept commands.
        #[inline(always)]
        pub fn cmd_rdy(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This one bit field is the status code returned with the application command ack.
        /// It is updated each time a command ack is asserted on the internal application
        /// interface for software use.
        /// 0b0: Request completed successfully
        /// 0b1: Request completed with an error
        #[inline(always)]
        pub fn cmd_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for SwCmdStsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SwCmdStsReadVal> for u32 {
        #[inline(always)]
        fn from(val: SwCmdStsReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type InterruptState = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::InterruptStateReadVal,
        crate::csrng::regs::InterruptStateWriteVal,
    >;
    pub type InterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::InterruptEnableReadVal,
        crate::csrng::regs::InterruptEnableWriteVal,
    >;
    pub type InterruptTest = ureg::WriteOnlyReg32<0, crate::csrng::regs::InterruptTestWriteVal>;
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::csrng::regs::AlertTestWriteVal>;
    pub type Regwen = ureg::ReadWriteReg32<
        1,
        crate::csrng::regs::RegwenReadVal,
        crate::csrng::regs::RegwenWriteVal,
    >;
    pub type Ctrl = ureg::ReadWriteReg32<
        0x999,
        crate::csrng::regs::CtrlReadVal,
        crate::csrng::regs::CtrlWriteVal,
    >;
    pub type CmdReq = ureg::WriteOnlyReg32<0, crate::csrng::regs::CmdReqWriteVal>;
    pub type SwCmdSts = ureg::ReadOnlyReg32<crate::csrng::regs::SwCmdStsReadVal>;
    pub type GenbitsVld = ureg::ReadOnlyReg32<crate::csrng::regs::GenbitsVldReadVal>;
    pub type Genbits = ureg::ReadOnlyReg32<u32>;
    pub type IntStateNum = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::IntStateNumReadVal,
        crate::csrng::regs::IntStateNumWriteVal,
    >;
    pub type IntStateVal = ureg::ReadOnlyReg32<u32>;
    pub type HwExcSts = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::HwExcStsReadVal,
        crate::csrng::regs::HwExcStsWriteVal,
    >;
    pub type RecovAlertSts = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::RecovAlertStsReadVal,
        crate::csrng::regs::RecovAlertStsWriteVal,
    >;
    pub type ErrCode = ureg::ReadOnlyReg32<crate::csrng::regs::ErrCodeReadVal>;
    pub type ErrCodeTest = ureg::ReadWriteReg32<
        0,
        crate::csrng::regs::ErrCodeTestReadVal,
        crate::csrng::regs::ErrCodeTestWriteVal,
    >;
    pub type MainSmState = ureg::ReadOnlyReg32<crate::csrng::regs::MainSmStateReadVal>;
}

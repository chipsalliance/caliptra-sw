// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 19dc3e00572423ca5ed03633f38f70a4592cb56c
//
#![allow(clippy::doc_lazy_continuation)]
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct McuMbox0Csr {
    _priv: (),
}
impl McuMbox0Csr {
    pub const PTR: *mut u32 = 0x400000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Mailbox SRAM storage. The maximum size is 2MB, but is configurable by the integration team. Only writable once a lock is obtained. Cleared from 0x0 to max DLEN after lock is released.
    /// [br] Root user, user with lock on mailbox, and target user have RW access.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox_sram(
        &self,
    ) -> ureg::Array<524288, ureg::RegRef<crate::mcu_mbox0::meta::MboxSram, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Mailbox lock register for mailbox access, reading 0 will set the lock. On reset release lock is set to root_user (MCU) to allow SRAM clearing
    ///
    /// Read value: [`mcu_mbox0::regs::MboxLockReadVal`]; Write value: [`mcu_mbox0::regs::MboxLockWriteVal`]
    #[inline(always)]
    pub fn mbox_lock(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200000 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Stores the AXI USER that locked the mailbox. Cleared when lock is cleared.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox_user(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200004 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Stores the AXI USER for target user access. Only valid when mbox_target_user_valid is set.  Only controllable by the root user. Only accessible when mailbox is locked. Cleared when lock is cleared.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox_target_user(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxTargetUser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200008 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Enables access for the mbox_target_user. Only controllable by the root user. Only accessible when mailbox is locked. Cleared when lock is cleared.
    ///
    /// Read value: [`mcu_mbox0::regs::MboxTargetUserValidReadVal`]; Write value: [`mcu_mbox0::regs::MboxTargetUserValidWriteVal`]
    #[inline(always)]
    pub fn mbox_target_user_valid(
        &self,
    ) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxTargetUserValid, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x20000c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Command requested for data in mailbox. Cleared when lock is cleared.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox_cmd(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxCmd, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200010 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Data length for mailbox access in bytes. Cleared when lock is cleared
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox_dlen(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxDlen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200014 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Mailbox execute register indicates to receiver that the sender is done.
    ///
    /// Read value: [`mcu_mbox0::regs::MboxExecuteReadVal`]; Write value: [`mcu_mbox0::regs::MboxExecuteWriteVal`]
    #[inline(always)]
    pub fn mbox_execute(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxExecute, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200018 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Status of the mailbox command
    ///
    /// Read value: [`mcu_mbox0::regs::MboxTargetStatusReadVal`]; Write value: [`mcu_mbox0::regs::MboxTargetStatusWriteVal`]
    #[inline(always)]
    pub fn mbox_target_status(
        &self,
    ) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxTargetStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x20001c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Status of the mailbox command
    ///
    /// Read value: [`mcu_mbox0::regs::MboxCmdStatusReadVal`]; Write value: [`mcu_mbox0::regs::MboxCmdStatusWriteVal`]
    #[inline(always)]
    pub fn mbox_cmd_status(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxCmdStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200020 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// HW status of the mailbox
    ///
    /// Read value: [`mcu_mbox0::regs::MboxHwStatusReadVal`]; Write value: [`mcu_mbox0::regs::MboxHwStatusWriteVal`]
    #[inline(always)]
    pub fn mbox_hw_status(&self) -> ureg::RegRef<crate::mcu_mbox0::meta::MboxHwStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr
                    .wrapping_add(0x200024 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct MboxCmdStatusReadVal(u32);
    impl MboxCmdStatusReadVal {
        /// Indicates the status of mailbox command.
        #[inline(always)]
        pub fn status(&self) -> super::enums::MboxStatusE {
            super::enums::MboxStatusE::try_from((self.0 >> 0) & 0xf).unwrap()
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MboxCmdStatusWriteVal {
            MboxCmdStatusWriteVal(self.0)
        }
    }
    impl From<u32> for MboxCmdStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxCmdStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxCmdStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxCmdStatusWriteVal(u32);
    impl MboxCmdStatusWriteVal {
        /// Indicates the status of mailbox command.
        #[inline(always)]
        pub fn status(
            self,
            f: impl FnOnce(super::enums::selector::MboxStatusESelector) -> super::enums::MboxStatusE,
        ) -> Self {
            Self(
                (self.0 & !(0xf << 0))
                    | (u32::from(f(super::enums::selector::MboxStatusESelector())) << 0),
            )
        }
    }
    impl From<u32> for MboxCmdStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxCmdStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MboxCmdStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxExecuteReadVal(u32);
    impl MboxExecuteReadVal {
        #[inline(always)]
        pub fn execute(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MboxExecuteWriteVal {
            MboxExecuteWriteVal(self.0)
        }
    }
    impl From<u32> for MboxExecuteReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxExecuteReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxExecuteReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxExecuteWriteVal(u32);
    impl MboxExecuteWriteVal {
        #[inline(always)]
        pub fn execute(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for MboxExecuteWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxExecuteWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MboxExecuteWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxHwStatusReadVal(u32);
    impl MboxHwStatusReadVal {
        /// Indicates a correctable ECC single-bit error was
        /// detected and corrected while reading dataout.
        /// Auto-clears when mbox_execute field is cleared.
        #[inline(always)]
        pub fn ecc_single_error(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Indicates an uncorrectable ECC double-bit error
        /// was detected while reading dataout.
        /// Firmware developers are advised to set the command
        /// status to CMD_FAILURE in response.
        /// Auto-clears when mbox_execute field is cleared.
        #[inline(always)]
        pub fn ecc_double_error(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for MboxHwStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxHwStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxHwStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxLockReadVal(u32);
    impl MboxLockReadVal {
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for MboxLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxTargetStatusReadVal(u32);
    impl MboxTargetStatusReadVal {
        /// Indicates the status of mailbox for the target user. Valid when done is set.
        #[inline(always)]
        pub fn status(&self) -> super::enums::MboxStatusE {
            super::enums::MboxStatusE::try_from((self.0 >> 0) & 0xf).unwrap()
        }
        /// Indicates target user is done and target status is valid.
        #[inline(always)]
        pub fn done(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MboxTargetStatusWriteVal {
            MboxTargetStatusWriteVal(self.0)
        }
    }
    impl From<u32> for MboxTargetStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxTargetStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxTargetStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxTargetStatusWriteVal(u32);
    impl MboxTargetStatusWriteVal {
        /// Indicates the status of mailbox for the target user. Valid when done is set.
        #[inline(always)]
        pub fn status(
            self,
            f: impl FnOnce(super::enums::selector::MboxStatusESelector) -> super::enums::MboxStatusE,
        ) -> Self {
            Self(
                (self.0 & !(0xf << 0))
                    | (u32::from(f(super::enums::selector::MboxStatusESelector())) << 0),
            )
        }
        /// Indicates target user is done and target status is valid.
        #[inline(always)]
        pub fn done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for MboxTargetStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxTargetStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MboxTargetStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxTargetUserValidReadVal(u32);
    impl MboxTargetUserValidReadVal {
        #[inline(always)]
        pub fn valid(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MboxTargetUserValidWriteVal {
            MboxTargetUserValidWriteVal(self.0)
        }
    }
    impl From<u32> for MboxTargetUserValidReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxTargetUserValidReadVal> for u32 {
        #[inline(always)]
        fn from(val: MboxTargetUserValidReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MboxTargetUserValidWriteVal(u32);
    impl MboxTargetUserValidWriteVal {
        #[inline(always)]
        pub fn valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for MboxTargetUserValidWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MboxTargetUserValidWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MboxTargetUserValidWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum MboxStatusE {
        CmdBusy = 0,
        DataReady = 1,
        CmdComplete = 2,
        CmdFailure = 3,
        Reserved4 = 4,
        Reserved5 = 5,
        Reserved6 = 6,
        Reserved7 = 7,
        Reserved8 = 8,
        Reserved9 = 9,
        Reserved10 = 10,
        Reserved11 = 11,
        Reserved12 = 12,
        Reserved13 = 13,
        Reserved14 = 14,
        Reserved15 = 15,
    }
    impl MboxStatusE {
        #[inline(always)]
        pub fn cmd_busy(&self) -> bool {
            *self == Self::CmdBusy
        }
        #[inline(always)]
        pub fn data_ready(&self) -> bool {
            *self == Self::DataReady
        }
        #[inline(always)]
        pub fn cmd_complete(&self) -> bool {
            *self == Self::CmdComplete
        }
        #[inline(always)]
        pub fn cmd_failure(&self) -> bool {
            *self == Self::CmdFailure
        }
    }
    impl TryFrom<u32> for MboxStatusE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<MboxStatusE, ()> {
            if val < 0x10 {
                Ok(unsafe { core::mem::transmute::<u32, MboxStatusE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<MboxStatusE> for u32 {
        fn from(val: MboxStatusE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct MboxStatusESelector();
        impl MboxStatusESelector {
            #[inline(always)]
            pub fn cmd_busy(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdBusy
            }
            #[inline(always)]
            pub fn data_ready(&self) -> super::MboxStatusE {
                super::MboxStatusE::DataReady
            }
            #[inline(always)]
            pub fn cmd_complete(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdComplete
            }
            #[inline(always)]
            pub fn cmd_failure(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdFailure
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type MboxSram = ureg::ReadWriteReg32<0, u32, u32>;
    pub type MboxLock = ureg::ReadOnlyReg32<crate::mcu_mbox0::regs::MboxLockReadVal>;
    pub type MboxUser = ureg::ReadOnlyReg32<u32>;
    pub type MboxTargetUser = ureg::ReadWriteReg32<0, u32, u32>;
    pub type MboxTargetUserValid = ureg::ReadWriteReg32<
        0,
        crate::mcu_mbox0::regs::MboxTargetUserValidReadVal,
        crate::mcu_mbox0::regs::MboxTargetUserValidWriteVal,
    >;
    pub type MboxCmd = ureg::ReadWriteReg32<0, u32, u32>;
    pub type MboxDlen = ureg::ReadWriteReg32<0, u32, u32>;
    pub type MboxExecute = ureg::ReadWriteReg32<
        0,
        crate::mcu_mbox0::regs::MboxExecuteReadVal,
        crate::mcu_mbox0::regs::MboxExecuteWriteVal,
    >;
    pub type MboxTargetStatus = ureg::ReadWriteReg32<
        0,
        crate::mcu_mbox0::regs::MboxTargetStatusReadVal,
        crate::mcu_mbox0::regs::MboxTargetStatusWriteVal,
    >;
    pub type MboxCmdStatus = ureg::ReadWriteReg32<
        0,
        crate::mcu_mbox0::regs::MboxCmdStatusReadVal,
        crate::mcu_mbox0::regs::MboxCmdStatusWriteVal,
    >;
    pub type MboxHwStatus = ureg::ReadOnlyReg32<crate::mcu_mbox0::regs::MboxHwStatusReadVal>;
}

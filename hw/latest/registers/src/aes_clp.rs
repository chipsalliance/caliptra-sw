// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at f6d35180615eb1908ba719e3296e82a610ebd31e
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct AesClpReg {
    _priv: (),
}
impl AesClpReg {
    pub const PTR: *mut u32 = 0x10011800 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Two 32-bit read-only registers representing of the name
    /// of AES component.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn aes_name(&self) -> ureg::Array<2, ureg::RegRef<crate::aes_clp::meta::AesName, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Two 32-bit read-only registers representing of the version
    /// of AES component.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn aes_version(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::aes_clp::meta::AesVersion, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Nine 32-bit write-only registers for providing a new 288-bit state seed for the
    /// Trivium stream cipher primitive driving the EDN interface of AES.
    ///
    /// After reset and whenever firmware wants to reseed the Trivium stream cipher
    /// primitive, it has to write every register once. The order in which the registers
    /// are written doesn't matter. Upon writing the last register, the provided 288-bit
    /// value is loaded into the Trivium primitive.
    ///
    /// It's fine to write the registers while AES is busy and even while it's performing a
    /// a reseed operation of the internal PRNGs via the EDN interface.
    ///
    /// Note: Upon reset, the state of the Trivium primitive is initialized to a netlist
    /// constant. The primitive thus always generates the same output after reset. It is the
    /// responsibility of firmware to provide a new state seed after reset.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn entropy_if_seed(
        &self,
    ) -> ureg::Array<9, ureg::RegRef<crate::aes_clp::meta::EntropyIfSeed, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// AES Wrapper Controls
    ///
    /// Read value: [`aes_clp::regs::Ctrl0ReadVal`]; Write value: [`aes_clp::regs::Ctrl0WriteVal`]
    #[inline(always)]
    pub fn ctrl0(&self) -> ureg::RegRef<crate::aes_clp::meta::Ctrl0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x134 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Controls the Key Vault read access for this engine
    ///
    /// Read value: [`regs::KvReadCtrlRegReadVal`]; Write value: [`regs::KvReadCtrlRegWriteVal`]
    #[inline(always)]
    pub fn aes_kv_rd_key_ctrl(&self) -> ureg::RegRef<crate::aes_clp::meta::AesKvRdKeyCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the Key Vault flow status for this engine
    ///
    /// Read value: [`regs::KvStatusRegReadVal`]; Write value: [`regs::KvStatusRegWriteVal`]
    #[inline(always)]
    pub fn aes_kv_rd_key_status(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::AesKvRdKeyStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Controls the Key Vault write access for this engine
    ///
    /// Read value: [`regs::KvWriteCtrlRegReadVal`]; Write value: [`regs::KvWriteCtrlRegWriteVal`]
    #[inline(always)]
    pub fn aes_kv_wr_ctrl(&self) -> ureg::RegRef<crate::aes_clp::meta::AesKvWrCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x208 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the Key Vault flow status for this engine
    ///
    /// Read value: [`regs::KvStatusRegReadVal`]; Write value: [`regs::KvStatusRegWriteVal`]
    #[inline(always)]
    pub fn aes_kv_wr_status(&self) -> ureg::RegRef<crate::aes_clp::meta::AesKvWrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn intr_block_rf(&self) -> IntrBlockRfBlock<&TMmio> {
        IntrBlockRfBlock {
            ptr: unsafe { self.ptr.add(0x400 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct IntrBlockRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> IntrBlockRfBlock<TMmio> {
    /// Dedicated register with one bit for each event type that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrEnTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrEnTWriteVal`]
    #[inline(always)]
    pub fn global_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfGlobalIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::ErrorIntrEnTReadVal`]; Write value: [`sha512_acc::regs::ErrorIntrEnTWriteVal`]
    #[inline(always)]
    pub fn error_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfErrorIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::NotifIntrEnTReadVal`]; Write value: [`sha512_acc::regs::NotifIntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn error_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfErrorGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`sha512_acc::regs::ErrorIntrTReadVal`]; Write value: [`sha512_acc::regs::ErrorIntrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfErrorInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`sha512_acc::regs::NotifIntrTReadVal`]; Write value: [`sha512_acc::regs::NotifIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`sha512_acc::regs::ErrorIntrTrigTReadVal`]; Write value: [`sha512_acc::regs::ErrorIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfErrorIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`sha512_acc::regs::NotifIntrTrigTReadVal`]; Write value: [`sha512_acc::regs::NotifIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error0_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError0IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error1_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError1IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error2_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError2IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error3_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError3IntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_cmd_done_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifCmdDoneIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error0_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError0IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error1_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError1IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error2_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError2IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x208 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error3_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfError3IntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_cmd_done_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::aes_clp::meta::IntrBlockRfNotifCmdDoneIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x210 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct IntrBlockRf {
    _priv: (),
}
impl IntrBlockRf {
    pub const PTR: *mut u32 = 0x400 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct Ctrl0ReadVal(u32);
    impl Ctrl0ReadVal {
        /// Default behavior assumes that data written into and read out of AES is little endian.
        /// [br]When set to 0, data written to AES and data read out of AES is left as is and is in little endian format.
        /// [br]When set to 1, data written to AES DATAIN and data read from DATAOUT is big endian format. Since the AES core always assumes little endian format, this control swizzles write data to DATAIN from big endian to little endian format. When data is read from DATAOUT it swizzle the read data from little endian to big endian format. Allowing for the user to stream big endian data into and out of the AES.
        #[inline(always)]
        pub fn endian_swap(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> Ctrl0WriteVal {
            Ctrl0WriteVal(self.0)
        }
    }
    impl From<u32> for Ctrl0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Ctrl0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: Ctrl0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct Ctrl0WriteVal(u32);
    impl Ctrl0WriteVal {
        /// Default behavior assumes that data written into and read out of AES is little endian.
        /// [br]When set to 0, data written to AES and data read out of AES is left as is and is in little endian format.
        /// [br]When set to 1, data written to AES DATAIN and data read from DATAOUT is big endian format. Since the AES core always assumes little endian format, this control swizzles write data to DATAIN from big endian to little endian format. When data is read from DATAOUT it swizzle the read data from little endian to big endian format. Allowing for the user to stream big endian data into and out of the AES.
        #[inline(always)]
        pub fn endian_swap(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for Ctrl0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<Ctrl0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: Ctrl0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTReadVal(u32);
    impl ErrorIntrEnTReadVal {
        /// Enable bit for Event 0
        #[inline(always)]
        pub fn error0_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for Event 1
        #[inline(always)]
        pub fn error1_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for Event 2
        #[inline(always)]
        pub fn error2_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for Event 3
        #[inline(always)]
        pub fn error3_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrEnTWriteVal {
            ErrorIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTWriteVal(u32);
    impl ErrorIntrEnTWriteVal {
        /// Enable bit for Event 0
        #[inline(always)]
        pub fn error0_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for Event 1
        #[inline(always)]
        pub fn error1_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for Event 2
        #[inline(always)]
        pub fn error2_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for Event 3
        #[inline(always)]
        pub fn error3_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for ErrorIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTReadVal(u32);
    impl ErrorIntrTReadVal {
        /// Interrupt Event 0 status bit
        #[inline(always)]
        pub fn error0_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Interrupt Event 1 status bit
        #[inline(always)]
        pub fn error1_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Interrupt Event 2 status bit
        #[inline(always)]
        pub fn error2_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Interrupt Event 3 status bit
        #[inline(always)]
        pub fn error3_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTWriteVal {
            ErrorIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTWriteVal(u32);
    impl ErrorIntrTWriteVal {
        /// Interrupt Event 0 status bit
        #[inline(always)]
        pub fn error0_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Interrupt Event 1 status bit
        #[inline(always)]
        pub fn error1_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Interrupt Event 2 status bit
        #[inline(always)]
        pub fn error2_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Interrupt Event 3 status bit
        #[inline(always)]
        pub fn error3_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for ErrorIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTReadVal(u32);
    impl ErrorIntrTrigTReadVal {
        /// Interrupt Trigger 0 bit
        #[inline(always)]
        pub fn error0_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Interrupt Trigger 1 bit
        #[inline(always)]
        pub fn error1_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Interrupt Trigger 2 bit
        #[inline(always)]
        pub fn error2_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Interrupt Trigger 3 bit
        #[inline(always)]
        pub fn error3_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTrigTWriteVal {
            ErrorIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTWriteVal(u32);
    impl ErrorIntrTrigTWriteVal {
        /// Interrupt Trigger 0 bit
        #[inline(always)]
        pub fn error0_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Interrupt Trigger 1 bit
        #[inline(always)]
        pub fn error1_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Interrupt Trigger 2 bit
        #[inline(always)]
        pub fn error2_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Interrupt Trigger 3 bit
        #[inline(always)]
        pub fn error3_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for ErrorIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GlobalIntrEnTReadVal(u32);
    impl GlobalIntrEnTReadVal {
        /// Global enable bit for all events of type 'Error'
        #[inline(always)]
        pub fn error_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Global enable bit for all events of type 'Notification'
        #[inline(always)]
        pub fn notif_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> GlobalIntrEnTWriteVal {
            GlobalIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for GlobalIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GlobalIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: GlobalIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GlobalIntrEnTWriteVal(u32);
    impl GlobalIntrEnTWriteVal {
        /// Global enable bit for all events of type 'Error'
        #[inline(always)]
        pub fn error_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Global enable bit for all events of type 'Notification'
        #[inline(always)]
        pub fn notif_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for GlobalIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GlobalIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: GlobalIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct GlobalIntrTReadVal(u32);
    impl GlobalIntrTReadVal {
        /// Interrupt Event Aggregation status bit
        #[inline(always)]
        pub fn agg_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for GlobalIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<GlobalIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: GlobalIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrCountIncrTReadVal(u32);
    impl IntrCountIncrTReadVal {
        /// Pulse mirrors interrupt event occurrence
        #[inline(always)]
        pub fn pulse(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for IntrCountIncrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrCountIncrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrCountIncrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTReadVal(u32);
    impl NotifIntrEnTReadVal {
        /// Enable bit for Command Done Interrupt
        #[inline(always)]
        pub fn notif_cmd_done_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrEnTWriteVal {
            NotifIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTWriteVal(u32);
    impl NotifIntrEnTWriteVal {
        /// Enable bit for Command Done Interrupt
        #[inline(always)]
        pub fn notif_cmd_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTReadVal(u32);
    impl NotifIntrTReadVal {
        /// Command Done Interrupt status bit
        #[inline(always)]
        pub fn notif_cmd_done_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTWriteVal {
            NotifIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTWriteVal(u32);
    impl NotifIntrTWriteVal {
        /// Command Done Interrupt status bit
        #[inline(always)]
        pub fn notif_cmd_done_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTReadVal(u32);
    impl NotifIntrTrigTReadVal {
        /// Interrupt Trigger 0 bit
        #[inline(always)]
        pub fn notif_cmd_done_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTrigTWriteVal {
            NotifIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTWriteVal(u32);
    impl NotifIntrTrigTWriteVal {
        /// Interrupt Trigger 0 bit
        #[inline(always)]
        pub fn notif_cmd_done_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for NotifIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum KvErrorE {
        Success = 0,
        KvReadFail = 1,
        KvWriteFail = 2,
        Reserved3 = 3,
        Reserved4 = 4,
        Reserved5 = 5,
        Reserved6 = 6,
        Reserved7 = 7,
        Reserved8 = 8,
        Reserved9 = 9,
        Reserved10 = 10,
        Reserved11 = 11,
        Reserved12 = 12,
        Reserved13 = 13,
        Reserved14 = 14,
        Reserved15 = 15,
        Reserved16 = 16,
        Reserved17 = 17,
        Reserved18 = 18,
        Reserved19 = 19,
        Reserved20 = 20,
        Reserved21 = 21,
        Reserved22 = 22,
        Reserved23 = 23,
        Reserved24 = 24,
        Reserved25 = 25,
        Reserved26 = 26,
        Reserved27 = 27,
        Reserved28 = 28,
        Reserved29 = 29,
        Reserved30 = 30,
        Reserved31 = 31,
        Reserved32 = 32,
        Reserved33 = 33,
        Reserved34 = 34,
        Reserved35 = 35,
        Reserved36 = 36,
        Reserved37 = 37,
        Reserved38 = 38,
        Reserved39 = 39,
        Reserved40 = 40,
        Reserved41 = 41,
        Reserved42 = 42,
        Reserved43 = 43,
        Reserved44 = 44,
        Reserved45 = 45,
        Reserved46 = 46,
        Reserved47 = 47,
        Reserved48 = 48,
        Reserved49 = 49,
        Reserved50 = 50,
        Reserved51 = 51,
        Reserved52 = 52,
        Reserved53 = 53,
        Reserved54 = 54,
        Reserved55 = 55,
        Reserved56 = 56,
        Reserved57 = 57,
        Reserved58 = 58,
        Reserved59 = 59,
        Reserved60 = 60,
        Reserved61 = 61,
        Reserved62 = 62,
        Reserved63 = 63,
        Reserved64 = 64,
        Reserved65 = 65,
        Reserved66 = 66,
        Reserved67 = 67,
        Reserved68 = 68,
        Reserved69 = 69,
        Reserved70 = 70,
        Reserved71 = 71,
        Reserved72 = 72,
        Reserved73 = 73,
        Reserved74 = 74,
        Reserved75 = 75,
        Reserved76 = 76,
        Reserved77 = 77,
        Reserved78 = 78,
        Reserved79 = 79,
        Reserved80 = 80,
        Reserved81 = 81,
        Reserved82 = 82,
        Reserved83 = 83,
        Reserved84 = 84,
        Reserved85 = 85,
        Reserved86 = 86,
        Reserved87 = 87,
        Reserved88 = 88,
        Reserved89 = 89,
        Reserved90 = 90,
        Reserved91 = 91,
        Reserved92 = 92,
        Reserved93 = 93,
        Reserved94 = 94,
        Reserved95 = 95,
        Reserved96 = 96,
        Reserved97 = 97,
        Reserved98 = 98,
        Reserved99 = 99,
        Reserved100 = 100,
        Reserved101 = 101,
        Reserved102 = 102,
        Reserved103 = 103,
        Reserved104 = 104,
        Reserved105 = 105,
        Reserved106 = 106,
        Reserved107 = 107,
        Reserved108 = 108,
        Reserved109 = 109,
        Reserved110 = 110,
        Reserved111 = 111,
        Reserved112 = 112,
        Reserved113 = 113,
        Reserved114 = 114,
        Reserved115 = 115,
        Reserved116 = 116,
        Reserved117 = 117,
        Reserved118 = 118,
        Reserved119 = 119,
        Reserved120 = 120,
        Reserved121 = 121,
        Reserved122 = 122,
        Reserved123 = 123,
        Reserved124 = 124,
        Reserved125 = 125,
        Reserved126 = 126,
        Reserved127 = 127,
        Reserved128 = 128,
        Reserved129 = 129,
        Reserved130 = 130,
        Reserved131 = 131,
        Reserved132 = 132,
        Reserved133 = 133,
        Reserved134 = 134,
        Reserved135 = 135,
        Reserved136 = 136,
        Reserved137 = 137,
        Reserved138 = 138,
        Reserved139 = 139,
        Reserved140 = 140,
        Reserved141 = 141,
        Reserved142 = 142,
        Reserved143 = 143,
        Reserved144 = 144,
        Reserved145 = 145,
        Reserved146 = 146,
        Reserved147 = 147,
        Reserved148 = 148,
        Reserved149 = 149,
        Reserved150 = 150,
        Reserved151 = 151,
        Reserved152 = 152,
        Reserved153 = 153,
        Reserved154 = 154,
        Reserved155 = 155,
        Reserved156 = 156,
        Reserved157 = 157,
        Reserved158 = 158,
        Reserved159 = 159,
        Reserved160 = 160,
        Reserved161 = 161,
        Reserved162 = 162,
        Reserved163 = 163,
        Reserved164 = 164,
        Reserved165 = 165,
        Reserved166 = 166,
        Reserved167 = 167,
        Reserved168 = 168,
        Reserved169 = 169,
        Reserved170 = 170,
        Reserved171 = 171,
        Reserved172 = 172,
        Reserved173 = 173,
        Reserved174 = 174,
        Reserved175 = 175,
        Reserved176 = 176,
        Reserved177 = 177,
        Reserved178 = 178,
        Reserved179 = 179,
        Reserved180 = 180,
        Reserved181 = 181,
        Reserved182 = 182,
        Reserved183 = 183,
        Reserved184 = 184,
        Reserved185 = 185,
        Reserved186 = 186,
        Reserved187 = 187,
        Reserved188 = 188,
        Reserved189 = 189,
        Reserved190 = 190,
        Reserved191 = 191,
        Reserved192 = 192,
        Reserved193 = 193,
        Reserved194 = 194,
        Reserved195 = 195,
        Reserved196 = 196,
        Reserved197 = 197,
        Reserved198 = 198,
        Reserved199 = 199,
        Reserved200 = 200,
        Reserved201 = 201,
        Reserved202 = 202,
        Reserved203 = 203,
        Reserved204 = 204,
        Reserved205 = 205,
        Reserved206 = 206,
        Reserved207 = 207,
        Reserved208 = 208,
        Reserved209 = 209,
        Reserved210 = 210,
        Reserved211 = 211,
        Reserved212 = 212,
        Reserved213 = 213,
        Reserved214 = 214,
        Reserved215 = 215,
        Reserved216 = 216,
        Reserved217 = 217,
        Reserved218 = 218,
        Reserved219 = 219,
        Reserved220 = 220,
        Reserved221 = 221,
        Reserved222 = 222,
        Reserved223 = 223,
        Reserved224 = 224,
        Reserved225 = 225,
        Reserved226 = 226,
        Reserved227 = 227,
        Reserved228 = 228,
        Reserved229 = 229,
        Reserved230 = 230,
        Reserved231 = 231,
        Reserved232 = 232,
        Reserved233 = 233,
        Reserved234 = 234,
        Reserved235 = 235,
        Reserved236 = 236,
        Reserved237 = 237,
        Reserved238 = 238,
        Reserved239 = 239,
        Reserved240 = 240,
        Reserved241 = 241,
        Reserved242 = 242,
        Reserved243 = 243,
        Reserved244 = 244,
        Reserved245 = 245,
        Reserved246 = 246,
        Reserved247 = 247,
        Reserved248 = 248,
        Reserved249 = 249,
        Reserved250 = 250,
        Reserved251 = 251,
        Reserved252 = 252,
        Reserved253 = 253,
        Reserved254 = 254,
        Reserved255 = 255,
    }
    impl KvErrorE {
        #[inline(always)]
        pub fn success(&self) -> bool {
            *self == Self::Success
        }
        #[inline(always)]
        pub fn kv_read_fail(&self) -> bool {
            *self == Self::KvReadFail
        }
        #[inline(always)]
        pub fn kv_write_fail(&self) -> bool {
            *self == Self::KvWriteFail
        }
    }
    impl TryFrom<u32> for KvErrorE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<KvErrorE, ()> {
            if val < 0x100 {
                Ok(unsafe { core::mem::transmute::<u32, KvErrorE>(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<KvErrorE> for u32 {
        fn from(val: KvErrorE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct KvErrorESelector();
        impl KvErrorESelector {
            #[inline(always)]
            pub fn success(&self) -> super::KvErrorE {
                super::KvErrorE::Success
            }
            #[inline(always)]
            pub fn kv_read_fail(&self) -> super::KvErrorE {
                super::KvErrorE::KvReadFail
            }
            #[inline(always)]
            pub fn kv_write_fail(&self) -> super::KvErrorE {
                super::KvErrorE::KvWriteFail
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type AesName = ureg::ReadOnlyReg32<u32>;
    pub type AesVersion = ureg::ReadOnlyReg32<u32>;
    pub type EntropyIfSeed = ureg::WriteOnlyReg32<0, u32>;
    pub type Ctrl0 = ureg::ReadWriteReg32<
        0,
        crate::aes_clp::regs::Ctrl0ReadVal,
        crate::aes_clp::regs::Ctrl0WriteVal,
    >;
    pub type AesKvRdKeyCtrl = ureg::ReadWriteReg32<
        0,
        crate::regs::KvReadCtrlRegReadVal,
        crate::regs::KvReadCtrlRegWriteVal,
    >;
    pub type AesKvRdKeyStatus = ureg::ReadOnlyReg32<crate::regs::KvStatusRegReadVal>;
    pub type AesKvWrCtrl = ureg::ReadWriteReg32<
        0,
        crate::regs::KvWriteCtrlRegReadVal,
        crate::regs::KvWriteCtrlRegWriteVal,
    >;
    pub type AesKvWrStatus = ureg::ReadOnlyReg32<crate::regs::KvStatusRegReadVal>;
    pub type IntrBlockRfGlobalIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::GlobalIntrEnTReadVal,
        crate::sha512_acc::regs::GlobalIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::ErrorIntrEnTReadVal,
        crate::sha512_acc::regs::ErrorIntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::NotifIntrEnTReadVal,
        crate::sha512_acc::regs::NotifIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfNotifGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfErrorInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::ErrorIntrTReadVal,
        crate::sha512_acc::regs::ErrorIntrTWriteVal,
    >;
    pub type IntrBlockRfNotifInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::NotifIntrTReadVal,
        crate::sha512_acc::regs::NotifIntrTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::ErrorIntrTrigTReadVal,
        crate::sha512_acc::regs::ErrorIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::NotifIntrTrigTReadVal,
        crate::sha512_acc::regs::NotifIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfError0IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfError1IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfError2IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfError3IntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifCmdDoneIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfError0IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfError1IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfError2IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfError3IntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifCmdDoneIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
}

// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 5f85fb4bc95b753a2f7d042db7dc2644ca1e8c49
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3ccsr {
    _priv: (),
}
impl I3ccsr {
    pub const PTR: *mut u32 = 0x10038000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    #[inline(always)]
    pub fn i3_cbase(&self) -> I3cbaseBlock<&TMmio> {
        I3cbaseBlock {
            ptr: unsafe { self.ptr.add(0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn piocontrol(&self) -> PiocontrolBlock<&TMmio> {
        PiocontrolBlock {
            ptr: unsafe { self.ptr.add(0x80 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn i3_c_ec(&self) -> I3cEcBlock<&TMmio> {
        I3cEcBlock {
            ptr: unsafe { self.ptr.add(0x100 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn sec_fw_recovery_if(&self) -> SecfwrecoveryifBlock<&TMmio> {
        SecfwrecoveryifBlock {
            ptr: unsafe { self.ptr.add(0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn stdby_ctrl_mode(&self) -> StdbyctrlmodeBlock<&TMmio> {
        StdbyctrlmodeBlock {
            ptr: unsafe { self.ptr.add(0x6c / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn tti(&self) -> TtiBlock<&TMmio> {
        TtiBlock {
            ptr: unsafe { self.ptr.add(0xac / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn so_cmgmt_if(&self) -> SocmgmtifBlock<&TMmio> {
        SocmgmtifBlock {
            ptr: unsafe { self.ptr.add(0xec / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn ctrl_cfg(&self) -> CtrlcfgBlock<&TMmio> {
        CtrlcfgBlock {
            ptr: unsafe { self.ptr.add(0x148 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct I3cbaseBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> I3cbaseBlock<TMmio> {
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hci_version(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHciVersion, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::HcControlReadVal`]; Write value: [`i3ccsr::regs::HcControlWriteVal`]
    #[inline(always)]
    pub fn hc_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHcControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ControllerDeviceAddrReadVal`]; Write value: [`i3ccsr::regs::ControllerDeviceAddrWriteVal`]
    #[inline(always)]
    pub fn controller_device_addr(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseControllerDeviceAddr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::HcCapabilitiesReadVal`]; Write value: [`i3ccsr::regs::HcCapabilitiesWriteVal`]
    #[inline(always)]
    pub fn hc_capabilities(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHcCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ResetControlReadVal`]; Write value: [`i3ccsr::regs::ResetControlWriteVal`]
    #[inline(always)]
    pub fn reset_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseResetControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PresentStateReadVal`]; Write value: [`i3ccsr::regs::PresentStateWriteVal`]
    #[inline(always)]
    pub fn present_state(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbasePresentState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrStatusReadVal`]; Write value: [`i3ccsr::regs::IntrStatusWriteVal`]
    #[inline(always)]
    pub fn intr_status(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrStatusEnableReadVal`]; Write value: [`i3ccsr::regs::IntrStatusEnableWriteVal`]
    #[inline(always)]
    pub fn intr_status_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrStatusEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrSignalEnableReadVal`]; Write value: [`i3ccsr::regs::IntrSignalEnableWriteVal`]
    #[inline(always)]
    pub fn intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrForceReadVal`]; Write value: [`i3ccsr::regs::IntrForceWriteVal`]
    #[inline(always)]
    pub fn intr_force(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DatSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::DatSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn dat_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDatSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DctSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::DctSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn dct_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDctSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::RingHeadersSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::RingHeadersSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn ring_headers_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseRingHeadersSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::PioSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn pio_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbasePioSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ExtCapsSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::ExtCapsSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn ext_caps_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseExtCapsSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntCtrlCmdsEnReadVal`]; Write value: [`i3ccsr::regs::IntCtrlCmdsEnWriteVal`]
    #[inline(always)]
    pub fn int_ctrl_cmds_en(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntCtrlCmdsEn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IbiNotifyCtrlReadVal`]; Write value: [`i3ccsr::regs::IbiNotifyCtrlWriteVal`]
    #[inline(always)]
    pub fn ibi_notify_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIbiNotifyCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IbiDataAbortCtrlReadVal`]; Write value: [`i3ccsr::regs::IbiDataAbortCtrlWriteVal`]
    #[inline(always)]
    pub fn ibi_data_abort_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIbiDataAbortCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxBaseLoReadVal`]; Write value: [`i3ccsr::regs::DevCtxBaseLoWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_base_lo(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxBaseLo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxBaseHiReadVal`]; Write value: [`i3ccsr::regs::DevCtxBaseHiWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_base_hi(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxBaseHi, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxSgReadVal`]; Write value: [`i3ccsr::regs::DevCtxSgWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_sg(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxSg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct PiocontrolBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> PiocontrolBlock<TMmio> {
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn command_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolCommandPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn response_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolResponsePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolTxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolRxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IbiPortReadVal`]; Write value: [`i3ccsr::regs::IbiPortWriteVal`]
    #[inline(always)]
    pub fn ibi_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolIbiPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::QueueThldCtrlReadVal`]; Write value: [`i3ccsr::regs::QueueThldCtrlWriteVal`]
    #[inline(always)]
    pub fn queue_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolQueueThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DataBufferThldCtrlReadVal`]; Write value: [`i3ccsr::regs::DataBufferThldCtrlWriteVal`]
    #[inline(always)]
    pub fn data_buffer_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolDataBufferThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::QueueSizeReadVal`]; Write value: [`i3ccsr::regs::QueueSizeWriteVal`]
    #[inline(always)]
    pub fn queue_size(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::AltQueueSizeReadVal`]; Write value: [`i3ccsr::regs::AltQueueSizeWriteVal`]
    #[inline(always)]
    pub fn alt_queue_size(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolAltQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrStatusReadVal`]; Write value: [`i3ccsr::regs::PioIntrStatusWriteVal`]
    #[inline(always)]
    pub fn pio_intr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrStatusEnableReadVal`]; Write value: [`i3ccsr::regs::PioIntrStatusEnableWriteVal`]
    #[inline(always)]
    pub fn pio_intr_status_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrStatusEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrSignalEnableReadVal`]; Write value: [`i3ccsr::regs::PioIntrSignalEnableWriteVal`]
    #[inline(always)]
    pub fn pio_intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrForceReadVal`]; Write value: [`i3ccsr::regs::PioIntrForceWriteVal`]
    #[inline(always)]
    pub fn pio_intr_force(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioControlReadVal`]; Write value: [`i3ccsr::regs::PioControlWriteVal`]
    #[inline(always)]
    pub fn pio_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct I3cEcBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> I3cEcBlock<TMmio> {
    /// Register after the last EC must advertise ID == 0.
    /// Termination register is added to guarantee that the discovery mechanism
    /// reaches termination value.
    ///
    /// Read value: [`i3ccsr::regs::TerminationExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::TerminationExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn termination_extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cEcTerminationExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecfwrecoveryifBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecfwrecoveryifBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderAnon0ReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderAnon0WriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_0(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_1(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_2(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_3(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_4(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_5(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_6(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_status_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_status_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_reset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceReset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn recovery_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifRecoveryCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn recovery_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifRecoveryStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hw_status(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifHwStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoCtrl0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoCtrl1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_4(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_5(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_data(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct StdbyctrlmodeBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> StdbyctrlmodeBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderAnon27ReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderAnon27WriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrControlAnon28ReadVal`]; Write value: [`i3ccsr::regs::StbyCrControlAnon28WriteVal`]
    #[inline(always)]
    pub fn stby_cr_control(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrDeviceAddrAnon29ReadVal`]; Write value: [`i3ccsr::regs::StbyCrDeviceAddrAnon29WriteVal`]
    #[inline(always)]
    pub fn stby_cr_device_addr(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDeviceAddr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCapabilitiesAnon30ReadVal`]; Write value: [`i3ccsr::regs::StbyCrCapabilitiesAnon30WriteVal`]
    #[inline(always)]
    pub fn stby_cr_capabilities(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_0(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrStatusAnon32ReadVal`]; Write value: [`i3ccsr::regs::StbyCrStatusAnon32WriteVal`]
    #[inline(always)]
    pub fn stby_cr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrDeviceCharAnon33ReadVal`]; Write value: [`i3ccsr::regs::StbyCrDeviceCharAnon33WriteVal`]
    #[inline(always)]
    pub fn stby_cr_device_char(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDeviceChar, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn stby_cr_device_pid_lo(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDevicePidLo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrIntrStatusAnon35ReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrStatusAnon35WriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_1(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrIntrSignalEnableAnon37ReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrSignalEnableAnon37WriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrIntrForceAnon38ReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrForceAnon38WriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_force(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCccConfigGetcapsAnon39ReadVal`]; Write value: [`i3ccsr::regs::StbyCrCccConfigGetcapsAnon39WriteVal`]
    #[inline(always)]
    pub fn stby_cr_ccc_config_getcaps(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCccConfigGetcaps, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCccConfigRstactParamsAnon40ReadVal`]; Write value: [`i3ccsr::regs::StbyCrCccConfigRstactParamsAnon40WriteVal`]
    #[inline(always)]
    pub fn stby_cr_ccc_config_rstact_params(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCccConfigRstactParams, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_2(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_3(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct TtiBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> TtiBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderAnon43ReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderAnon43WriteVal`]
    #[inline(always)]
    pub fn extcap_header(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control Register
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn control(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Status Register
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Reset Control
    ///
    /// Read value: [`i3ccsr::regs::ResetControlAnon46ReadVal`]; Write value: [`i3ccsr::regs::ResetControlAnon46WriteVal`]
    #[inline(always)]
    pub fn reset_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiResetControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Status
    ///
    /// Read value: [`i3ccsr::regs::InterruptStatusAnon47ReadVal`]; Write value: [`i3ccsr::regs::InterruptStatusAnon47WriteVal`]
    #[inline(always)]
    pub fn interrupt_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Enable
    ///
    /// Read value: [`i3ccsr::regs::InterruptEnableAnon48ReadVal`]; Write value: [`i3ccsr::regs::InterruptEnableAnon48WriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Force
    ///
    /// Read value: [`i3ccsr::regs::InterruptForceAnon49ReadVal`]; Write value: [`i3ccsr::regs::InterruptForceAnon49WriteVal`]
    #[inline(always)]
    pub fn interrupt_force(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RX Descriptor Queue Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_desc_queue_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiRxDescQueuePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RX Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiRxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TX Descriptor Queue Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_desc_queue_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiTxDescQueuePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TX Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiTxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn ibi_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiIbiPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Size
    ///
    /// Read value: [`i3ccsr::regs::QueueSizeAnon55ReadVal`]; Write value: [`i3ccsr::regs::QueueSizeAnon55WriteVal`]
    #[inline(always)]
    pub fn queue_size(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Queue Size
    ///
    /// Read value: [`i3ccsr::regs::IbiQueueSizeAnon56ReadVal`]; Write value: [`i3ccsr::regs::IbiQueueSizeAnon56WriteVal`]
    #[inline(always)]
    pub fn ibi_queue_size(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiIbiQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Threshold Control
    ///
    /// Read value: [`i3ccsr::regs::QueueThldCtrlAnon57ReadVal`]; Write value: [`i3ccsr::regs::QueueThldCtrlAnon57WriteVal`]
    #[inline(always)]
    pub fn queue_thld_ctrl(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiQueueThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Queue Threshold Control
    ///
    /// Read value: [`i3ccsr::regs::DataBufferThldCtrlAnon58ReadVal`]; Write value: [`i3ccsr::regs::DataBufferThldCtrlAnon58WriteVal`]
    #[inline(always)]
    pub fn data_buffer_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiDataBufferThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SocmgmtifBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SocmgmtifBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderAnon59ReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderAnon59WriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_control(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::SocPadConfAnon66ReadVal`]; Write value: [`i3ccsr::regs::SocPadConfAnon66WriteVal`]
    #[inline(always)]
    pub fn soc_pad_conf(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocPadConf, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::SocPadAttrAnon67ReadVal`]; Write value: [`i3ccsr::regs::SocPadAttrAnon67WriteVal`]
    #[inline(always)]
    pub fn soc_pad_attr(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocPadAttr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_feature_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtFeature2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_feature_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtFeature3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TRRegAnon70ReadVal`]; Write value: [`i3ccsr::regs::TRRegAnon70WriteVal`]
    #[inline(always)]
    pub fn t_r_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTRReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TFRegAnon71ReadVal`]; Write value: [`i3ccsr::regs::TFRegAnon71WriteVal`]
    #[inline(always)]
    pub fn t_f_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTFReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuDatRegAnon72ReadVal`]; Write value: [`i3ccsr::regs::TSuDatRegAnon72WriteVal`]
    #[inline(always)]
    pub fn t_su_dat_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuDatReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THdDatRegAnon73ReadVal`]; Write value: [`i3ccsr::regs::THdDatRegAnon73WriteVal`]
    #[inline(always)]
    pub fn t_hd_dat_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHdDatReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THighRegAnon74ReadVal`]; Write value: [`i3ccsr::regs::THighRegAnon74WriteVal`]
    #[inline(always)]
    pub fn t_high_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHighReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TLowRegAnon75ReadVal`]; Write value: [`i3ccsr::regs::TLowRegAnon75WriteVal`]
    #[inline(always)]
    pub fn t_low_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTLowReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THdStaRegAnon76ReadVal`]; Write value: [`i3ccsr::regs::THdStaRegAnon76WriteVal`]
    #[inline(always)]
    pub fn t_hd_sta_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHdStaReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuStaRegAnon77ReadVal`]; Write value: [`i3ccsr::regs::TSuStaRegAnon77WriteVal`]
    #[inline(always)]
    pub fn t_su_sta_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuStaReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuStoRegAnon78ReadVal`]; Write value: [`i3ccsr::regs::TSuStoRegAnon78WriteVal`]
    #[inline(always)]
    pub fn t_su_sto_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuStoReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_free_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTFreeReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_aval_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTAvalReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_idle_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTIdleReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct CtrlcfgBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> CtrlcfgBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderAnon82ReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderAnon82WriteVal`]
    #[inline(always)]
    pub fn extcap_header(&self) -> ureg::RegRef<crate::i3ccsr::meta::CtrlcfgExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ControllerConfigAnon83ReadVal`]; Write value: [`i3ccsr::regs::ControllerConfigAnon83WriteVal`]
    #[inline(always)]
    pub fn controller_config(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::CtrlcfgControllerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3cbase {
    _priv: (),
}
impl I3cbase {
    pub const PTR: *mut u32 = 0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Piocontrol {
    _priv: (),
}
impl Piocontrol {
    pub const PTR: *mut u32 = 0x80 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3cEc {
    _priv: (),
}
impl I3cEc {
    pub const PTR: *mut u32 = 0x100 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Secfwrecoveryif {
    _priv: (),
}
impl Secfwrecoveryif {
    pub const PTR: *mut u32 = 0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AltQueueSizeReadVal(u32);
    impl AltQueueSizeReadVal {
        /// 1 indicates that IBI queue size is equal to 8*IBI_STATUS_SIZE
        #[inline(always)]
        pub fn ext_ibi_queue_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// If set, response and command queues are not equal lengths, then
        /// ALT_RESP_QUEUE_SIZE contains response queue size
        #[inline(always)]
        pub fn alt_resp_queue_en(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Valid only if ALT_RESP_QUEUE_EN is set. Contains response queue size
        #[inline(always)]
        pub fn alt_resp_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for AltQueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AltQueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: AltQueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerDeviceAddrReadVal(u32);
    impl ControllerDeviceAddrReadVal {
        /// Dynamic Address is Valid:
        ///
        /// 0 - dynamic address is invalid
        ///
        /// 1 - dynamic address is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Device Dynamic Address
        #[inline(always)]
        pub fn dynamic_addr(&self) -> u32 {
            (self.0 >> 16) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControllerDeviceAddrWriteVal {
            ControllerDeviceAddrWriteVal(self.0)
        }
    }
    impl From<u32> for ControllerDeviceAddrReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerDeviceAddrReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerDeviceAddrReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerDeviceAddrWriteVal(u32);
    impl ControllerDeviceAddrWriteVal {
        /// Dynamic Address is Valid:
        ///
        /// 0 - dynamic address is invalid
        ///
        /// 1 - dynamic address is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Device Dynamic Address
        #[inline(always)]
        pub fn dynamic_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
        }
    }
    impl From<u32> for ControllerDeviceAddrWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerDeviceAddrWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerDeviceAddrWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlReadVal(u32);
    impl DataBufferThldCtrlReadVal {
        /// Postpone read command until RX queue has 2^(N+1) free entries
        #[inline(always)]
        pub fn rx_start_thld(&self) -> u32 {
            (self.0 >> 24) & 7
        }
        /// Postpone write command until TX queue has 2^(N+1) entries
        #[inline(always)]
        pub fn tx_start_thld(&self) -> u32 {
            (self.0 >> 16) & 7
        }
        /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
        #[inline(always)]
        pub fn rx_buf_thld(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
        #[inline(always)]
        pub fn tx_buf_thld(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DataBufferThldCtrlWriteVal {
            DataBufferThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for DataBufferThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlWriteVal(u32);
    impl DataBufferThldCtrlWriteVal {
        /// Postpone read command until RX queue has 2^(N+1) free entries
        #[inline(always)]
        pub fn rx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
        }
        /// Postpone write command until TX queue has 2^(N+1) entries
        #[inline(always)]
        pub fn tx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
        }
        /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
        #[inline(always)]
        pub fn rx_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
        #[inline(always)]
        pub fn tx_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for DataBufferThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DatSectionOffsetReadVal(u32);
    impl DatSectionOffsetReadVal {
        /// Individual DAT entry size.
        /// 0 - 2 DWRODs,
        /// 1:15 - reserved.
        #[inline(always)]
        pub fn entry_size(&self) -> u32 {
            (self.0 >> 28) & 0xf
        }
        /// Max number of DAT entries.
        #[inline(always)]
        pub fn table_size(&self) -> u32 {
            (self.0 >> 12) & 0x7f
        }
        /// DAT entry offset in respect to BASE address.
        #[inline(always)]
        pub fn table_offset(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
    }
    impl From<u32> for DatSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DatSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: DatSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DctSectionOffsetReadVal(u32);
    impl DctSectionOffsetReadVal {
        /// Individual DCT entry size.
        ///
        /// 0 - 4 DWORDs,
        ///
        /// 1:15 - Reserved.
        #[inline(always)]
        pub fn entry_size(&self) -> u32 {
            (self.0 >> 28) & 0xf
        }
        /// Index to DCT used during ENTDAA.
        #[inline(always)]
        pub fn table_index(&self) -> u32 {
            (self.0 >> 19) & 0x1f
        }
        /// Max number of DCT entries.
        #[inline(always)]
        pub fn table_size(&self) -> u32 {
            (self.0 >> 12) & 0x7f
        }
        /// DCT entry offset in respect to BASE address.
        #[inline(always)]
        pub fn table_offset(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DctSectionOffsetWriteVal {
            DctSectionOffsetWriteVal(self.0)
        }
    }
    impl From<u32> for DctSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DctSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: DctSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DctSectionOffsetWriteVal(u32);
    impl DctSectionOffsetWriteVal {
        /// Index to DCT used during ENTDAA.
        #[inline(always)]
        pub fn table_index(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 19)) | ((val & 0x1f) << 19))
        }
    }
    impl From<u32> for DctSectionOffsetWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DctSectionOffsetWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DctSectionOffsetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseHiReadVal(u32);
    impl DevCtxBaseHiReadVal {
        ///
        #[inline(always)]
        pub fn base_hi(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DevCtxBaseHiWriteVal {
            DevCtxBaseHiWriteVal(self.0)
        }
    }
    impl From<u32> for DevCtxBaseHiReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseHiReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseHiReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseHiWriteVal(u32);
    impl DevCtxBaseHiWriteVal {
        ///
        #[inline(always)]
        pub fn base_hi(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for DevCtxBaseHiWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseHiWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseHiWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseLoReadVal(u32);
    impl DevCtxBaseLoReadVal {
        ///
        #[inline(always)]
        pub fn base_lo(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DevCtxBaseLoWriteVal {
            DevCtxBaseLoWriteVal(self.0)
        }
    }
    impl From<u32> for DevCtxBaseLoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseLoReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseLoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseLoWriteVal(u32);
    impl DevCtxBaseLoWriteVal {
        ///
        #[inline(always)]
        pub fn base_lo(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for DevCtxBaseLoWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseLoWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseLoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxSgReadVal(u32);
    impl DevCtxSgReadVal {
        /// Buffer vs list pointer in device context:
        ///
        /// 0 - continuous physical memory region,
        ///
        /// 1 - pointer to SG descriptor list.
        #[inline(always)]
        pub fn blp(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Number of SG entries.
        #[inline(always)]
        pub fn list_size(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for DevCtxSgReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxSgReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxSgReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtCapsSectionOffsetReadVal(u32);
    impl ExtCapsSectionOffsetReadVal {
        /// Extended Capabilities section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for ExtCapsSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtCapsSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtCapsSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcCapabilitiesReadVal(u32);
    impl HcCapabilitiesReadVal {
        /// Device context memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_dc_en(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// DMA only: IBI status and IBI Data rings memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_ibi_en(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// DMA only: Command and Response rings memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_cr_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Size and structure of the Command Descriptor:
        ///
        /// 2'b0: 2 DWORDs,
        ///
        /// all other reserved.
        #[inline(always)]
        pub fn cmd_size(&self) -> u32 {
            (self.0 >> 20) & 3
        }
        /// Controller command scheduling:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn scheduled_commands_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Controller IBI credit count:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn ibi_credit_count_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Controller IBI data abort:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn ibi_data_abort_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// CCC with defining byte:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn cmd_ccc_defbyte(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// HDR-Ternary transfers:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn hdr_ts_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// HDR-DDR transfers:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn hdr_ddr_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Switching from active to standby mode:
        ///
        /// 0 - not supported, this controller is always active on I3C
        ///
        /// 1- supported, this controller can hand off I3C to secondary controller
        #[inline(always)]
        pub fn standby_cr_cap(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Automatic read command on IBI:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn auto_command(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Controller combined command:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn combo_command(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
    }
    impl From<u32> for HcCapabilitiesReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcCapabilitiesReadVal> for u32 {
        #[inline(always)]
        fn from(val: HcCapabilitiesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcControlReadVal(u32);
    impl HcControlReadVal {
        /// Host Controller Bus Enable
        #[inline(always)]
        pub fn bus_enable(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Host Controller Resume:
        ///
        /// 0 - Controller is running
        ///
        /// 1 - Controller is suspended
        ///
        /// Write 1 to resume Controller operations.
        #[inline(always)]
        pub fn resume(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Host Controller Abort when set to 1
        #[inline(always)]
        pub fn abort(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Halt on Command Sequence Timeout when set to 1
        #[inline(always)]
        pub fn halt_on_cmd_seq_timeout(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Hot-Join ACK/NACK Control:
        ///
        /// 0 - ACK Hot-Join request
        ///
        /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
        #[inline(always)]
        pub fn hot_join_ctrl(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// I2C Device Present on Bus:
        ///
        /// 0 - pure I3C bus
        ///
        /// 1 - legacy I2C devices on the bus
        #[inline(always)]
        pub fn i2_c_dev_present(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// DMA/PIO Mode Selector:
        ///
        /// 0 - DMA
        ///
        /// 1 - PIO
        #[inline(always)]
        pub fn mode_selector(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Data Byte Ordering Mode:
        ///
        /// 0 - Little Endian
        ///
        /// 1 - Big Endian
        #[inline(always)]
        pub fn data_byte_order_mode(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Auto-Command Data Report:
        ///
        /// 0 - coalesced reporting
        ///
        /// 1 - separated reporting
        #[inline(always)]
        pub fn autocmd_data_rpt(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Include I3C Broadcast Address:
        ///
        /// 0 - skips I3C Broadcast Address for private transfers
        ///
        /// 1 - includes I3C Broadcast Address for private transfers
        #[inline(always)]
        pub fn iba_include(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HcControlWriteVal {
            HcControlWriteVal(self.0)
        }
    }
    impl From<u32> for HcControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: HcControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcControlWriteVal(u32);
    impl HcControlWriteVal {
        /// Host Controller Bus Enable
        #[inline(always)]
        pub fn bus_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Host Controller Resume:
        ///
        /// 0 - Controller is running
        ///
        /// 1 - Controller is suspended
        ///
        /// Write 1 to resume Controller operations.
        #[inline(always)]
        pub fn resume(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Host Controller Abort when set to 1
        #[inline(always)]
        pub fn abort(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Halt on Command Sequence Timeout when set to 1
        #[inline(always)]
        pub fn halt_on_cmd_seq_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Hot-Join ACK/NACK Control:
        ///
        /// 0 - ACK Hot-Join request
        ///
        /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
        #[inline(always)]
        pub fn hot_join_ctrl(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// I2C Device Present on Bus:
        ///
        /// 0 - pure I3C bus
        ///
        /// 1 - legacy I2C devices on the bus
        #[inline(always)]
        pub fn i2_c_dev_present(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Include I3C Broadcast Address:
        ///
        /// 0 - skips I3C Broadcast Address for private transfers
        ///
        /// 1 - includes I3C Broadcast Address for private transfers
        #[inline(always)]
        pub fn iba_include(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for HcControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HcControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiDataAbortCtrlReadVal(u32);
    impl IbiDataAbortCtrlReadVal {
        /// Enable/disable IBI monitoring logic.
        #[inline(always)]
        pub fn ibi_data_abort_mon(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Define which IBI should be aborted:
        ///
        /// 3'b000 - Regular IBI,
        ///
        /// 3'b100 - Autocmd IBI,
        ///
        /// other values - not supported.
        #[inline(always)]
        pub fn match_status_type(&self) -> u32 {
            (self.0 >> 18) & 7
        }
        /// Number of data chunks to be allowed before forced termination:
        ///
        /// 0 - immediate,
        ///
        /// 1:3 - delay by 1-3 data chunks.
        #[inline(always)]
        pub fn after_n_chunks(&self) -> u32 {
            (self.0 >> 16) & 3
        }
        /// IBI target address:
        ///
        /// [15:9] - device address,
        ///
        /// [8] - must always be set to 1'b1
        #[inline(always)]
        pub fn match_ibi_id(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IbiDataAbortCtrlWriteVal {
            IbiDataAbortCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for IbiDataAbortCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiDataAbortCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiDataAbortCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiDataAbortCtrlWriteVal(u32);
    impl IbiDataAbortCtrlWriteVal {
        /// Enable/disable IBI monitoring logic.
        #[inline(always)]
        pub fn ibi_data_abort_mon(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Define which IBI should be aborted:
        ///
        /// 3'b000 - Regular IBI,
        ///
        /// 3'b100 - Autocmd IBI,
        ///
        /// other values - not supported.
        #[inline(always)]
        pub fn match_status_type(self, val: u32) -> Self {
            Self((self.0 & !(7 << 18)) | ((val & 7) << 18))
        }
        /// Number of data chunks to be allowed before forced termination:
        ///
        /// 0 - immediate,
        ///
        /// 1:3 - delay by 1-3 data chunks.
        #[inline(always)]
        pub fn after_n_chunks(self, val: u32) -> Self {
            Self((self.0 & !(3 << 16)) | ((val & 3) << 16))
        }
        /// IBI target address:
        ///
        /// [15:9] - device address,
        ///
        /// [8] - must always be set to 1'b1
        #[inline(always)]
        pub fn match_ibi_id(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for IbiDataAbortCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiDataAbortCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IbiDataAbortCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiNotifyCtrlReadVal(u32);
    impl IbiNotifyCtrlReadVal {
        /// Notify about rejected IBI:
        ///
        /// 0 - do not enqueue rejected IBI,
        ///
        /// 1 = enqueue rejected IBI on IBI queue/ring.
        #[inline(always)]
        pub fn notify_ibi_rejected(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Notify about rejected controller role request:
        ///
        /// 0 - do not enqueue rejected CRR,
        ///
        /// 1 = enqueue rejected CRR on IBI queue/ring.
        #[inline(always)]
        pub fn notify_crr_rejected(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Notify about rejected hot-join:
        ///
        /// 0 - do not enqueue rejected HJ,
        ///
        /// 1 = enqueue rejected HJ on IBI queue/ring.
        #[inline(always)]
        pub fn notify_hj_rejected(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IbiNotifyCtrlWriteVal {
            IbiNotifyCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for IbiNotifyCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiNotifyCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiNotifyCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiNotifyCtrlWriteVal(u32);
    impl IbiNotifyCtrlWriteVal {
        /// Notify about rejected IBI:
        ///
        /// 0 - do not enqueue rejected IBI,
        ///
        /// 1 = enqueue rejected IBI on IBI queue/ring.
        #[inline(always)]
        pub fn notify_ibi_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Notify about rejected controller role request:
        ///
        /// 0 - do not enqueue rejected CRR,
        ///
        /// 1 = enqueue rejected CRR on IBI queue/ring.
        #[inline(always)]
        pub fn notify_crr_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Notify about rejected hot-join:
        ///
        /// 0 - do not enqueue rejected HJ,
        ///
        /// 1 = enqueue rejected HJ on IBI queue/ring.
        #[inline(always)]
        pub fn notify_hj_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for IbiNotifyCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiNotifyCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IbiNotifyCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiPortReadVal(u32);
    impl IbiPortReadVal {
        ///
        #[inline(always)]
        pub fn ibi_data(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for IbiPortReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiPortReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiPortReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrForceWriteVal(u32);
    impl IntrForceWriteVal {
        /// Force SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Force HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Force HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Force HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Force HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrSignalEnableReadVal(u32);
    impl IntrSignalEnableReadVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_signal_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_signal_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_signal_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_signal_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_signal_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrSignalEnableWriteVal {
            IntrSignalEnableWriteVal(self.0)
        }
    }
    impl From<u32> for IntrSignalEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrSignalEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrSignalEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrSignalEnableWriteVal(u32);
    impl IntrSignalEnableWriteVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrSignalEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrSignalEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrSignalEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusReadVal(u32);
    impl IntrStatusReadVal {
        /// Scheduled commands could be executed due to controller being busy.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Command timeout after prolonged stall.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Clock stalled due to lack of commands.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Controller had to cancel command sequence.
        #[inline(always)]
        pub fn hc_seq_cancel_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Controller internal unrecoverable error.
        #[inline(always)]
        pub fn hc_internal_err_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrStatusWriteVal {
            IntrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for IntrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusWriteVal(u32);
    impl IntrStatusWriteVal {
        /// Scheduled commands could be executed due to controller being busy.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Command timeout after prolonged stall.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Clock stalled due to lack of commands.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Controller had to cancel command sequence.
        #[inline(always)]
        pub fn hc_seq_cancel_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Controller internal unrecoverable error.
        #[inline(always)]
        pub fn hc_internal_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusEnableReadVal(u32);
    impl IntrStatusEnableReadVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable HC_SEQ_CANCEL_STAT monitoring.
        #[inline(always)]
        pub fn hc_seq_cancel_stat_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable HC_INTERNAL_ERR_STAT monitoring.
        #[inline(always)]
        pub fn hc_internal_err_stat_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrStatusEnableWriteVal {
            IntrStatusEnableWriteVal(self.0)
        }
    }
    impl From<u32> for IntrStatusEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusEnableWriteVal(u32);
    impl IntrStatusEnableWriteVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable HC_SEQ_CANCEL_STAT monitoring.
        #[inline(always)]
        pub fn hc_seq_cancel_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable HC_INTERNAL_ERR_STAT monitoring.
        #[inline(always)]
        pub fn hc_internal_err_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrStatusEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntCtrlCmdsEnReadVal(u32);
    impl IntCtrlCmdsEnReadVal {
        /// Bitmask of supported MIPI commands.
        #[inline(always)]
        pub fn mipi_cmds_supported(&self) -> u32 {
            (self.0 >> 1) & 0x7fff
        }
        /// Internal Control Commands:
        ///
        /// 1 - some or all internals commands sub-commands are supported,
        ///
        /// 0 - illegal.
        #[inline(always)]
        pub fn icc_support(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for IntCtrlCmdsEnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntCtrlCmdsEnReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntCtrlCmdsEnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioControlReadVal(u32);
    impl PioControlReadVal {
        /// Stop current command descriptor execution forcefully and hold remaining commands.
        /// 1 - Request PIO Abort,
        /// 0 - Resume PIO execution
        #[inline(always)]
        pub fn abort(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Run/Stop execution of enqueued commands.
        /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
        /// 1 - PIO Queue start request,
        /// 0 - PIO Queue stop request.
        #[inline(always)]
        pub fn rs(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
        /// 1 - PIO queue enable request,
        /// 0 - PIO queue disable request
        #[inline(always)]
        pub fn enable(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioControlWriteVal {
            PioControlWriteVal(self.0)
        }
    }
    impl From<u32> for PioControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioControlWriteVal(u32);
    impl PioControlWriteVal {
        /// Stop current command descriptor execution forcefully and hold remaining commands.
        /// 1 - Request PIO Abort,
        /// 0 - Resume PIO execution
        #[inline(always)]
        pub fn abort(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Run/Stop execution of enqueued commands.
        /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
        /// 1 - PIO Queue start request,
        /// 0 - PIO Queue stop request.
        #[inline(always)]
        pub fn rs(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
        /// 1 - PIO queue enable request,
        /// 0 - PIO queue disable request
        #[inline(always)]
        pub fn enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrForceWriteVal(u32);
    impl PioIntrForceWriteVal {
        /// Force transfer error
        #[inline(always)]
        pub fn transfer_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Force transfer aborted
        #[inline(always)]
        pub fn transfer_abort_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Force response queue interrupt
        #[inline(always)]
        pub fn resp_ready_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Force command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Force IBI queue interrupt
        #[inline(always)]
        pub fn ibi_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Force RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Force TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrSignalEnableReadVal(u32);
    impl PioIntrSignalEnableReadVal {
        /// Enable transfer error interrupt
        #[inline(always)]
        pub fn transfer_err_signal_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable transfer abort interrupt
        #[inline(always)]
        pub fn transfer_abort_signal_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable response ready interrupt
        #[inline(always)]
        pub fn resp_ready_signal_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_signal_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable IBI queue interrupt
        #[inline(always)]
        pub fn ibi_status_thld_signal_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_signal_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_signal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrSignalEnableWriteVal {
            PioIntrSignalEnableWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrSignalEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrSignalEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrSignalEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrSignalEnableWriteVal(u32);
    impl PioIntrSignalEnableWriteVal {
        /// Enable transfer error interrupt
        #[inline(always)]
        pub fn transfer_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable transfer abort interrupt
        #[inline(always)]
        pub fn transfer_abort_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable response ready interrupt
        #[inline(always)]
        pub fn resp_ready_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable IBI queue interrupt
        #[inline(always)]
        pub fn ibi_status_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrSignalEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrSignalEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrSignalEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusReadVal(u32);
    impl PioIntrStatusReadVal {
        /// Transfer error
        #[inline(always)]
        pub fn transfer_err_stat(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Transfer aborted
        #[inline(always)]
        pub fn transfer_abort_stat(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Response queue fulfils RESP_BUF_THLD
        #[inline(always)]
        pub fn resp_ready_stat(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Command queue fulfils CMD_EMPTY_BUF_THLD
        #[inline(always)]
        pub fn cmd_queue_ready_stat(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// IBI queue fulfils IBI_STATUS_THLD
        #[inline(always)]
        pub fn ibi_status_thld_stat(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// RX queue fulfils RX_BUF_THLD
        #[inline(always)]
        pub fn rx_thld_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// TX queue fulfils TX_BUF_THLD
        #[inline(always)]
        pub fn tx_thld_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrStatusWriteVal {
            PioIntrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusWriteVal(u32);
    impl PioIntrStatusWriteVal {
        /// Transfer error
        #[inline(always)]
        pub fn transfer_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Transfer aborted
        #[inline(always)]
        pub fn transfer_abort_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for PioIntrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusEnableReadVal(u32);
    impl PioIntrStatusEnableReadVal {
        /// Enable transfer error monitoring
        #[inline(always)]
        pub fn transfer_err_stat_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable transfer abort monitoring
        #[inline(always)]
        pub fn transfer_abort_stat_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable response queue monitoring
        #[inline(always)]
        pub fn resp_ready_stat_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable command queue monitoring
        #[inline(always)]
        pub fn cmd_queue_ready_stat_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable IBI queue monitoring
        #[inline(always)]
        pub fn ibi_status_thld_stat_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable RX queue monitoring
        #[inline(always)]
        pub fn rx_thld_stat_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable TX queue monitoring
        #[inline(always)]
        pub fn tx_thld_stat_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrStatusEnableWriteVal {
            PioIntrStatusEnableWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrStatusEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusEnableWriteVal(u32);
    impl PioIntrStatusEnableWriteVal {
        /// Enable transfer error monitoring
        #[inline(always)]
        pub fn transfer_err_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable transfer abort monitoring
        #[inline(always)]
        pub fn transfer_abort_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable response queue monitoring
        #[inline(always)]
        pub fn resp_ready_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable command queue monitoring
        #[inline(always)]
        pub fn cmd_queue_ready_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable IBI queue monitoring
        #[inline(always)]
        pub fn ibi_status_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable RX queue monitoring
        #[inline(always)]
        pub fn rx_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable TX queue monitoring
        #[inline(always)]
        pub fn tx_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrStatusEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioSectionOffsetReadVal(u32);
    impl PioSectionOffsetReadVal {
        /// PIO section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for PioSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PresentStateReadVal(u32);
    impl PresentStateReadVal {
        /// Controller I3C state:
        ///
        /// 0 - not bus owner
        ///
        /// 1 - bus owner
        #[inline(always)]
        pub fn ac_current_own(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
    }
    impl From<u32> for PresentStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PresentStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: PresentStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueSizeReadVal(u32);
    impl QueueSizeReadVal {
        /// TX queue size is equal to 2^(N+1), where N is this field value
        #[inline(always)]
        pub fn tx_data_buffer_size(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// RX queue size is equal to 2^(N+1), where N is this field value
        #[inline(always)]
        pub fn rx_data_buffer_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// IBI Queue size is equal to N
        #[inline(always)]
        pub fn ibi_status_size(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Command/Response queue size is equal to N
        #[inline(always)]
        pub fn cr_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for QueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlReadVal(u32);
    impl QueueThldCtrlReadVal {
        /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn ibi_status_thld(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// IBI Queue data segment size. Valida values are 1:63
        #[inline(always)]
        pub fn ibi_data_segment_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn resp_buf_thld(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
        #[inline(always)]
        pub fn cmd_empty_buf_thld(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> QueueThldCtrlWriteVal {
            QueueThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for QueueThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlWriteVal(u32);
    impl QueueThldCtrlWriteVal {
        /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn ibi_status_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// IBI Queue data segment size. Valida values are 1:63
        #[inline(always)]
        pub fn ibi_data_segment_size(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn resp_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
        #[inline(always)]
        pub fn cmd_empty_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for QueueThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlReadVal(u32);
    impl ResetControlReadVal {
        /// Clear IBI queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn ibi_queue_rst(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Clear RX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn rx_fifo_rst(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Clear TX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn tx_fifo_rst(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Clear response queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn resp_queue_rst(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Clear command queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn cmd_queue_rst(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Reset controller from software.
        #[inline(always)]
        pub fn soft_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetControlWriteVal {
            ResetControlWriteVal(self.0)
        }
    }
    impl From<u32> for ResetControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlWriteVal(u32);
    impl ResetControlWriteVal {
        /// Clear IBI queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn ibi_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Clear RX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn rx_fifo_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Clear TX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn tx_fifo_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Clear response queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn resp_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Clear command queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn cmd_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Reset controller from software.
        #[inline(always)]
        pub fn soft_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ResetControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RingHeadersSectionOffsetReadVal(u32);
    impl RingHeadersSectionOffsetReadVal {
        /// DMA ring headers section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for RingHeadersSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RingHeadersSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: RingHeadersSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TerminationExtcapHeaderReadVal(u32);
    impl TerminationExtcapHeaderReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for TerminationExtcapHeaderReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TerminationExtcapHeaderReadVal> for u32 {
        #[inline(always)]
        fn from(val: TerminationExtcapHeaderReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderAnon0ReadVal(u32);
    impl ExtcapHeaderAnon0ReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderAnon0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderAnon0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderAnon0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderAnon27ReadVal(u32);
    impl ExtcapHeaderAnon27ReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderAnon27ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderAnon27ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderAnon27ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrControlAnon28ReadVal(u32);
    impl StbyCrControlAnon28ReadVal {
        /// Enables or disables the Secondary Controller:
        ///
        /// 2'b00 - DISABLED: Secondary Controller is disabled.
        ///
        /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
        /// but Host Controller initializes in Active Controller mode.
        ///
        /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
        /// Host Controller initializes in Standby Controller mode.
        ///
        /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
        /// Host Controller conditionally becomes a Hot-Joining Device
        /// to receive its Dynamic Address before operating in Standby Controller mode.
        #[inline(always)]
        pub fn stby_cr_enable_init(&self) -> u32 {
            (self.0 >> 30) & 3
        }
        /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
        /// Defining Byte 0x02.
        ///
        /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
        ///
        /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
        #[inline(always)]
        pub fn rstact_defbyte_02(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Indicates ENTDAA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_entdaa_enable(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Indicates SETDASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setdasa_enable(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Indicates SETAASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setaasa_enable(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
        /// an I3C Target Transaction Interface to software (Section 6.17.3).
        ///
        /// 1'b0: DISABLED: not available
        ///
        /// 1'b1: ENABLED: available for software
        #[inline(always)]
        pub fn target_xact_enable(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
        /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
        #[inline(always)]
        pub fn bast_ccc_ibi_ring(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
        /// to attempt to send a Controller Role Request to the I3C Bus.
        #[inline(always)]
        pub fn cr_request_send(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
        /// report a return from Deep Sleep state to the Active Controller.
        /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
        /// after accepting the Controller Role and transitioning to Active Controller mode.
        #[inline(always)]
        pub fn handoff_deep_sleep(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn prime_accept_getacccr(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_fsm_op_select(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn handoff_delay_nack(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn pending_rx_nack(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrControlAnon28WriteVal {
            StbyCrControlAnon28WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrControlAnon28ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrControlAnon28ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrControlAnon28ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrControlAnon28WriteVal(u32);
    impl StbyCrControlAnon28WriteVal {
        /// Enables or disables the Secondary Controller:
        ///
        /// 2'b00 - DISABLED: Secondary Controller is disabled.
        ///
        /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
        /// but Host Controller initializes in Active Controller mode.
        ///
        /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
        /// Host Controller initializes in Standby Controller mode.
        ///
        /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
        /// Host Controller conditionally becomes a Hot-Joining Device
        /// to receive its Dynamic Address before operating in Standby Controller mode.
        #[inline(always)]
        pub fn stby_cr_enable_init(self, val: u32) -> Self {
            Self((self.0 & !(3 << 30)) | ((val & 3) << 30))
        }
        /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
        /// Defining Byte 0x02.
        ///
        /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
        ///
        /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
        #[inline(always)]
        pub fn rstact_defbyte_02(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Indicates ENTDAA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_entdaa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Indicates SETDASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setdasa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Indicates SETAASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setaasa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
        /// an I3C Target Transaction Interface to software (Section 6.17.3).
        ///
        /// 1'b0: DISABLED: not available
        ///
        /// 1'b1: ENABLED: available for software
        #[inline(always)]
        pub fn target_xact_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
        /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
        #[inline(always)]
        pub fn bast_ccc_ibi_ring(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
        /// to attempt to send a Controller Role Request to the I3C Bus.
        #[inline(always)]
        pub fn cr_request_send(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
        /// report a return from Deep Sleep state to the Active Controller.
        /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
        /// after accepting the Controller Role and transitioning to Active Controller mode.
        #[inline(always)]
        pub fn handoff_deep_sleep(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        ///
        #[inline(always)]
        pub fn prime_accept_getacccr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        ///
        #[inline(always)]
        pub fn acr_fsm_op_select(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn handoff_delay_nack(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn pending_rx_nack(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrControlAnon28WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrControlAnon28WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrControlAnon28WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceAddrAnon29ReadVal(u32);
    impl StbyCrDeviceAddrAnon29ReadVal {
        /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
        /// 1'b0: DYNAMIC_ADDR field is not valid
        /// 1'b1: DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Contains the Host Controller Device’s Dynamic Address.
        #[inline(always)]
        pub fn dynamic_addr(&self) -> u32 {
            (self.0 >> 16) & 0x7f
        }
        /// Indicates whether or not the value in the STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Static Address field is not valid
        ///
        /// 1'b1: The Static Address field is valid
        #[inline(always)]
        pub fn static_addr_valid(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn static_addr(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrDeviceAddrAnon29WriteVal {
            StbyCrDeviceAddrAnon29WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrDeviceAddrAnon29ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceAddrAnon29ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceAddrAnon29ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceAddrAnon29WriteVal(u32);
    impl StbyCrDeviceAddrAnon29WriteVal {
        /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
        /// 1'b0: DYNAMIC_ADDR field is not valid
        /// 1'b1: DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Contains the Host Controller Device’s Dynamic Address.
        #[inline(always)]
        pub fn dynamic_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
        }
        /// Indicates whether or not the value in the STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Static Address field is not valid
        ///
        /// 1'b1: The Static Address field is valid
        #[inline(always)]
        pub fn static_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn static_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 0)) | ((val & 0x7f) << 0))
        }
    }
    impl From<u32> for StbyCrDeviceAddrAnon29WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceAddrAnon29WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceAddrAnon29WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCapabilitiesAnon30ReadVal(u32);
    impl StbyCrCapabilitiesAnon30ReadVal {
        /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_entdaa_support(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setdasa_support(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setaasa_support(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Defines whether an I3C Target Transaction Interface is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
        #[inline(always)]
        pub fn target_xact_support(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn simple_crr_support(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrCapabilitiesAnon30WriteVal {
            StbyCrCapabilitiesAnon30WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrCapabilitiesAnon30ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCapabilitiesAnon30ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCapabilitiesAnon30ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCapabilitiesAnon30WriteVal(u32);
    impl StbyCrCapabilitiesAnon30WriteVal {
        /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_entdaa_support(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setdasa_support(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setaasa_support(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Defines whether an I3C Target Transaction Interface is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
        #[inline(always)]
        pub fn target_xact_support(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        ///
        #[inline(always)]
        pub fn simple_crr_support(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for StbyCrCapabilitiesAnon30WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCapabilitiesAnon30WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCapabilitiesAnon30WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrStatusAnon32ReadVal(u32);
    impl StbyCrStatusAnon32ReadVal {
        ///
        #[inline(always)]
        pub fn hj_req_status(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn simple_crr_status(&self) -> u32 {
            (self.0 >> 5) & 7
        }
        ///
        #[inline(always)]
        pub fn ac_current_own(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrStatusAnon32WriteVal {
            StbyCrStatusAnon32WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrStatusAnon32ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrStatusAnon32ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrStatusAnon32ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrStatusAnon32WriteVal(u32);
    impl StbyCrStatusAnon32WriteVal {
        ///
        #[inline(always)]
        pub fn hj_req_status(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        ///
        #[inline(always)]
        pub fn simple_crr_status(self, val: u32) -> Self {
            Self((self.0 & !(7 << 5)) | ((val & 7) << 5))
        }
        ///
        #[inline(always)]
        pub fn ac_current_own(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for StbyCrStatusAnon32WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrStatusAnon32WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrStatusAnon32WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceCharAnon33ReadVal(u32);
    impl StbyCrDeviceCharAnon33ReadVal {
        ///
        #[inline(always)]
        pub fn bcr_fixed(&self) -> u32 {
            (self.0 >> 29) & 7
        }
        ///
        #[inline(always)]
        pub fn bcr_var(&self) -> u32 {
            (self.0 >> 24) & 0x1f
        }
        ///
        #[inline(always)]
        pub fn dcr(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        ///
        #[inline(always)]
        pub fn pid_hi(&self) -> u32 {
            (self.0 >> 1) & 0x7fff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrDeviceCharAnon33WriteVal {
            StbyCrDeviceCharAnon33WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrDeviceCharAnon33ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceCharAnon33ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceCharAnon33ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceCharAnon33WriteVal(u32);
    impl StbyCrDeviceCharAnon33WriteVal {
        ///
        #[inline(always)]
        pub fn bcr_fixed(self, val: u32) -> Self {
            Self((self.0 & !(7 << 29)) | ((val & 7) << 29))
        }
        ///
        #[inline(always)]
        pub fn bcr_var(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 24)) | ((val & 0x1f) << 24))
        }
        ///
        #[inline(always)]
        pub fn dcr(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        ///
        #[inline(always)]
        pub fn pid_hi(self, val: u32) -> Self {
            Self((self.0 & !(0x7fff << 1)) | ((val & 0x7fff) << 1))
        }
    }
    impl From<u32> for StbyCrDeviceCharAnon33WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceCharAnon33WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceCharAnon33WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrStatusAnon35ReadVal(u32);
    impl StbyCrIntrStatusAnon35ReadVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_stat(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_stat(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_stat(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_stat(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_stat(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_stat(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn crr_response_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_m3_stat(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_fail_stat(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_primed_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_remain_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrStatusAnon35WriteVal {
            StbyCrIntrStatusAnon35WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrStatusAnon35ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrStatusAnon35ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrStatusAnon35ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrStatusAnon35WriteVal(u32);
    impl StbyCrIntrStatusAnon35WriteVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        ///
        #[inline(always)]
        pub fn crr_response_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_m3_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_fail_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_primed_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_remain_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrIntrStatusAnon35WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrStatusAnon35WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrStatusAnon35WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrSignalEnableAnon37ReadVal(u32);
    impl StbyCrIntrSignalEnableAnon37ReadVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_signal_en(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_signal_en(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_signal_en(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_signal_en(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_signal_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_signal_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_signal_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_signal_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn crr_response_signal_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_m3_signal_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_fail_signal_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_primed_signal_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_remain_signal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrSignalEnableAnon37WriteVal {
            StbyCrIntrSignalEnableAnon37WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrSignalEnableAnon37ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrSignalEnableAnon37ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrSignalEnableAnon37ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrSignalEnableAnon37WriteVal(u32);
    impl StbyCrIntrSignalEnableAnon37WriteVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        ///
        #[inline(always)]
        pub fn crr_response_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_m3_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_err_fail_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_primed_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn acr_handoff_ok_remain_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrIntrSignalEnableAnon37WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrSignalEnableAnon37WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrSignalEnableAnon37WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrForceAnon38ReadVal(u32);
    impl StbyCrIntrForceAnon38ReadVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_force(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_force(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_force(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_force(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_force(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_force(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_force(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_force(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn crr_response_force(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrForceAnon38WriteVal {
            StbyCrIntrForceAnon38WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrForceAnon38ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrForceAnon38ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrForceAnon38ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrForceAnon38WriteVal(u32);
    impl StbyCrIntrForceAnon38WriteVal {
        ///
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        ///
        #[inline(always)]
        pub fn ccc_unhandled_nack_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        ///
        #[inline(always)]
        pub fn ccc_param_modified_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_op_rstact_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_ok_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_accept_nacked_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        ///
        #[inline(always)]
        pub fn stby_cr_dyn_addr_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        ///
        #[inline(always)]
        pub fn crr_response_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for StbyCrIntrForceAnon38WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrForceAnon38WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrForceAnon38WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigGetcapsAnon39ReadVal(u32);
    impl StbyCrCccConfigGetcapsAnon39ReadVal {
        ///
        #[inline(always)]
        pub fn f2_crcap2_dev_interact(&self) -> u32 {
            (self.0 >> 8) & 0xf
        }
        ///
        #[inline(always)]
        pub fn f2_crcap1_bus_config(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrCccConfigGetcapsAnon39WriteVal {
            StbyCrCccConfigGetcapsAnon39WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrCccConfigGetcapsAnon39ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigGetcapsAnon39ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigGetcapsAnon39ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigGetcapsAnon39WriteVal(u32);
    impl StbyCrCccConfigGetcapsAnon39WriteVal {
        ///
        #[inline(always)]
        pub fn f2_crcap2_dev_interact(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
        }
        ///
        #[inline(always)]
        pub fn f2_crcap1_bus_config(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for StbyCrCccConfigGetcapsAnon39WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigGetcapsAnon39WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigGetcapsAnon39WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigRstactParamsAnon40ReadVal(u32);
    impl StbyCrCccConfigRstactParamsAnon40ReadVal {
        ///
        #[inline(always)]
        pub fn reset_dynamic_addr(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn reset_time_target(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        ///
        #[inline(always)]
        pub fn reset_time_peripheral(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        ///
        #[inline(always)]
        pub fn rst_action(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrCccConfigRstactParamsAnon40WriteVal {
            StbyCrCccConfigRstactParamsAnon40WriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrCccConfigRstactParamsAnon40ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigRstactParamsAnon40ReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigRstactParamsAnon40ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigRstactParamsAnon40WriteVal(u32);
    impl StbyCrCccConfigRstactParamsAnon40WriteVal {
        ///
        #[inline(always)]
        pub fn reset_dynamic_addr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        ///
        #[inline(always)]
        pub fn reset_time_target(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        ///
        #[inline(always)]
        pub fn reset_time_peripheral(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        ///
        #[inline(always)]
        pub fn rst_action(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for StbyCrCccConfigRstactParamsAnon40WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigRstactParamsAnon40WriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigRstactParamsAnon40WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderAnon43ReadVal(u32);
    impl ExtcapHeaderAnon43ReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderAnon43ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderAnon43ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderAnon43ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlAnon46ReadVal(u32);
    impl ResetControlAnon46ReadVal {
        /// TTI IBI Queue Buffer Software Reset
        #[inline(always)]
        pub fn ibi_queue_rst(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// TTI RX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_data_rst(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// TTI TX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_data_rst(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// TTI RX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_desc_rst(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// TTI TX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_desc_rst(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Target Core Software Reset
        #[inline(always)]
        pub fn soft_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetControlAnon46WriteVal {
            ResetControlAnon46WriteVal(self.0)
        }
    }
    impl From<u32> for ResetControlAnon46ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlAnon46ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlAnon46ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlAnon46WriteVal(u32);
    impl ResetControlAnon46WriteVal {
        /// TTI IBI Queue Buffer Software Reset
        #[inline(always)]
        pub fn ibi_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// TTI RX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_data_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// TTI TX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_data_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// TTI RX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_desc_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// TTI TX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_desc_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Target Core Software Reset
        #[inline(always)]
        pub fn soft_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ResetControlAnon46WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlAnon46WriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlAnon46WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStatusAnon47ReadVal(u32);
    impl InterruptStatusAnon47ReadVal {
        /// Bus error occurred
        #[inline(always)]
        pub fn transfer_err_stat(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Bus aborted transaction
        #[inline(always)]
        pub fn transfer_abort_stat(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
        #[inline(always)]
        pub fn ibi_thld_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
        #[inline(always)]
        pub fn rx_desc_thld_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
        #[inline(always)]
        pub fn tx_desc_thld_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
        #[inline(always)]
        pub fn rx_data_thld_stat(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
        #[inline(always)]
        pub fn tx_data_thld_stat(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Pending Write was NACK’ed, because the `TX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn tx_desc_timeout(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Pending Read was NACK’ed, because the `RX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn rx_desc_timeout(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
        #[inline(always)]
        pub fn tx_desc_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
        #[inline(always)]
        pub fn rx_desc_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStatusAnon47WriteVal {
            InterruptStatusAnon47WriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStatusAnon47ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStatusAnon47ReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStatusAnon47ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStatusAnon47WriteVal(u32);
    impl InterruptStatusAnon47WriteVal {
        /// Bus error occurred
        #[inline(always)]
        pub fn transfer_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Bus aborted transaction
        #[inline(always)]
        pub fn transfer_abort_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Pending Write was NACK’ed, because the `TX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn tx_desc_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Pending Read was NACK’ed, because the `RX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn rx_desc_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
        #[inline(always)]
        pub fn tx_desc_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
        #[inline(always)]
        pub fn rx_desc_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptStatusAnon47WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStatusAnon47WriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStatusAnon47WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableAnon48ReadVal(u32);
    impl InterruptEnableAnon48ReadVal {
        /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
        #[inline(always)]
        pub fn ibi_thld_stat_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn rx_desc_thld_stat_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn tx_desc_thld_stat_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn rx_data_thld_stat_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn tx_data_thld_stat_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableAnon48WriteVal {
            InterruptEnableAnon48WriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableAnon48ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableAnon48ReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableAnon48ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableAnon48WriteVal(u32);
    impl InterruptEnableAnon48WriteVal {
        /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
        #[inline(always)]
        pub fn ibi_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn rx_desc_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn tx_desc_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn rx_data_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn tx_data_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptEnableAnon48WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableAnon48WriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableAnon48WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptForceAnon49ReadVal(u32);
    impl InterruptForceAnon49ReadVal {
        /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
        #[inline(always)]
        pub fn ibi_thld_force(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_desc_thld_force(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_desc_thld_force(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_data_thld_force(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_data_thld_force(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptForceAnon49WriteVal {
            InterruptForceAnon49WriteVal(self.0)
        }
    }
    impl From<u32> for InterruptForceAnon49ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptForceAnon49ReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptForceAnon49ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptForceAnon49WriteVal(u32);
    impl InterruptForceAnon49WriteVal {
        /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
        #[inline(always)]
        pub fn ibi_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_desc_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_desc_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_data_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_data_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptForceAnon49WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptForceAnon49WriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptForceAnon49WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueSizeAnon55ReadVal(u32);
    impl QueueSizeAnon55ReadVal {
        /// Transmit Data Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn tx_data_buffer_size(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Receive Data Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn rx_data_buffer_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// TX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn tx_desc_buffer_size(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// RX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn rx_desc_buffer_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for QueueSizeAnon55ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueSizeAnon55ReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueSizeAnon55ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiQueueSizeAnon56ReadVal(u32);
    impl IbiQueueSizeAnon56ReadVal {
        /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn ibi_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for IbiQueueSizeAnon56ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiQueueSizeAnon56ReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiQueueSizeAnon56ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlAnon57ReadVal(u32);
    impl QueueThldCtrlAnon57ReadVal {
        /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
        #[inline(always)]
        pub fn ibi_thld(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
        #[inline(always)]
        pub fn rx_desc_thld(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
        #[inline(always)]
        pub fn tx_desc_thld(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> QueueThldCtrlAnon57WriteVal {
            QueueThldCtrlAnon57WriteVal(self.0)
        }
    }
    impl From<u32> for QueueThldCtrlAnon57ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlAnon57ReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlAnon57ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlAnon57WriteVal(u32);
    impl QueueThldCtrlAnon57WriteVal {
        /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
        #[inline(always)]
        pub fn ibi_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
        #[inline(always)]
        pub fn rx_desc_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
        #[inline(always)]
        pub fn tx_desc_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for QueueThldCtrlAnon57WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlAnon57WriteVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlAnon57WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlAnon58ReadVal(u32);
    impl DataBufferThldCtrlAnon58ReadVal {
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_start_thld(&self) -> u32 {
            (self.0 >> 24) & 7
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_start_thld(&self) -> u32 {
            (self.0 >> 16) & 7
        }
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_data_thld(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_data_thld(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DataBufferThldCtrlAnon58WriteVal {
            DataBufferThldCtrlAnon58WriteVal(self.0)
        }
    }
    impl From<u32> for DataBufferThldCtrlAnon58ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlAnon58ReadVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlAnon58ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlAnon58WriteVal(u32);
    impl DataBufferThldCtrlAnon58WriteVal {
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
        }
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_data_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_data_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for DataBufferThldCtrlAnon58WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlAnon58WriteVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlAnon58WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderAnon59ReadVal(u32);
    impl ExtcapHeaderAnon59ReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderAnon59ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderAnon59ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderAnon59ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadConfAnon66ReadVal(u32);
    impl SocPadConfAnon66ReadVal {
        /// Select pad type
        ///
        /// 0 - Bidirectional
        ///
        /// 1 - Open-drain
        ///
        /// 2 - Input-only
        ///
        /// 3 - Analog input
        #[inline(always)]
        pub fn pad_type(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Enable virtual open drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn virtual_od_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Enable Open-Drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn od_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Invert I/O signal:
        ///
        /// 0 - signals pass-through
        ///
        /// 1 - signals are inverted
        #[inline(always)]
        pub fn io_inversion(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable Pull:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn pull_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Direction of the pull:
        ///
        /// 0 - Pull down
        ///
        /// 1 - Pull up
        #[inline(always)]
        pub fn pull_dir(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable the High-Keeper:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn keeper_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable the Schmitt Trigger:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn schmitt_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable input:
        ///
        /// 0 - enabled
        ///
        /// 1 - disabled
        #[inline(always)]
        pub fn input_enable(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SocPadConfAnon66WriteVal {
            SocPadConfAnon66WriteVal(self.0)
        }
    }
    impl From<u32> for SocPadConfAnon66ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadConfAnon66ReadVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadConfAnon66ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadConfAnon66WriteVal(u32);
    impl SocPadConfAnon66WriteVal {
        /// Select pad type
        ///
        /// 0 - Bidirectional
        ///
        /// 1 - Open-drain
        ///
        /// 2 - Input-only
        ///
        /// 3 - Analog input
        #[inline(always)]
        pub fn pad_type(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Enable virtual open drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn virtual_od_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Enable Open-Drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn od_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Invert I/O signal:
        ///
        /// 0 - signals pass-through
        ///
        /// 1 - signals are inverted
        #[inline(always)]
        pub fn io_inversion(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable Pull:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn pull_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Direction of the pull:
        ///
        /// 0 - Pull down
        ///
        /// 1 - Pull up
        #[inline(always)]
        pub fn pull_dir(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable the High-Keeper:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn keeper_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable the Schmitt Trigger:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn schmitt_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable input:
        ///
        /// 0 - enabled
        ///
        /// 1 - disabled
        #[inline(always)]
        pub fn input_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SocPadConfAnon66WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadConfAnon66WriteVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadConfAnon66WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadAttrAnon67ReadVal(u32);
    impl SocPadAttrAnon67ReadVal {
        /// Select driver strength
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_strength(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Select driver slew rate
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_slew_rate(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SocPadAttrAnon67WriteVal {
            SocPadAttrAnon67WriteVal(self.0)
        }
    }
    impl From<u32> for SocPadAttrAnon67ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadAttrAnon67ReadVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadAttrAnon67ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadAttrAnon67WriteVal(u32);
    impl SocPadAttrAnon67WriteVal {
        /// Select driver strength
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_strength(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Select driver slew rate
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_slew_rate(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for SocPadAttrAnon67WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadAttrAnon67WriteVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadAttrAnon67WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TRRegAnon70ReadVal(u32);
    impl TRRegAnon70ReadVal {
        /// Rise time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_r(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TRRegAnon70WriteVal {
            TRRegAnon70WriteVal(self.0)
        }
    }
    impl From<u32> for TRRegAnon70ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TRRegAnon70ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TRRegAnon70ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TRRegAnon70WriteVal(u32);
    impl TRRegAnon70WriteVal {
        /// Rise time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_r(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TRRegAnon70WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TRRegAnon70WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TRRegAnon70WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TFRegAnon71ReadVal(u32);
    impl TFRegAnon71ReadVal {
        /// Fall time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_f(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TFRegAnon71WriteVal {
            TFRegAnon71WriteVal(self.0)
        }
    }
    impl From<u32> for TFRegAnon71ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TFRegAnon71ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TFRegAnon71ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TFRegAnon71WriteVal(u32);
    impl TFRegAnon71WriteVal {
        /// Fall time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_f(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TFRegAnon71WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TFRegAnon71WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TFRegAnon71WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuDatRegAnon72ReadVal(u32);
    impl TSuDatRegAnon72ReadVal {
        /// Data setup time in clock units
        #[inline(always)]
        pub fn t_su_dat(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuDatRegAnon72WriteVal {
            TSuDatRegAnon72WriteVal(self.0)
        }
    }
    impl From<u32> for TSuDatRegAnon72ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuDatRegAnon72ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuDatRegAnon72ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuDatRegAnon72WriteVal(u32);
    impl TSuDatRegAnon72WriteVal {
        /// Data setup time in clock units
        #[inline(always)]
        pub fn t_su_dat(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuDatRegAnon72WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuDatRegAnon72WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuDatRegAnon72WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdDatRegAnon73ReadVal(u32);
    impl THdDatRegAnon73ReadVal {
        /// Data hold time in clock units
        #[inline(always)]
        pub fn t_hd_dat(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THdDatRegAnon73WriteVal {
            THdDatRegAnon73WriteVal(self.0)
        }
    }
    impl From<u32> for THdDatRegAnon73ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdDatRegAnon73ReadVal> for u32 {
        #[inline(always)]
        fn from(val: THdDatRegAnon73ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdDatRegAnon73WriteVal(u32);
    impl THdDatRegAnon73WriteVal {
        /// Data hold time in clock units
        #[inline(always)]
        pub fn t_hd_dat(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THdDatRegAnon73WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdDatRegAnon73WriteVal> for u32 {
        #[inline(always)]
        fn from(val: THdDatRegAnon73WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THighRegAnon74ReadVal(u32);
    impl THighRegAnon74ReadVal {
        ///
        #[inline(always)]
        pub fn t_high(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THighRegAnon74WriteVal {
            THighRegAnon74WriteVal(self.0)
        }
    }
    impl From<u32> for THighRegAnon74ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THighRegAnon74ReadVal> for u32 {
        #[inline(always)]
        fn from(val: THighRegAnon74ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THighRegAnon74WriteVal(u32);
    impl THighRegAnon74WriteVal {
        ///
        #[inline(always)]
        pub fn t_high(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THighRegAnon74WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THighRegAnon74WriteVal> for u32 {
        #[inline(always)]
        fn from(val: THighRegAnon74WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TLowRegAnon75ReadVal(u32);
    impl TLowRegAnon75ReadVal {
        /// Low period of the SCL in clock units
        #[inline(always)]
        pub fn t_low(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TLowRegAnon75WriteVal {
            TLowRegAnon75WriteVal(self.0)
        }
    }
    impl From<u32> for TLowRegAnon75ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TLowRegAnon75ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TLowRegAnon75ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TLowRegAnon75WriteVal(u32);
    impl TLowRegAnon75WriteVal {
        /// Low period of the SCL in clock units
        #[inline(always)]
        pub fn t_low(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TLowRegAnon75WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TLowRegAnon75WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TLowRegAnon75WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdStaRegAnon76ReadVal(u32);
    impl THdStaRegAnon76ReadVal {
        /// Hold time for (repeated) START in clock units
        #[inline(always)]
        pub fn t_hd_sta(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THdStaRegAnon76WriteVal {
            THdStaRegAnon76WriteVal(self.0)
        }
    }
    impl From<u32> for THdStaRegAnon76ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdStaRegAnon76ReadVal> for u32 {
        #[inline(always)]
        fn from(val: THdStaRegAnon76ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdStaRegAnon76WriteVal(u32);
    impl THdStaRegAnon76WriteVal {
        /// Hold time for (repeated) START in clock units
        #[inline(always)]
        pub fn t_hd_sta(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THdStaRegAnon76WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdStaRegAnon76WriteVal> for u32 {
        #[inline(always)]
        fn from(val: THdStaRegAnon76WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStaRegAnon77ReadVal(u32);
    impl TSuStaRegAnon77ReadVal {
        /// Setup time for repeated START in clock units
        #[inline(always)]
        pub fn t_su_sta(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuStaRegAnon77WriteVal {
            TSuStaRegAnon77WriteVal(self.0)
        }
    }
    impl From<u32> for TSuStaRegAnon77ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStaRegAnon77ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStaRegAnon77ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStaRegAnon77WriteVal(u32);
    impl TSuStaRegAnon77WriteVal {
        /// Setup time for repeated START in clock units
        #[inline(always)]
        pub fn t_su_sta(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuStaRegAnon77WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStaRegAnon77WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStaRegAnon77WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStoRegAnon78ReadVal(u32);
    impl TSuStoRegAnon78ReadVal {
        /// Setup time for STOP in clock units
        #[inline(always)]
        pub fn t_su_sto(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuStoRegAnon78WriteVal {
            TSuStoRegAnon78WriteVal(self.0)
        }
    }
    impl From<u32> for TSuStoRegAnon78ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStoRegAnon78ReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStoRegAnon78ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStoRegAnon78WriteVal(u32);
    impl TSuStoRegAnon78WriteVal {
        /// Setup time for STOP in clock units
        #[inline(always)]
        pub fn t_su_sto(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuStoRegAnon78WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStoRegAnon78WriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStoRegAnon78WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderAnon82ReadVal(u32);
    impl ExtcapHeaderAnon82ReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderAnon82ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderAnon82ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderAnon82ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerConfigAnon83ReadVal(u32);
    impl ControllerConfigAnon83ReadVal {
        ///
        #[inline(always)]
        pub fn operation_mode(&self) -> u32 {
            (self.0 >> 4) & 3
        }
    }
    impl From<u32> for ControllerConfigAnon83ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerConfigAnon83ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerConfigAnon83ReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type I3cbaseHciVersion = ureg::ReadOnlyReg32<u32>;
    pub type I3cbaseHcControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::HcControlReadVal,
        crate::i3ccsr::regs::HcControlWriteVal,
    >;
    pub type I3cbaseControllerDeviceAddr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ControllerDeviceAddrReadVal,
        crate::i3ccsr::regs::ControllerDeviceAddrWriteVal,
    >;
    pub type I3cbaseHcCapabilities =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::HcCapabilitiesReadVal>;
    pub type I3cbaseResetControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ResetControlReadVal,
        crate::i3ccsr::regs::ResetControlWriteVal,
    >;
    pub type I3cbasePresentState = ureg::ReadOnlyReg32<crate::i3ccsr::regs::PresentStateReadVal>;
    pub type I3cbaseIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrStatusReadVal,
        crate::i3ccsr::regs::IntrStatusWriteVal,
    >;
    pub type I3cbaseIntrStatusEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrStatusEnableReadVal,
        crate::i3ccsr::regs::IntrStatusEnableWriteVal,
    >;
    pub type I3cbaseIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrSignalEnableReadVal,
        crate::i3ccsr::regs::IntrSignalEnableWriteVal,
    >;
    pub type I3cbaseIntrForce = ureg::WriteOnlyReg32<0, crate::i3ccsr::regs::IntrForceWriteVal>;
    pub type I3cbaseDatSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::DatSectionOffsetReadVal>;
    pub type I3cbaseDctSectionOffset = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DctSectionOffsetReadVal,
        crate::i3ccsr::regs::DctSectionOffsetWriteVal,
    >;
    pub type I3cbaseRingHeadersSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::RingHeadersSectionOffsetReadVal>;
    pub type I3cbasePioSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::PioSectionOffsetReadVal>;
    pub type I3cbaseExtCapsSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtCapsSectionOffsetReadVal>;
    pub type I3cbaseIntCtrlCmdsEn = ureg::ReadOnlyReg32<crate::i3ccsr::regs::IntCtrlCmdsEnReadVal>;
    pub type I3cbaseIbiNotifyCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IbiNotifyCtrlReadVal,
        crate::i3ccsr::regs::IbiNotifyCtrlWriteVal,
    >;
    pub type I3cbaseIbiDataAbortCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IbiDataAbortCtrlReadVal,
        crate::i3ccsr::regs::IbiDataAbortCtrlWriteVal,
    >;
    pub type I3cbaseDevCtxBaseLo = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DevCtxBaseLoReadVal,
        crate::i3ccsr::regs::DevCtxBaseLoWriteVal,
    >;
    pub type I3cbaseDevCtxBaseHi = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DevCtxBaseHiReadVal,
        crate::i3ccsr::regs::DevCtxBaseHiWriteVal,
    >;
    pub type I3cbaseDevCtxSg = ureg::ReadOnlyReg32<crate::i3ccsr::regs::DevCtxSgReadVal>;
    pub type PiocontrolCommandPort = ureg::WriteOnlyReg32<0, u32>;
    pub type PiocontrolResponsePort = ureg::ReadOnlyReg32<u32>;
    pub type PiocontrolTxDataPort = ureg::WriteOnlyReg32<0, u32>;
    pub type PiocontrolRxDataPort = ureg::ReadOnlyReg32<u32>;
    pub type PiocontrolIbiPort = ureg::ReadOnlyReg32<crate::i3ccsr::regs::IbiPortReadVal>;
    pub type PiocontrolQueueThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::QueueThldCtrlReadVal,
        crate::i3ccsr::regs::QueueThldCtrlWriteVal,
    >;
    pub type PiocontrolDataBufferThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DataBufferThldCtrlReadVal,
        crate::i3ccsr::regs::DataBufferThldCtrlWriteVal,
    >;
    pub type PiocontrolQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::QueueSizeReadVal>;
    pub type PiocontrolAltQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::AltQueueSizeReadVal>;
    pub type PiocontrolPioIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrStatusReadVal,
        crate::i3ccsr::regs::PioIntrStatusWriteVal,
    >;
    pub type PiocontrolPioIntrStatusEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrStatusEnableReadVal,
        crate::i3ccsr::regs::PioIntrStatusEnableWriteVal,
    >;
    pub type PiocontrolPioIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrSignalEnableReadVal,
        crate::i3ccsr::regs::PioIntrSignalEnableWriteVal,
    >;
    pub type PiocontrolPioIntrForce =
        ureg::WriteOnlyReg32<0, crate::i3ccsr::regs::PioIntrForceWriteVal>;
    pub type PiocontrolPioControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioControlReadVal,
        crate::i3ccsr::regs::PioControlWriteVal,
    >;
    pub type I3cEcTerminationExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::TerminationExtcapHeaderReadVal>;
    pub type SecfwrecoveryifExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderAnon0ReadVal>;
    pub type SecfwrecoveryifProtCap0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifProtCap1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifProtCap2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifProtCap3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId6 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceStatus0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceStatus1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceReset = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifRecoveryCtrl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifRecoveryStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifHwStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoCtrl0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoCtrl1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoData = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderAnon27ReadVal>;
    pub type StdbyctrlmodeStbyCrControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrControlAnon28ReadVal,
        crate::i3ccsr::regs::StbyCrControlAnon28WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDeviceAddr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrDeviceAddrAnon29ReadVal,
        crate::i3ccsr::regs::StbyCrDeviceAddrAnon29WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCapabilities = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrCapabilitiesAnon30ReadVal,
        crate::i3ccsr::regs::StbyCrCapabilitiesAnon30WriteVal,
    >;
    pub type StdbyctrlmodeRsvd0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrStatusAnon32ReadVal,
        crate::i3ccsr::regs::StbyCrStatusAnon32WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDeviceChar = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrDeviceCharAnon33ReadVal,
        crate::i3ccsr::regs::StbyCrDeviceCharAnon33WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDevicePidLo = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrStatusAnon35ReadVal,
        crate::i3ccsr::regs::StbyCrIntrStatusAnon35WriteVal,
    >;
    pub type StdbyctrlmodeRsvd1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrSignalEnableAnon37ReadVal,
        crate::i3ccsr::regs::StbyCrIntrSignalEnableAnon37WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrIntrForce = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrForceAnon38ReadVal,
        crate::i3ccsr::regs::StbyCrIntrForceAnon38WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCccConfigGetcaps = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrCccConfigGetcapsAnon39ReadVal,
        crate::i3ccsr::regs::StbyCrCccConfigGetcapsAnon39WriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCccConfigRstactParams = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrCccConfigRstactParamsAnon40ReadVal,
        crate::i3ccsr::regs::StbyCrCccConfigRstactParamsAnon40WriteVal,
    >;
    pub type StdbyctrlmodeRsvd2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeRsvd3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TtiExtcapHeader = ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderAnon43ReadVal>;
    pub type TtiControl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TtiStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TtiResetControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ResetControlAnon46ReadVal,
        crate::i3ccsr::regs::ResetControlAnon46WriteVal,
    >;
    pub type TtiInterruptStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptStatusAnon47ReadVal,
        crate::i3ccsr::regs::InterruptStatusAnon47WriteVal,
    >;
    pub type TtiInterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptEnableAnon48ReadVal,
        crate::i3ccsr::regs::InterruptEnableAnon48WriteVal,
    >;
    pub type TtiInterruptForce = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptForceAnon49ReadVal,
        crate::i3ccsr::regs::InterruptForceAnon49WriteVal,
    >;
    pub type TtiRxDescQueuePort = ureg::ReadOnlyReg32<u32>;
    pub type TtiRxDataPort = ureg::ReadOnlyReg32<u32>;
    pub type TtiTxDescQueuePort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiTxDataPort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiIbiPort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::QueueSizeAnon55ReadVal>;
    pub type TtiIbiQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::IbiQueueSizeAnon56ReadVal>;
    pub type TtiQueueThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::QueueThldCtrlAnon57ReadVal,
        crate::i3ccsr::regs::QueueThldCtrlAnon57WriteVal,
    >;
    pub type TtiDataBufferThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DataBufferThldCtrlAnon58ReadVal,
        crate::i3ccsr::regs::DataBufferThldCtrlAnon58WriteVal,
    >;
    pub type SocmgmtifExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderAnon59ReadVal>;
    pub type SocmgmtifSocMgmtControl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocPadConf = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::SocPadConfAnon66ReadVal,
        crate::i3ccsr::regs::SocPadConfAnon66WriteVal,
    >;
    pub type SocmgmtifSocPadAttr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::SocPadAttrAnon67ReadVal,
        crate::i3ccsr::regs::SocPadAttrAnon67WriteVal,
    >;
    pub type SocmgmtifSocMgmtFeature2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtFeature3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTRReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TRRegAnon70ReadVal,
        crate::i3ccsr::regs::TRRegAnon70WriteVal,
    >;
    pub type SocmgmtifTFReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TFRegAnon71ReadVal,
        crate::i3ccsr::regs::TFRegAnon71WriteVal,
    >;
    pub type SocmgmtifTSuDatReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuDatRegAnon72ReadVal,
        crate::i3ccsr::regs::TSuDatRegAnon72WriteVal,
    >;
    pub type SocmgmtifTHdDatReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THdDatRegAnon73ReadVal,
        crate::i3ccsr::regs::THdDatRegAnon73WriteVal,
    >;
    pub type SocmgmtifTHighReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THighRegAnon74ReadVal,
        crate::i3ccsr::regs::THighRegAnon74WriteVal,
    >;
    pub type SocmgmtifTLowReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TLowRegAnon75ReadVal,
        crate::i3ccsr::regs::TLowRegAnon75WriteVal,
    >;
    pub type SocmgmtifTHdStaReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THdStaRegAnon76ReadVal,
        crate::i3ccsr::regs::THdStaRegAnon76WriteVal,
    >;
    pub type SocmgmtifTSuStaReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuStaRegAnon77ReadVal,
        crate::i3ccsr::regs::TSuStaRegAnon77WriteVal,
    >;
    pub type SocmgmtifTSuStoReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuStoRegAnon78ReadVal,
        crate::i3ccsr::regs::TSuStoRegAnon78WriteVal,
    >;
    pub type SocmgmtifTFreeReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTAvalReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTIdleReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CtrlcfgExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderAnon82ReadVal>;
    pub type CtrlcfgControllerConfig =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ControllerConfigAnon83ReadVal>;
}

// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at f6d35180615eb1908ba719e3296e82a610ebd31e
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3ccsr {
    _priv: (),
}
impl I3ccsr {
    pub const PTR: *mut u32 = 0x10040000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn dat(&self) -> ureg::Array<256, ureg::RegRef<crate::i3ccsr::meta::Dat, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn dct(&self) -> ureg::Array<512, ureg::RegRef<crate::i3ccsr::meta::Dct, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x800 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn i3c_base(&self) -> I3cbaseBlock<&TMmio> {
        I3cbaseBlock {
            ptr: unsafe { self.ptr.add(0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn piocontrol(&self) -> PiocontrolBlock<&TMmio> {
        PiocontrolBlock {
            ptr: unsafe { self.ptr.add(0x80 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn i3c_ec(&self) -> I3cEcBlock<&TMmio> {
        I3cEcBlock {
            ptr: unsafe { self.ptr.add(0x100 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn sec_fw_recovery_if(&self) -> SecfwrecoveryifBlock<&TMmio> {
        SecfwrecoveryifBlock {
            ptr: unsafe { self.ptr.add(0x100 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn stdby_ctrl_mode(&self) -> StdbyctrlmodeBlock<&TMmio> {
        StdbyctrlmodeBlock {
            ptr: unsafe { self.ptr.add(0x180 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn tti(&self) -> TtiBlock<&TMmio> {
        TtiBlock {
            ptr: unsafe { self.ptr.add(0x1c0 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn so_cmgmt_if(&self) -> SocmgmtifBlock<&TMmio> {
        SocmgmtifBlock {
            ptr: unsafe { self.ptr.add(0x200 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
    #[inline(always)]
    pub fn ctrl_cfg(&self) -> CtrlcfgBlock<&TMmio> {
        CtrlcfgBlock {
            ptr: unsafe { self.ptr.add(0x260 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct I3cbaseBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> I3cbaseBlock<TMmio> {
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hci_version(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHciVersion, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::HcControlReadVal`]; Write value: [`i3ccsr::regs::HcControlWriteVal`]
    #[inline(always)]
    pub fn hc_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHcControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ControllerDeviceAddrReadVal`]; Write value: [`i3ccsr::regs::ControllerDeviceAddrWriteVal`]
    #[inline(always)]
    pub fn controller_device_addr(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseControllerDeviceAddr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::HcCapabilitiesReadVal`]; Write value: [`i3ccsr::regs::HcCapabilitiesWriteVal`]
    #[inline(always)]
    pub fn hc_capabilities(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseHcCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ResetControlReadVal`]; Write value: [`i3ccsr::regs::ResetControlWriteVal`]
    #[inline(always)]
    pub fn reset_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseResetControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PresentStateReadVal`]; Write value: [`i3ccsr::regs::PresentStateWriteVal`]
    #[inline(always)]
    pub fn present_state(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbasePresentState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrStatusReadVal`]; Write value: [`i3ccsr::regs::IntrStatusWriteVal`]
    #[inline(always)]
    pub fn intr_status(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrStatusEnableReadVal`]; Write value: [`i3ccsr::regs::IntrStatusEnableWriteVal`]
    #[inline(always)]
    pub fn intr_status_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrStatusEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrSignalEnableReadVal`]; Write value: [`i3ccsr::regs::IntrSignalEnableWriteVal`]
    #[inline(always)]
    pub fn intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntrForceReadVal`]; Write value: [`i3ccsr::regs::IntrForceWriteVal`]
    #[inline(always)]
    pub fn intr_force(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DatSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::DatSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn dat_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDatSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DctSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::DctSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn dct_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDctSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::RingHeadersSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::RingHeadersSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn ring_headers_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseRingHeadersSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::PioSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn pio_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbasePioSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ExtCapsSectionOffsetReadVal`]; Write value: [`i3ccsr::regs::ExtCapsSectionOffsetWriteVal`]
    #[inline(always)]
    pub fn ext_caps_section_offset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseExtCapsSectionOffset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IntCtrlCmdsEnReadVal`]; Write value: [`i3ccsr::regs::IntCtrlCmdsEnWriteVal`]
    #[inline(always)]
    pub fn int_ctrl_cmds_en(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIntCtrlCmdsEn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IbiNotifyCtrlReadVal`]; Write value: [`i3ccsr::regs::IbiNotifyCtrlWriteVal`]
    #[inline(always)]
    pub fn ibi_notify_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIbiNotifyCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IbiDataAbortCtrlReadVal`]; Write value: [`i3ccsr::regs::IbiDataAbortCtrlWriteVal`]
    #[inline(always)]
    pub fn ibi_data_abort_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseIbiDataAbortCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxBaseLoReadVal`]; Write value: [`i3ccsr::regs::DevCtxBaseLoWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_base_lo(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxBaseLo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxBaseHiReadVal`]; Write value: [`i3ccsr::regs::DevCtxBaseHiWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_base_hi(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxBaseHi, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DevCtxSgReadVal`]; Write value: [`i3ccsr::regs::DevCtxSgWriteVal`]
    #[inline(always)]
    pub fn dev_ctx_sg(&self) -> ureg::RegRef<crate::i3ccsr::meta::I3cbaseDevCtxSg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct PiocontrolBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> PiocontrolBlock<TMmio> {
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn command_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolCommandPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn response_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolResponsePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolTxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolRxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn ibi_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolIbiPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::QueueThldCtrlReadVal`]; Write value: [`i3ccsr::regs::QueueThldCtrlWriteVal`]
    #[inline(always)]
    pub fn queue_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolQueueThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DataBufferThldCtrlReadVal`]; Write value: [`i3ccsr::regs::DataBufferThldCtrlWriteVal`]
    #[inline(always)]
    pub fn data_buffer_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolDataBufferThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::QueueSizeReadVal`]; Write value: [`i3ccsr::regs::QueueSizeWriteVal`]
    #[inline(always)]
    pub fn queue_size(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::AltQueueSizeReadVal`]; Write value: [`i3ccsr::regs::AltQueueSizeWriteVal`]
    #[inline(always)]
    pub fn alt_queue_size(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolAltQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrStatusReadVal`]; Write value: [`i3ccsr::regs::PioIntrStatusWriteVal`]
    #[inline(always)]
    pub fn pio_intr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrStatusEnableReadVal`]; Write value: [`i3ccsr::regs::PioIntrStatusEnableWriteVal`]
    #[inline(always)]
    pub fn pio_intr_status_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrStatusEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrSignalEnableReadVal`]; Write value: [`i3ccsr::regs::PioIntrSignalEnableWriteVal`]
    #[inline(always)]
    pub fn pio_intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioIntrForceReadVal`]; Write value: [`i3ccsr::regs::PioIntrForceWriteVal`]
    #[inline(always)]
    pub fn pio_intr_force(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::PioControlReadVal`]; Write value: [`i3ccsr::regs::PioControlWriteVal`]
    #[inline(always)]
    pub fn pio_control(&self) -> ureg::RegRef<crate::i3ccsr::meta::PiocontrolPioControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct I3cEcBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> I3cEcBlock<TMmio> {
    /// Register after the last EC must advertise ID == 0.
    /// Termination register is added to guarantee that the discovery mechanism
    /// reaches termination value.
    ///
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn termination_extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::I3cEcTerminationExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SecfwrecoveryifBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SecfwrecoveryifBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_0(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_1(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ProtCap2ReadVal`]; Write value: [`i3ccsr::regs::ProtCap2WriteVal`]
    #[inline(always)]
    pub fn prot_cap_2(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ProtCap3ReadVal`]; Write value: [`i3ccsr::regs::ProtCap3WriteVal`]
    #[inline(always)]
    pub fn prot_cap_3(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifProtCap3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DeviceId0ReadVal`]; Write value: [`i3ccsr::regs::DeviceId0WriteVal`]
    #[inline(always)]
    pub fn device_id_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_4(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_5(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceId5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_reserved(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceIdReserved, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DeviceStatus0ReadVal`]; Write value: [`i3ccsr::regs::DeviceStatus0WriteVal`]
    #[inline(always)]
    pub fn device_status_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::DeviceStatus1ReadVal`]; Write value: [`i3ccsr::regs::DeviceStatus1WriteVal`]
    #[inline(always)]
    pub fn device_status_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// For devices which support reset, this register will reset the device or management entity
    ///
    /// Read value: [`i3ccsr::regs::DeviceResetReadVal`]; Write value: [`i3ccsr::regs::DeviceResetWriteVal`]
    #[inline(always)]
    pub fn device_reset(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifDeviceReset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::RecoveryCtrlReadVal`]; Write value: [`i3ccsr::regs::RecoveryCtrlWriteVal`]
    #[inline(always)]
    pub fn recovery_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifRecoveryCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::RecoveryStatusReadVal`]; Write value: [`i3ccsr::regs::RecoveryStatusWriteVal`]
    #[inline(always)]
    pub fn recovery_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifRecoveryStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::HwStatusReadVal`]; Write value: [`i3ccsr::regs::HwStatusWriteVal`]
    #[inline(always)]
    pub fn hw_status(&self) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifHwStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IndirectFifoCtrl0ReadVal`]; Write value: [`i3ccsr::regs::IndirectFifoCtrl0WriteVal`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoCtrl0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoCtrl1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::IndirectFifoStatus0ReadVal`]; Write value: [`i3ccsr::regs::IndirectFifoStatus0WriteVal`]
    #[inline(always)]
    pub fn indirect_fifo_status_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_4(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoStatus4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_reserved(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoReserved, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indirect memory access to address space configured in INDIRECT_FIFO_CTRL at the Head Pointer offset.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_data(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SecfwrecoveryifIndirectFifoData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct StdbyctrlmodeBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> StdbyctrlmodeBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrControlReadVal`]; Write value: [`i3ccsr::regs::StbyCrControlWriteVal`]
    #[inline(always)]
    pub fn stby_cr_control(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrDeviceAddrReadVal`]; Write value: [`i3ccsr::regs::StbyCrDeviceAddrWriteVal`]
    #[inline(always)]
    pub fn stby_cr_device_addr(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDeviceAddr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCapabilitiesReadVal`]; Write value: [`i3ccsr::regs::StbyCrCapabilitiesWriteVal`]
    #[inline(always)]
    pub fn stby_cr_capabilities(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCapabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_0(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrStatusReadVal`]; Write value: [`i3ccsr::regs::StbyCrStatusWriteVal`]
    #[inline(always)]
    pub fn stby_cr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrDeviceCharReadVal`]; Write value: [`i3ccsr::regs::StbyCrDeviceCharWriteVal`]
    #[inline(always)]
    pub fn stby_cr_device_char(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDeviceChar, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn stby_cr_device_pid_lo(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrDevicePidLo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrIntrStatusReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrStatusWriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_1(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// When set to 1'b1, and the corresponding interrupt status field is set in register
    /// STBY_CR_INTR_STATUS, the Host Controller shall assert an interrupt to the Host.
    ///
    /// Read value: [`i3ccsr::regs::StbyCrIntrSignalEnableReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrSignalEnableWriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_signal_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrSignalEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// For software testing, when set to 1'b1, forces the corresponding interrupt
    /// to be sent to the Host, if the corresponding fields are set in register
    /// STBY_CR_INTR_SIGNAL_ENABLE
    ///
    /// Read value: [`i3ccsr::regs::StbyCrIntrForceReadVal`]; Write value: [`i3ccsr::regs::StbyCrIntrForceWriteVal`]
    #[inline(always)]
    pub fn stby_cr_intr_force(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrIntrForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCccConfigGetcapsReadVal`]; Write value: [`i3ccsr::regs::StbyCrCccConfigGetcapsWriteVal`]
    #[inline(always)]
    pub fn stby_cr_ccc_config_getcaps(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCccConfigGetcaps, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrCccConfigRstactParamsReadVal`]; Write value: [`i3ccsr::regs::StbyCrCccConfigRstactParamsWriteVal`]
    #[inline(always)]
    pub fn stby_cr_ccc_config_rstact_params(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrCccConfigRstactParams, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::StbyCrVirtDeviceAddrReadVal`]; Write value: [`i3ccsr::regs::StbyCrVirtDeviceAddrWriteVal`]
    #[inline(always)]
    pub fn stby_cr_virt_device_addr(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeStbyCrVirtDeviceAddr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn _rsvd_3(&self) -> ureg::RegRef<crate::i3ccsr::meta::StdbyctrlmodeRsvd3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct TtiBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> TtiBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control Register
    ///
    /// Read value: [`i3ccsr::regs::ControlReadVal`]; Write value: [`i3ccsr::regs::ControlWriteVal`]
    #[inline(always)]
    pub fn control(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Status Register
    ///
    /// Read value: [`i3ccsr::regs::StatusReadVal`]; Write value: [`i3ccsr::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Reset Control
    ///
    /// Read value: [`i3ccsr::regs::TtiResetControlReadVal`]; Write value: [`i3ccsr::regs::TtiResetControlWriteVal`]
    #[inline(always)]
    pub fn tti_reset_control(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiTtiResetControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Status
    ///
    /// Read value: [`i3ccsr::regs::InterruptStatusReadVal`]; Write value: [`i3ccsr::regs::InterruptStatusWriteVal`]
    #[inline(always)]
    pub fn interrupt_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Enable
    ///
    /// Read value: [`i3ccsr::regs::InterruptEnableReadVal`]; Write value: [`i3ccsr::regs::InterruptEnableWriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Interrupt Force
    ///
    /// Read value: [`i3ccsr::regs::InterruptForceReadVal`]; Write value: [`i3ccsr::regs::InterruptForceWriteVal`]
    #[inline(always)]
    pub fn interrupt_force(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiInterruptForce, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RX Descriptor Queue Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_desc_queue_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiRxDescQueuePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RX Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiRxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TX Descriptor Queue Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_desc_queue_port(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiTxDescQueuePort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TX Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tx_data_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiTxDataPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Data Port
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn tti_ibi_port(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiTtiIbiPort, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Size
    ///
    /// Read value: [`i3ccsr::regs::TtiQueueSizeReadVal`]; Write value: [`i3ccsr::regs::TtiQueueSizeWriteVal`]
    #[inline(always)]
    pub fn tti_queue_size(&self) -> ureg::RegRef<crate::i3ccsr::meta::TtiTtiQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Queue Size
    ///
    /// Read value: [`i3ccsr::regs::IbiTtiQueueSizeReadVal`]; Write value: [`i3ccsr::regs::IbiTtiQueueSizeWriteVal`]
    #[inline(always)]
    pub fn ibi_tti_queue_size(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiIbiTtiQueueSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Queue Threshold Control
    ///
    /// Read value: [`i3ccsr::regs::TtiQueueThldCtrlReadVal`]; Write value: [`i3ccsr::regs::TtiQueueThldCtrlWriteVal`]
    #[inline(always)]
    pub fn tti_queue_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiTtiQueueThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// IBI Queue Threshold Control
    ///
    /// Read value: [`i3ccsr::regs::TtiDataBufferThldCtrlReadVal`]; Write value: [`i3ccsr::regs::TtiDataBufferThldCtrlWriteVal`]
    #[inline(always)]
    pub fn tti_data_buffer_thld_ctrl(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::TtiTtiDataBufferThldCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct SocmgmtifBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> SocmgmtifBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_control(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_status(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_0(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_1(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_rsvd_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtRsvd3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::SocPadConfReadVal`]; Write value: [`i3ccsr::regs::SocPadConfWriteVal`]
    #[inline(always)]
    pub fn soc_pad_conf(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocPadConf, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::SocPadAttrReadVal`]; Write value: [`i3ccsr::regs::SocPadAttrWriteVal`]
    #[inline(always)]
    pub fn soc_pad_attr(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocPadAttr, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_feature_2(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtFeature2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn soc_mgmt_feature_3(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifSocMgmtFeature3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TRRegReadVal`]; Write value: [`i3ccsr::regs::TRRegWriteVal`]
    #[inline(always)]
    pub fn t_r_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTRReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TFRegReadVal`]; Write value: [`i3ccsr::regs::TFRegWriteVal`]
    #[inline(always)]
    pub fn t_f_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTFReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuDatRegReadVal`]; Write value: [`i3ccsr::regs::TSuDatRegWriteVal`]
    #[inline(always)]
    pub fn t_su_dat_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuDatReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THdDatRegReadVal`]; Write value: [`i3ccsr::regs::THdDatRegWriteVal`]
    #[inline(always)]
    pub fn t_hd_dat_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHdDatReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THighRegReadVal`]; Write value: [`i3ccsr::regs::THighRegWriteVal`]
    #[inline(always)]
    pub fn t_high_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHighReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TLowRegReadVal`]; Write value: [`i3ccsr::regs::TLowRegWriteVal`]
    #[inline(always)]
    pub fn t_low_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTLowReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::THdStaRegReadVal`]; Write value: [`i3ccsr::regs::THdStaRegWriteVal`]
    #[inline(always)]
    pub fn t_hd_sta_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTHdStaReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuStaRegReadVal`]; Write value: [`i3ccsr::regs::TSuStaRegWriteVal`]
    #[inline(always)]
    pub fn t_su_sta_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuStaReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::TSuStoRegReadVal`]; Write value: [`i3ccsr::regs::TSuStoRegWriteVal`]
    #[inline(always)]
    pub fn t_su_sto_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTSuStoReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_free_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTFreeReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_aval_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTAvalReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn t_idle_reg(&self) -> ureg::RegRef<crate::i3ccsr::meta::SocmgmtifTIdleReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
#[derive(Clone, Copy)]
pub struct CtrlcfgBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> CtrlcfgBlock<TMmio> {
    /// Read value: [`i3ccsr::regs::ExtcapHeaderReadVal`]; Write value: [`i3ccsr::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(&self) -> ureg::RegRef<crate::i3ccsr::meta::CtrlcfgExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`i3ccsr::regs::ControllerConfigReadVal`]; Write value: [`i3ccsr::regs::ControllerConfigWriteVal`]
    #[inline(always)]
    pub fn controller_config(
        &self,
    ) -> ureg::RegRef<crate::i3ccsr::meta::CtrlcfgControllerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3cbase {
    _priv: (),
}
impl I3cbase {
    pub const PTR: *mut u32 = 0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Piocontrol {
    _priv: (),
}
impl Piocontrol {
    pub const PTR: *mut u32 = 0x80 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct I3cEc {
    _priv: (),
}
impl I3cEc {
    pub const PTR: *mut u32 = 0x100 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Secfwrecoveryif {
    _priv: (),
}
impl Secfwrecoveryif {
    pub const PTR: *mut u32 = 0 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AltQueueSizeReadVal(u32);
    impl AltQueueSizeReadVal {
        /// 1 indicates that IBI queue size is equal to 8*IBI_STATUS_SIZE
        #[inline(always)]
        pub fn ext_ibi_queue_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// If set, response and command queues are not equal lengths, then
        /// ALT_RESP_QUEUE_SIZE contains response queue size
        #[inline(always)]
        pub fn alt_resp_queue_en(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Valid only if ALT_RESP_QUEUE_EN is set. Contains response queue size
        #[inline(always)]
        pub fn alt_resp_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for AltQueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AltQueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: AltQueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlReadVal(u32);
    impl ControlReadVal {
        /// Number of times the Target Device will try to request an IBI before giving up.
        ///
        /// Values:
        ///
        /// 0x0 - Device will never retry.
        ///
        /// 0x1-0x6 - Device will retry this many times.
        ///
        /// 0x7 - Device will retry indefinitely until the Active Controller sets
        /// DISINT bit in the DISEC command.
        #[inline(always)]
        pub fn ibi_retry_num(&self) -> u32 {
            (self.0 >> 13) & 7
        }
        /// Enable the IBI queue servicing.
        ///
        /// Values:
        ///
        /// 0x0 - Device will not service the IBI queue.
        ///
        /// 0x1 - Device will send IBI requests onto the bus, if possible.
        #[inline(always)]
        pub fn ibi_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable Controller Role Request.
        ///
        /// Values:
        ///
        /// 0x0 - Device is allowed to perform Controller Role Request.
        ///
        /// 0x1 - Device is not allowed to perform Controller Role Request.
        #[inline(always)]
        pub fn crr_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable Hot-Join capability.
        ///
        /// Values:
        ///
        /// 0x0 - Device is allowed to attempt Hot-Join.
        ///
        /// 0x1 - Device is not allowed to attempt Hot-Join.
        #[inline(always)]
        pub fn hj_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControlWriteVal {
            ControlWriteVal(self.0)
        }
    }
    impl From<u32> for ControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlWriteVal(u32);
    impl ControlWriteVal {
        /// Number of times the Target Device will try to request an IBI before giving up.
        ///
        /// Values:
        ///
        /// 0x0 - Device will never retry.
        ///
        /// 0x1-0x6 - Device will retry this many times.
        ///
        /// 0x7 - Device will retry indefinitely until the Active Controller sets
        /// DISINT bit in the DISEC command.
        #[inline(always)]
        pub fn ibi_retry_num(self, val: u32) -> Self {
            Self((self.0 & !(7 << 13)) | ((val & 7) << 13))
        }
        /// Enable the IBI queue servicing.
        ///
        /// Values:
        ///
        /// 0x0 - Device will not service the IBI queue.
        ///
        /// 0x1 - Device will send IBI requests onto the bus, if possible.
        #[inline(always)]
        pub fn ibi_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable Controller Role Request.
        ///
        /// Values:
        ///
        /// 0x0 - Device is allowed to perform Controller Role Request.
        ///
        /// 0x1 - Device is not allowed to perform Controller Role Request.
        #[inline(always)]
        pub fn crr_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable Hot-Join capability.
        ///
        /// Values:
        ///
        /// 0x0 - Device is allowed to attempt Hot-Join.
        ///
        /// 0x1 - Device is not allowed to attempt Hot-Join.
        #[inline(always)]
        pub fn hj_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for ControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerConfigReadVal(u32);
    impl ControllerConfigReadVal {
        #[inline(always)]
        pub fn operation_mode(&self) -> u32 {
            (self.0 >> 4) & 3
        }
    }
    impl From<u32> for ControllerConfigReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerConfigReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerConfigReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerDeviceAddrReadVal(u32);
    impl ControllerDeviceAddrReadVal {
        /// Dynamic Address is Valid:
        ///
        /// 0 - dynamic address is invalid
        ///
        /// 1 - dynamic address is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Device Dynamic Address
        #[inline(always)]
        pub fn dynamic_addr(&self) -> u32 {
            (self.0 >> 16) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControllerDeviceAddrWriteVal {
            ControllerDeviceAddrWriteVal(self.0)
        }
    }
    impl From<u32> for ControllerDeviceAddrReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerDeviceAddrReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerDeviceAddrReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControllerDeviceAddrWriteVal(u32);
    impl ControllerDeviceAddrWriteVal {
        /// Dynamic Address is Valid:
        ///
        /// 0 - dynamic address is invalid
        ///
        /// 1 - dynamic address is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Device Dynamic Address
        #[inline(always)]
        pub fn dynamic_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
        }
    }
    impl From<u32> for ControllerDeviceAddrWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControllerDeviceAddrWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ControllerDeviceAddrWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlReadVal(u32);
    impl DataBufferThldCtrlReadVal {
        /// Postpone read command until RX queue has 2^(N+1) free entries
        #[inline(always)]
        pub fn rx_start_thld(&self) -> u32 {
            (self.0 >> 24) & 7
        }
        /// Postpone write command until TX queue has 2^(N+1) entries
        #[inline(always)]
        pub fn tx_start_thld(&self) -> u32 {
            (self.0 >> 16) & 7
        }
        /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
        #[inline(always)]
        pub fn rx_buf_thld(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
        #[inline(always)]
        pub fn tx_buf_thld(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DataBufferThldCtrlWriteVal {
            DataBufferThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for DataBufferThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DataBufferThldCtrlWriteVal(u32);
    impl DataBufferThldCtrlWriteVal {
        /// Postpone read command until RX queue has 2^(N+1) free entries
        #[inline(always)]
        pub fn rx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
        }
        /// Postpone write command until TX queue has 2^(N+1) entries
        #[inline(always)]
        pub fn tx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
        }
        /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
        #[inline(always)]
        pub fn rx_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
        #[inline(always)]
        pub fn tx_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for DataBufferThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DataBufferThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DataBufferThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DatSectionOffsetReadVal(u32);
    impl DatSectionOffsetReadVal {
        /// Individual DAT entry size.
        /// 0 - 2 DWRODs,
        /// 1:15 - reserved.
        #[inline(always)]
        pub fn entry_size(&self) -> u32 {
            (self.0 >> 28) & 0xf
        }
        /// Max number of DAT entries.
        #[inline(always)]
        pub fn table_size(&self) -> u32 {
            (self.0 >> 12) & 0x7f
        }
        /// DAT entry offset in respect to BASE address.
        #[inline(always)]
        pub fn table_offset(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
    }
    impl From<u32> for DatSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DatSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: DatSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DctSectionOffsetReadVal(u32);
    impl DctSectionOffsetReadVal {
        /// Individual DCT entry size.
        ///
        /// 0 - 4 DWORDs,
        ///
        /// 1:15 - Reserved.
        #[inline(always)]
        pub fn entry_size(&self) -> u32 {
            (self.0 >> 28) & 0xf
        }
        /// Index to DCT used during ENTDAA.
        #[inline(always)]
        pub fn table_index(&self) -> u32 {
            (self.0 >> 19) & 0x1f
        }
        /// Max number of DCT entries.
        #[inline(always)]
        pub fn table_size(&self) -> u32 {
            (self.0 >> 12) & 0x7f
        }
        /// DCT entry offset in respect to BASE address.
        #[inline(always)]
        pub fn table_offset(&self) -> u32 {
            (self.0 >> 0) & 0xfff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DctSectionOffsetWriteVal {
            DctSectionOffsetWriteVal(self.0)
        }
    }
    impl From<u32> for DctSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DctSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: DctSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DctSectionOffsetWriteVal(u32);
    impl DctSectionOffsetWriteVal {
        /// Index to DCT used during ENTDAA.
        #[inline(always)]
        pub fn table_index(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 19)) | ((val & 0x1f) << 19))
        }
    }
    impl From<u32> for DctSectionOffsetWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DctSectionOffsetWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DctSectionOffsetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceId0ReadVal(u32);
    impl DeviceId0ReadVal {
        /// Based on table 8 from [DMTF PLDM FM]:
        ///
        /// * 0x00: PCI Vendor
        ///
        /// * 0x1: IANA
        ///
        /// * 0x2: UUID
        ///
        /// * 0x3: PnP Vendor
        ///
        /// * 0x4: ACPI Vendor
        ///
        /// * 0x5: IANA Enterprise Type
        ///
        /// * 0x6-0xFE: Reserved
        ///
        /// * 0xFF: NVMe-MI
        #[inline(always)]
        pub fn desc_type(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// 0x0-0xFF: Total length of Vendor Specific String, 0 indicates not supported
        #[inline(always)]
        pub fn vendor_specific_str_length(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        #[inline(always)]
        pub fn data(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DeviceId0WriteVal {
            DeviceId0WriteVal(self.0)
        }
    }
    impl From<u32> for DeviceId0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceId0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceId0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceId0WriteVal(u32);
    impl DeviceId0WriteVal {
        /// Based on table 8 from [DMTF PLDM FM]:
        ///
        /// * 0x00: PCI Vendor
        ///
        /// * 0x1: IANA
        ///
        /// * 0x2: UUID
        ///
        /// * 0x3: PnP Vendor
        ///
        /// * 0x4: ACPI Vendor
        ///
        /// * 0x5: IANA Enterprise Type
        ///
        /// * 0x6-0xFE: Reserved
        ///
        /// * 0xFF: NVMe-MI
        #[inline(always)]
        pub fn desc_type(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// 0x0-0xFF: Total length of Vendor Specific String, 0 indicates not supported
        #[inline(always)]
        pub fn vendor_specific_str_length(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        #[inline(always)]
        pub fn data(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for DeviceId0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceId0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceId0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceResetReadVal(u32);
    impl DeviceResetReadVal {
        /// * 0x0: No reset
        ///
        /// * 0x1: Reset Device (PCIe Fundamental Reset or equivalent. This is likely bus disruptive)
        ///
        /// * 0x2: Reset Management. This reset will reset the management subsystem. If supported, this reset MUST not be bus disruptive (cause re-enumeration)
        ///
        /// * 0x3-FF: Reserved
        #[inline(always)]
        pub fn reset_ctrl(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// * 0x0: No forced recovery
        ///
        /// * 0x01-0xD: Reserved
        ///
        /// * 0xE: Enter flashless boot mode on next platform reset
        ///
        /// * 0xF: Enter recovery mode on next platform reset
        ///
        /// * 0x10-FF: Reserved
        #[inline(always)]
        pub fn forced_recovery(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// * 0x0: Disable Interface mastering
        ///
        /// * 0x1: Enable Interface mastering
        #[inline(always)]
        pub fn if_ctrl(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DeviceResetWriteVal {
            DeviceResetWriteVal(self.0)
        }
    }
    impl From<u32> for DeviceResetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceResetReadVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceResetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceResetWriteVal(u32);
    impl DeviceResetWriteVal {
        /// * 0x0: No reset
        ///
        /// * 0x1: Reset Device (PCIe Fundamental Reset or equivalent. This is likely bus disruptive)
        ///
        /// * 0x2: Reset Management. This reset will reset the management subsystem. If supported, this reset MUST not be bus disruptive (cause re-enumeration)
        ///
        /// * 0x3-FF: Reserved
        #[inline(always)]
        pub fn reset_ctrl(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// * 0x0: No forced recovery
        ///
        /// * 0x01-0xD: Reserved
        ///
        /// * 0xE: Enter flashless boot mode on next platform reset
        ///
        /// * 0xF: Enter recovery mode on next platform reset
        ///
        /// * 0x10-FF: Reserved
        #[inline(always)]
        pub fn forced_recovery(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// * 0x0: Disable Interface mastering
        ///
        /// * 0x1: Enable Interface mastering
        #[inline(always)]
        pub fn if_ctrl(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
    }
    impl From<u32> for DeviceResetWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceResetWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceResetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceStatus0ReadVal(u32);
    impl DeviceStatus0ReadVal {
        /// * 0x0: Status Pending (Recover Reason Code not populated)
        ///
        /// * 0x1: Device healthy (Recover Reason Code not populated)
        ///
        /// * 0x2: Device Error (“soft” error or other error state) - (Recover Reason Code not populated)
        ///
        /// * 0x3: Recovery mode - ready to accept recovery image - (Recover Reason Code populated)
        ///
        /// * 0x4: Recovery Pending (waiting for activation) - (Recover Reason Code populated)
        ///
        /// * 0x5: Running Recovery Image ( Recover Reason Code not populated)
        ///
        /// * 0x6-0xD: Reserved
        ///
        /// * 0xE: Boot Failure (Recover Reason Code populated)
        ///
        /// * 0xF: Fatal Error (Recover Reason Code not populated)
        ///
        /// * 0x10-FF:Reserved
        #[inline(always)]
        pub fn dev_status(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// * 0x0: No Protocol Error
        ///
        /// * 0x1: Unsupported/Write Command - command is not support or a write to a RO command
        ///
        /// * 0x2: Unsupported Parameter
        ///
        /// * 0x3: Length write error (length of write command is incorrect)
        ///
        /// * 0x4: CRC Error (if supported)
        ///
        /// * 0x5-0xFE: Reserved
        ///
        /// * 0xFF: General Protocol Error - catch all unclassified errors
        #[inline(always)]
        pub fn prot_error(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// * 0x0: No Boot Failure detected (BFNF)
        ///
        /// * 0x1: Generic hardware error (BFGHWE)
        ///
        /// * 0x2: Generic hardware soft error (BFGSE) - soft error may be recoverable
        ///
        /// * 0x3: Self-test failure (BFSTF) (e.g., RSA self test failure, FIPs self test failure,, etc.)
        ///
        /// * 0x4: Corrupted/missing critical data (BFCD)
        ///
        /// * 0x5: Missing/corrupt key manifest (BFKMMC)
        ///
        /// * 0x6: Authentication Failure on key manifest (BFKMAF)
        ///
        /// * 0x7: Anti-rollback failure on key manifest (BFKIAR)
        ///
        /// * 0x8: Missing/corrupt boot loader (first mutable code) firmware image (BFFIMC)
        ///
        /// * 0x9: Authentication failure on boot loader ( 1st mutable code) firmware image (BFFIAF)
        ///
        /// * 0xA: Anti-rollback failure boot loader (1st mutable code) firmware image (BFFIAR)
        ///
        /// * 0xB: Missing/corrupt main/management firmware image (BFMFMC)
        ///
        /// * 0xC: Authentication Failure main/management firmware image (BFMFAF)
        ///
        /// * 0xD: Anti-rollback Failure main/management firmware image (BFMFAR)
        ///
        /// * 0xE: Missing/corrupt recovery firmware (BFRFMC)
        ///
        /// * 0xF: Authentication Failure recovery firmware (BFRFAF)
        ///
        /// * 0x10: Anti-rollback Failure on recovery firmware (BFRFAR)
        ///
        /// * 0x11: Forced Recovery (FR)
        ///
        /// * 0x12: Flashless/Streaming Boot (FSB)
        ///
        /// * 0x13-0x7F: Reserved
        ///
        /// * 0x80-0xFF: Vendor Unique Boot Failure Codes
        #[inline(always)]
        pub fn rec_reason_code(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DeviceStatus0WriteVal {
            DeviceStatus0WriteVal(self.0)
        }
    }
    impl From<u32> for DeviceStatus0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceStatus0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceStatus0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceStatus0WriteVal(u32);
    impl DeviceStatus0WriteVal {
        /// * 0x0: Status Pending (Recover Reason Code not populated)
        ///
        /// * 0x1: Device healthy (Recover Reason Code not populated)
        ///
        /// * 0x2: Device Error (“soft” error or other error state) - (Recover Reason Code not populated)
        ///
        /// * 0x3: Recovery mode - ready to accept recovery image - (Recover Reason Code populated)
        ///
        /// * 0x4: Recovery Pending (waiting for activation) - (Recover Reason Code populated)
        ///
        /// * 0x5: Running Recovery Image ( Recover Reason Code not populated)
        ///
        /// * 0x6-0xD: Reserved
        ///
        /// * 0xE: Boot Failure (Recover Reason Code populated)
        ///
        /// * 0xF: Fatal Error (Recover Reason Code not populated)
        ///
        /// * 0x10-FF:Reserved
        #[inline(always)]
        pub fn dev_status(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// * 0x0: No Protocol Error
        ///
        /// * 0x1: Unsupported/Write Command - command is not support or a write to a RO command
        ///
        /// * 0x2: Unsupported Parameter
        ///
        /// * 0x3: Length write error (length of write command is incorrect)
        ///
        /// * 0x4: CRC Error (if supported)
        ///
        /// * 0x5-0xFE: Reserved
        ///
        /// * 0xFF: General Protocol Error - catch all unclassified errors
        #[inline(always)]
        pub fn prot_error(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// * 0x0: No Boot Failure detected (BFNF)
        ///
        /// * 0x1: Generic hardware error (BFGHWE)
        ///
        /// * 0x2: Generic hardware soft error (BFGSE) - soft error may be recoverable
        ///
        /// * 0x3: Self-test failure (BFSTF) (e.g., RSA self test failure, FIPs self test failure,, etc.)
        ///
        /// * 0x4: Corrupted/missing critical data (BFCD)
        ///
        /// * 0x5: Missing/corrupt key manifest (BFKMMC)
        ///
        /// * 0x6: Authentication Failure on key manifest (BFKMAF)
        ///
        /// * 0x7: Anti-rollback failure on key manifest (BFKIAR)
        ///
        /// * 0x8: Missing/corrupt boot loader (first mutable code) firmware image (BFFIMC)
        ///
        /// * 0x9: Authentication failure on boot loader ( 1st mutable code) firmware image (BFFIAF)
        ///
        /// * 0xA: Anti-rollback failure boot loader (1st mutable code) firmware image (BFFIAR)
        ///
        /// * 0xB: Missing/corrupt main/management firmware image (BFMFMC)
        ///
        /// * 0xC: Authentication Failure main/management firmware image (BFMFAF)
        ///
        /// * 0xD: Anti-rollback Failure main/management firmware image (BFMFAR)
        ///
        /// * 0xE: Missing/corrupt recovery firmware (BFRFMC)
        ///
        /// * 0xF: Authentication Failure recovery firmware (BFRFAF)
        ///
        /// * 0x10: Anti-rollback Failure on recovery firmware (BFRFAR)
        ///
        /// * 0x11: Forced Recovery (FR)
        ///
        /// * 0x12: Flashless/Streaming Boot (FSB)
        ///
        /// * 0x13-0x7F: Reserved
        ///
        /// * 0x80-0xFF: Vendor Unique Boot Failure Codes
        #[inline(always)]
        pub fn rec_reason_code(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for DeviceStatus0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceStatus0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceStatus0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceStatus1ReadVal(u32);
    impl DeviceStatus1ReadVal {
        /// 0-4095: Incrementing number (counter wraps)
        #[inline(always)]
        pub fn heartbeat(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// 0-248: Length in bytes of just VENDOR_STATUS. Zero indicates no vendor status and zero additional bytes.
        #[inline(always)]
        pub fn vendor_status_length(&self) -> u32 {
            (self.0 >> 16) & 0x1ff
        }
        #[inline(always)]
        pub fn vendor_status(&self) -> u32 {
            (self.0 >> 25) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DeviceStatus1WriteVal {
            DeviceStatus1WriteVal(self.0)
        }
    }
    impl From<u32> for DeviceStatus1ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceStatus1ReadVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceStatus1ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DeviceStatus1WriteVal(u32);
    impl DeviceStatus1WriteVal {
        /// 0-4095: Incrementing number (counter wraps)
        #[inline(always)]
        pub fn heartbeat(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// 0-248: Length in bytes of just VENDOR_STATUS. Zero indicates no vendor status and zero additional bytes.
        #[inline(always)]
        pub fn vendor_status_length(self, val: u32) -> Self {
            Self((self.0 & !(0x1ff << 16)) | ((val & 0x1ff) << 16))
        }
        #[inline(always)]
        pub fn vendor_status(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 25)) | ((val & 0x7f) << 25))
        }
    }
    impl From<u32> for DeviceStatus1WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DeviceStatus1WriteVal> for u32 {
        #[inline(always)]
        fn from(val: DeviceStatus1WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseHiReadVal(u32);
    impl DevCtxBaseHiReadVal {
        #[inline(always)]
        pub fn base_hi(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DevCtxBaseHiWriteVal {
            DevCtxBaseHiWriteVal(self.0)
        }
    }
    impl From<u32> for DevCtxBaseHiReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseHiReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseHiReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseHiWriteVal(u32);
    impl DevCtxBaseHiWriteVal {
        #[inline(always)]
        pub fn base_hi(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for DevCtxBaseHiWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseHiWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseHiWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseLoReadVal(u32);
    impl DevCtxBaseLoReadVal {
        #[inline(always)]
        pub fn base_lo(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> DevCtxBaseLoWriteVal {
            DevCtxBaseLoWriteVal(self.0)
        }
    }
    impl From<u32> for DevCtxBaseLoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseLoReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseLoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxBaseLoWriteVal(u32);
    impl DevCtxBaseLoWriteVal {
        #[inline(always)]
        pub fn base_lo(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for DevCtxBaseLoWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxBaseLoWriteVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxBaseLoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DevCtxSgReadVal(u32);
    impl DevCtxSgReadVal {
        /// Buffer vs list pointer in device context:
        ///
        /// 0 - continuous physical memory region,
        ///
        /// 1 - pointer to SG descriptor list.
        #[inline(always)]
        pub fn blp(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Number of SG entries.
        #[inline(always)]
        pub fn list_size(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for DevCtxSgReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DevCtxSgReadVal> for u32 {
        #[inline(always)]
        fn from(val: DevCtxSgReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderReadVal(u32);
    impl ExtcapHeaderReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExtCapsSectionOffsetReadVal(u32);
    impl ExtCapsSectionOffsetReadVal {
        /// Extended Capabilities section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for ExtCapsSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtCapsSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtCapsSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcCapabilitiesReadVal(u32);
    impl HcCapabilitiesReadVal {
        /// Device context memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_dc_en(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// DMA only: IBI status and IBI Data rings memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_ibi_en(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// DMA only: Command and Response rings memory:
        ///
        /// 0 - must be physically continuous
        ///
        /// 1 - controller supports scatter-gather
        #[inline(always)]
        pub fn sg_capability_cr_en(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Size and structure of the Command Descriptor:
        ///
        /// 2'b0: 2 DWORDs,
        ///
        /// all other reserved.
        #[inline(always)]
        pub fn cmd_size(&self) -> u32 {
            (self.0 >> 20) & 3
        }
        /// Controller command scheduling:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn scheduled_commands_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Controller IBI credit count:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn ibi_credit_count_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Controller IBI data abort:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn ibi_data_abort_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// CCC with defining byte:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn cmd_ccc_defbyte(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// HDR-Ternary transfers:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn hdr_ts_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// HDR-DDR transfers:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn hdr_ddr_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Switching from active to standby mode:
        ///
        /// 0 - not supported, this controller is always active on I3C
        ///
        /// 1- supported, this controller can hand off I3C to secondary controller
        #[inline(always)]
        pub fn standby_cr_cap(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Automatic read command on IBI:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn auto_command(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Controller combined command:
        ///
        /// 0 - not supported
        ///
        /// 1 - supported
        #[inline(always)]
        pub fn combo_command(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
    }
    impl From<u32> for HcCapabilitiesReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcCapabilitiesReadVal> for u32 {
        #[inline(always)]
        fn from(val: HcCapabilitiesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcControlReadVal(u32);
    impl HcControlReadVal {
        /// Host Controller Bus Enable
        #[inline(always)]
        pub fn bus_enable(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Host Controller Resume:
        ///
        /// 0 - Controller is running
        ///
        /// 1 - Controller is suspended
        ///
        /// Write 1 to resume Controller operations.
        #[inline(always)]
        pub fn resume(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Host Controller Abort when set to 1
        #[inline(always)]
        pub fn abort(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Halt on Command Sequence Timeout when set to 1
        #[inline(always)]
        pub fn halt_on_cmd_seq_timeout(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Hot-Join ACK/NACK Control:
        ///
        /// 0 - ACK Hot-Join request
        ///
        /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
        #[inline(always)]
        pub fn hot_join_ctrl(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// I2C Device Present on Bus:
        ///
        /// 0 - pure I3C bus
        ///
        /// 1 - legacy I2C devices on the bus
        #[inline(always)]
        pub fn i2_c_dev_present(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// DMA/PIO Mode Selector:
        ///
        /// 0 - DMA
        ///
        /// 1 - PIO
        #[inline(always)]
        pub fn mode_selector(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Data Byte Ordering Mode:
        ///
        /// 0 - Little Endian
        ///
        /// 1 - Big Endian
        #[inline(always)]
        pub fn data_byte_order_mode(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Auto-Command Data Report:
        ///
        /// 0 - coalesced reporting
        ///
        /// 1 - separated reporting
        #[inline(always)]
        pub fn autocmd_data_rpt(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Include I3C Broadcast Address:
        ///
        /// 0 - skips I3C Broadcast Address for private transfers
        ///
        /// 1 - includes I3C Broadcast Address for private transfers
        #[inline(always)]
        pub fn iba_include(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HcControlWriteVal {
            HcControlWriteVal(self.0)
        }
    }
    impl From<u32> for HcControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: HcControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HcControlWriteVal(u32);
    impl HcControlWriteVal {
        /// Host Controller Bus Enable
        #[inline(always)]
        pub fn bus_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Host Controller Resume:
        ///
        /// 0 - Controller is running
        ///
        /// 1 - Controller is suspended
        ///
        /// Write 1 to resume Controller operations.
        #[inline(always)]
        pub fn resume(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Host Controller Abort when set to 1
        #[inline(always)]
        pub fn abort(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Halt on Command Sequence Timeout when set to 1
        #[inline(always)]
        pub fn halt_on_cmd_seq_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Hot-Join ACK/NACK Control:
        ///
        /// 0 - ACK Hot-Join request
        ///
        /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
        #[inline(always)]
        pub fn hot_join_ctrl(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// I2C Device Present on Bus:
        ///
        /// 0 - pure I3C bus
        ///
        /// 1 - legacy I2C devices on the bus
        #[inline(always)]
        pub fn i2_c_dev_present(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Include I3C Broadcast Address:
        ///
        /// 0 - skips I3C Broadcast Address for private transfers
        ///
        /// 1 - includes I3C Broadcast Address for private transfers
        #[inline(always)]
        pub fn iba_include(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for HcControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HcControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HcControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwStatusReadVal(u32);
    impl HwStatusReadVal {
        /// Device temperature is critical (may need reset to clear)
        #[inline(always)]
        pub fn temp_critical(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Hardware Soft Error (may need reset to clear)
        #[inline(always)]
        pub fn soft_err(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn fatal_err(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn reserved_7_3(&self) -> u32 {
            (self.0 >> 3) & 0x1f
        }
        #[inline(always)]
        pub fn vendor_hw_status(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Current temperatureof device in degrees Celsius: Compatible with NVMe-MI command code 0 offset 3.
        ///
        /// * 0x00-0x7e: 0 to 126 C
        ///
        /// * 0x7f: 127 C or higher
        ///
        /// * 0x80: no temperature data, or data is older than 5 seconds
        ///
        /// * 0x81: temperature sensor failure
        ///
        /// * 0x82-0x83: reserved
        ///
        /// * 0xc4: -60 C or lower
        ///
        /// * 0xc5-0xff: -59 to -1 C (in two's complement)
        #[inline(always)]
        pub fn ctemp(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// 0-251: Length in bytes of Vendor Specific Hardware Status.
        #[inline(always)]
        pub fn vendor_hw_status_len(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HwStatusWriteVal {
            HwStatusWriteVal(self.0)
        }
    }
    impl From<u32> for HwStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HwStatusWriteVal(u32);
    impl HwStatusWriteVal {
        /// Device temperature is critical (may need reset to clear)
        #[inline(always)]
        pub fn temp_critical(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Hardware Soft Error (may need reset to clear)
        #[inline(always)]
        pub fn soft_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn reserved_7_3(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 3)) | ((val & 0x1f) << 3))
        }
        #[inline(always)]
        pub fn vendor_hw_status(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Current temperatureof device in degrees Celsius: Compatible with NVMe-MI command code 0 offset 3.
        ///
        /// * 0x00-0x7e: 0 to 126 C
        ///
        /// * 0x7f: 127 C or higher
        ///
        /// * 0x80: no temperature data, or data is older than 5 seconds
        ///
        /// * 0x81: temperature sensor failure
        ///
        /// * 0x82-0x83: reserved
        ///
        /// * 0xc4: -60 C or lower
        ///
        /// * 0xc5-0xff: -59 to -1 C (in two's complement)
        #[inline(always)]
        pub fn ctemp(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        /// 0-251: Length in bytes of Vendor Specific Hardware Status.
        #[inline(always)]
        pub fn vendor_hw_status_len(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
    }
    impl From<u32> for HwStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HwStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiDataAbortCtrlReadVal(u32);
    impl IbiDataAbortCtrlReadVal {
        /// Enable/disable IBI monitoring logic.
        #[inline(always)]
        pub fn ibi_data_abort_mon(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Define which IBI should be aborted:
        ///
        /// 3'b000 - Regular IBI,
        ///
        /// 3'b100 - Autocmd IBI,
        ///
        /// other values - not supported.
        #[inline(always)]
        pub fn match_status_type(&self) -> u32 {
            (self.0 >> 18) & 7
        }
        /// Number of data chunks to be allowed before forced termination:
        ///
        /// 0 - immediate,
        ///
        /// 1:3 - delay by 1-3 data chunks.
        #[inline(always)]
        pub fn after_n_chunks(&self) -> u32 {
            (self.0 >> 16) & 3
        }
        /// IBI target address:
        ///
        /// [15:9] - device address,
        ///
        /// [8] - must always be set to 1'b1
        #[inline(always)]
        pub fn match_ibi_id(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IbiDataAbortCtrlWriteVal {
            IbiDataAbortCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for IbiDataAbortCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiDataAbortCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiDataAbortCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiDataAbortCtrlWriteVal(u32);
    impl IbiDataAbortCtrlWriteVal {
        /// Enable/disable IBI monitoring logic.
        #[inline(always)]
        pub fn ibi_data_abort_mon(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Define which IBI should be aborted:
        ///
        /// 3'b000 - Regular IBI,
        ///
        /// 3'b100 - Autocmd IBI,
        ///
        /// other values - not supported.
        #[inline(always)]
        pub fn match_status_type(self, val: u32) -> Self {
            Self((self.0 & !(7 << 18)) | ((val & 7) << 18))
        }
        /// Number of data chunks to be allowed before forced termination:
        ///
        /// 0 - immediate,
        ///
        /// 1:3 - delay by 1-3 data chunks.
        #[inline(always)]
        pub fn after_n_chunks(self, val: u32) -> Self {
            Self((self.0 & !(3 << 16)) | ((val & 3) << 16))
        }
        /// IBI target address:
        ///
        /// [15:9] - device address,
        ///
        /// [8] - must always be set to 1'b1
        #[inline(always)]
        pub fn match_ibi_id(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for IbiDataAbortCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiDataAbortCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IbiDataAbortCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiNotifyCtrlReadVal(u32);
    impl IbiNotifyCtrlReadVal {
        /// Notify about rejected IBI:
        ///
        /// 0 - do not enqueue rejected IBI,
        ///
        /// 1 = enqueue rejected IBI on IBI queue/ring.
        #[inline(always)]
        pub fn notify_ibi_rejected(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Notify about rejected controller role request:
        ///
        /// 0 - do not enqueue rejected CRR,
        ///
        /// 1 = enqueue rejected CRR on IBI queue/ring.
        #[inline(always)]
        pub fn notify_crr_rejected(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Notify about rejected hot-join:
        ///
        /// 0 - do not enqueue rejected HJ,
        ///
        /// 1 = enqueue rejected HJ on IBI queue/ring.
        #[inline(always)]
        pub fn notify_hj_rejected(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IbiNotifyCtrlWriteVal {
            IbiNotifyCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for IbiNotifyCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiNotifyCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiNotifyCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiNotifyCtrlWriteVal(u32);
    impl IbiNotifyCtrlWriteVal {
        /// Notify about rejected IBI:
        ///
        /// 0 - do not enqueue rejected IBI,
        ///
        /// 1 = enqueue rejected IBI on IBI queue/ring.
        #[inline(always)]
        pub fn notify_ibi_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Notify about rejected controller role request:
        ///
        /// 0 - do not enqueue rejected CRR,
        ///
        /// 1 = enqueue rejected CRR on IBI queue/ring.
        #[inline(always)]
        pub fn notify_crr_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Notify about rejected hot-join:
        ///
        /// 0 - do not enqueue rejected HJ,
        ///
        /// 1 = enqueue rejected HJ on IBI queue/ring.
        #[inline(always)]
        pub fn notify_hj_rejected(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for IbiNotifyCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiNotifyCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IbiNotifyCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IbiTtiQueueSizeReadVal(u32);
    impl IbiTtiQueueSizeReadVal {
        /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn ibi_tti_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for IbiTtiQueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IbiTtiQueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: IbiTtiQueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoCtrl0ReadVal(u32);
    impl IndirectFifoCtrl0ReadVal {
        /// This register selects a region within the device. Read/write access is through address
        /// spaces. Each space represents a FIFO.
        /// Component Memory Space (CMS):
        ///
        /// * 0-255: Address region within a device.
        #[inline(always)]
        pub fn cms(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Reset (Write 1 Clear):
        ///
        /// * 0x0: idle
        ///
        /// * 0x1: reset Write Index and Read Index to initial value.
        ///
        /// * 0x2 to 0xFF: reserved
        #[inline(always)]
        pub fn reset(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IndirectFifoCtrl0WriteVal {
            IndirectFifoCtrl0WriteVal(self.0)
        }
    }
    impl From<u32> for IndirectFifoCtrl0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoCtrl0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoCtrl0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoCtrl0WriteVal(u32);
    impl IndirectFifoCtrl0WriteVal {
        /// This register selects a region within the device. Read/write access is through address
        /// spaces. Each space represents a FIFO.
        /// Component Memory Space (CMS):
        ///
        /// * 0-255: Address region within a device.
        #[inline(always)]
        pub fn cms(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// Reset (Write 1 Clear):
        ///
        /// * 0x0: idle
        ///
        /// * 0x1: reset Write Index and Read Index to initial value.
        ///
        /// * 0x2 to 0xFF: reserved
        #[inline(always)]
        pub fn reset(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for IndirectFifoCtrl0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoCtrl0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoCtrl0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IndirectFifoStatus0ReadVal(u32);
    impl IndirectFifoStatus0ReadVal {
        /// If set, FIFO is empty
        #[inline(always)]
        pub fn empty(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// If set, FIFO is full
        #[inline(always)]
        pub fn full(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Memory Region Type:
        ///
        /// * 0b000: Code space for recovery. (write only)
        ///
        /// * 0b001: Log uses the defined debug format (read only)
        ///
        /// * 0b100: Vendor Defined Region (write only)
        ///
        /// * 0b101: Vendor Defined Region (read only)
        ///
        /// * 0b111: Unsupported Region (address space out of range)
        #[inline(always)]
        pub fn region_type(&self) -> u32 {
            (self.0 >> 8) & 7
        }
    }
    impl From<u32> for IndirectFifoStatus0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IndirectFifoStatus0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: IndirectFifoStatus0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableReadVal(u32);
    impl InterruptEnableReadVal {
        /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT`
        #[inline(always)]
        pub fn transfer_err_stat_en(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT`
        #[inline(always)]
        pub fn transfer_abort_stat_en(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `IBI_DONE`
        #[inline(always)]
        pub fn ibi_done_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
        #[inline(always)]
        pub fn ibi_thld_stat_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn rx_desc_thld_stat_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn tx_desc_thld_stat_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn rx_data_thld_stat_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn tx_data_thld_stat_en(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_EN`
        #[inline(always)]
        pub fn tx_desc_timeout_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_EN`
        #[inline(always)]
        pub fn rx_desc_timeout_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TX_DESC_STAT_EN`
        #[inline(always)]
        pub fn tx_desc_stat_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `RX_DESC_STAT_EN`
        #[inline(always)]
        pub fn rx_desc_stat_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableWriteVal {
            InterruptEnableWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableWriteVal(u32);
    impl InterruptEnableWriteVal {
        /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT`
        #[inline(always)]
        pub fn transfer_err_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT`
        #[inline(always)]
        pub fn transfer_abort_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Enables the corresponding interrupt bit `IBI_DONE`
        #[inline(always)]
        pub fn ibi_done_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
        #[inline(always)]
        pub fn ibi_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn rx_desc_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
        #[inline(always)]
        pub fn tx_desc_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn rx_data_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
        #[inline(always)]
        pub fn tx_data_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_EN`
        #[inline(always)]
        pub fn tx_desc_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_EN`
        #[inline(always)]
        pub fn rx_desc_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enables the corresponding interrupt bit `TX_DESC_STAT_EN`
        #[inline(always)]
        pub fn tx_desc_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enables the corresponding interrupt bit `RX_DESC_STAT_EN`
        #[inline(always)]
        pub fn rx_desc_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptForceReadVal(u32);
    impl InterruptForceReadVal {
        /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT_FORCE`
        #[inline(always)]
        pub fn transfer_err_stat_force(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT_FORCE`
        #[inline(always)]
        pub fn transfer_abort_stat_force(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `IBI_DONE_FORCE`
        #[inline(always)]
        pub fn ibi_done_force(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
        #[inline(always)]
        pub fn ibi_thld_force(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_desc_thld_force(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_desc_thld_force(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_data_thld_force(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_data_thld_force(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_FORCE`
        #[inline(always)]
        pub fn tx_desc_timeout_force(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_FORCE`
        #[inline(always)]
        pub fn rx_desc_timeout_force(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `TX_DESC_STAT_FORCE`
        #[inline(always)]
        pub fn tx_desc_stat_force(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enables the corresponding interrupt bit `RX_DESC_STAT_FORCE`
        #[inline(always)]
        pub fn rx_desc_stat_force(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptForceWriteVal {
            InterruptForceWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptForceReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptForceReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptForceReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptForceWriteVal(u32);
    impl InterruptForceWriteVal {
        /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT_FORCE`
        #[inline(always)]
        pub fn transfer_err_stat_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT_FORCE`
        #[inline(always)]
        pub fn transfer_abort_stat_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Enables the corresponding interrupt bit `IBI_DONE_FORCE`
        #[inline(always)]
        pub fn ibi_done_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
        #[inline(always)]
        pub fn ibi_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_desc_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_desc_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn rx_data_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
        #[inline(always)]
        pub fn tx_data_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_FORCE`
        #[inline(always)]
        pub fn tx_desc_timeout_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_FORCE`
        #[inline(always)]
        pub fn rx_desc_timeout_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enables the corresponding interrupt bit `TX_DESC_STAT_FORCE`
        #[inline(always)]
        pub fn tx_desc_stat_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enables the corresponding interrupt bit `RX_DESC_STAT_FORCE`
        #[inline(always)]
        pub fn rx_desc_stat_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStatusReadVal(u32);
    impl InterruptStatusReadVal {
        /// Bus error occurred
        #[inline(always)]
        pub fn transfer_err_stat(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Bus aborted transaction
        #[inline(always)]
        pub fn transfer_abort_stat(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// Contains the interrupt number of any pending interrupt, or 0 if no interrupts are pending. This encoding allows for up to 15 numbered interrupts. If more than one interrupt is set, then the highest priority interrupt shall be returned.
        #[inline(always)]
        pub fn pending_interrupt(&self) -> u32 {
            (self.0 >> 15) & 0xf
        }
        /// IBI is done, check LAST_IBI_STATUS for result.
        #[inline(always)]
        pub fn ibi_done(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
        #[inline(always)]
        pub fn ibi_thld_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
        #[inline(always)]
        pub fn rx_desc_thld_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
        #[inline(always)]
        pub fn tx_desc_thld_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
        #[inline(always)]
        pub fn rx_data_thld_stat(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
        #[inline(always)]
        pub fn tx_data_thld_stat(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// Pending Read was NACK’ed, because the `TX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn tx_desc_timeout(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Pending Write was NACK’ed, because the `RX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn rx_desc_timeout(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// There is a pending Read Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
        #[inline(always)]
        pub fn tx_desc_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// There is a pending Write Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
        #[inline(always)]
        pub fn rx_desc_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStatusWriteVal {
            InterruptStatusWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStatusWriteVal(u32);
    impl InterruptStatusWriteVal {
        /// Bus error occurred
        #[inline(always)]
        pub fn transfer_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Bus aborted transaction
        #[inline(always)]
        pub fn transfer_abort_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
        }
        /// Contains the interrupt number of any pending interrupt, or 0 if no interrupts are pending. This encoding allows for up to 15 numbered interrupts. If more than one interrupt is set, then the highest priority interrupt shall be returned.
        #[inline(always)]
        pub fn pending_interrupt(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 15)) | ((val & 0xf) << 15))
        }
        /// IBI is done, check LAST_IBI_STATUS for result.
        #[inline(always)]
        pub fn ibi_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
        #[inline(always)]
        pub fn ibi_thld_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
        #[inline(always)]
        pub fn rx_desc_thld_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
        #[inline(always)]
        pub fn tx_desc_thld_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
        #[inline(always)]
        pub fn rx_data_thld_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
        #[inline(always)]
        pub fn tx_data_thld_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// Pending Read was NACK’ed, because the `TX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn tx_desc_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Pending Write was NACK’ed, because the `RX_DESC_STAT` event was not handled in time
        #[inline(always)]
        pub fn rx_desc_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// There is a pending Read Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
        #[inline(always)]
        pub fn tx_desc_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// There is a pending Write Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
        #[inline(always)]
        pub fn rx_desc_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InterruptStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrForceWriteVal(u32);
    impl IntrForceWriteVal {
        /// Force SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Force HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Force HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Force HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Force HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrSignalEnableReadVal(u32);
    impl IntrSignalEnableReadVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_signal_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_signal_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_signal_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_signal_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_signal_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrSignalEnableWriteVal {
            IntrSignalEnableWriteVal(self.0)
        }
    }
    impl From<u32> for IntrSignalEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrSignalEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrSignalEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrSignalEnableWriteVal(u32);
    impl IntrSignalEnableWriteVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable HC_SEQ_CANCEL_STAT interrupt.
        #[inline(always)]
        pub fn hc_seq_cancel_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable HC_INTERNAL_ERR_STAT interrupt.
        #[inline(always)]
        pub fn hc_internal_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrSignalEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrSignalEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrSignalEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusReadVal(u32);
    impl IntrStatusReadVal {
        /// Scheduled commands could be executed due to controller being busy.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Command timeout after prolonged stall.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Clock stalled due to lack of commands.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Controller had to cancel command sequence.
        #[inline(always)]
        pub fn hc_seq_cancel_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Controller internal unrecoverable error.
        #[inline(always)]
        pub fn hc_internal_err_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrStatusWriteVal {
            IntrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for IntrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusWriteVal(u32);
    impl IntrStatusWriteVal {
        /// Scheduled commands could be executed due to controller being busy.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Command timeout after prolonged stall.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Clock stalled due to lack of commands.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Controller had to cancel command sequence.
        #[inline(always)]
        pub fn hc_seq_cancel_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Controller internal unrecoverable error.
        #[inline(always)]
        pub fn hc_internal_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusEnableReadVal(u32);
    impl IntrStatusEnableReadVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Enable HC_SEQ_CANCEL_STAT monitoring.
        #[inline(always)]
        pub fn hc_seq_cancel_stat_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// Enable HC_INTERNAL_ERR_STAT monitoring.
        #[inline(always)]
        pub fn hc_internal_err_stat_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> IntrStatusEnableWriteVal {
            IntrStatusEnableWriteVal(self.0)
        }
    }
    impl From<u32> for IntrStatusEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntrStatusEnableWriteVal(u32);
    impl IntrStatusEnableWriteVal {
        /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
        #[inline(always)]
        pub fn sched_cmd_missed_tick_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
        #[inline(always)]
        pub fn hc_err_cmd_seq_timeout_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
        #[inline(always)]
        pub fn hc_warn_cmd_seq_stall_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Enable HC_SEQ_CANCEL_STAT monitoring.
        #[inline(always)]
        pub fn hc_seq_cancel_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// Enable HC_INTERNAL_ERR_STAT monitoring.
        #[inline(always)]
        pub fn hc_internal_err_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for IntrStatusEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntrStatusEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: IntrStatusEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct IntCtrlCmdsEnReadVal(u32);
    impl IntCtrlCmdsEnReadVal {
        /// Bitmask of supported MIPI commands.
        #[inline(always)]
        pub fn mipi_cmds_supported(&self) -> u32 {
            (self.0 >> 1) & 0x7fff
        }
        /// Internal Control Commands:
        ///
        /// 1 - some or all internals commands sub-commands are supported,
        ///
        /// 0 - illegal.
        #[inline(always)]
        pub fn icc_support(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for IntCtrlCmdsEnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<IntCtrlCmdsEnReadVal> for u32 {
        #[inline(always)]
        fn from(val: IntCtrlCmdsEnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioControlReadVal(u32);
    impl PioControlReadVal {
        /// Stop current command descriptor execution forcefully and hold remaining commands.
        /// 1 - Request PIO Abort,
        /// 0 - Resume PIO execution
        #[inline(always)]
        pub fn abort(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Run/Stop execution of enqueued commands.
        /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
        /// 1 - PIO Queue start request,
        /// 0 - PIO Queue stop request.
        #[inline(always)]
        pub fn rs(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
        /// 1 - PIO queue enable request,
        /// 0 - PIO queue disable request
        #[inline(always)]
        pub fn enable(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioControlWriteVal {
            PioControlWriteVal(self.0)
        }
    }
    impl From<u32> for PioControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioControlWriteVal(u32);
    impl PioControlWriteVal {
        /// Stop current command descriptor execution forcefully and hold remaining commands.
        /// 1 - Request PIO Abort,
        /// 0 - Resume PIO execution
        #[inline(always)]
        pub fn abort(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Run/Stop execution of enqueued commands.
        /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
        /// 1 - PIO Queue start request,
        /// 0 - PIO Queue stop request.
        #[inline(always)]
        pub fn rs(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
        /// 1 - PIO queue enable request,
        /// 0 - PIO queue disable request
        #[inline(always)]
        pub fn enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrForceWriteVal(u32);
    impl PioIntrForceWriteVal {
        /// Force transfer error
        #[inline(always)]
        pub fn transfer_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Force transfer aborted
        #[inline(always)]
        pub fn transfer_abort_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Force response queue interrupt
        #[inline(always)]
        pub fn resp_ready_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Force command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Force IBI queue interrupt
        #[inline(always)]
        pub fn ibi_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Force RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Force TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrSignalEnableReadVal(u32);
    impl PioIntrSignalEnableReadVal {
        /// Enable transfer error interrupt
        #[inline(always)]
        pub fn transfer_err_signal_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable transfer abort interrupt
        #[inline(always)]
        pub fn transfer_abort_signal_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable response ready interrupt
        #[inline(always)]
        pub fn resp_ready_signal_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_signal_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable IBI queue interrupt
        #[inline(always)]
        pub fn ibi_status_thld_signal_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_signal_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_signal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrSignalEnableWriteVal {
            PioIntrSignalEnableWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrSignalEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrSignalEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrSignalEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrSignalEnableWriteVal(u32);
    impl PioIntrSignalEnableWriteVal {
        /// Enable transfer error interrupt
        #[inline(always)]
        pub fn transfer_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable transfer abort interrupt
        #[inline(always)]
        pub fn transfer_abort_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable response ready interrupt
        #[inline(always)]
        pub fn resp_ready_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable command queue interrupt
        #[inline(always)]
        pub fn cmd_queue_ready_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable IBI queue interrupt
        #[inline(always)]
        pub fn ibi_status_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable RX queue interrupt
        #[inline(always)]
        pub fn rx_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable TX queue interrupt
        #[inline(always)]
        pub fn tx_thld_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrSignalEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrSignalEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrSignalEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusReadVal(u32);
    impl PioIntrStatusReadVal {
        /// Transfer error
        #[inline(always)]
        pub fn transfer_err_stat(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Transfer aborted
        #[inline(always)]
        pub fn transfer_abort_stat(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Response queue fulfils RESP_BUF_THLD
        #[inline(always)]
        pub fn resp_ready_stat(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Command queue fulfils CMD_EMPTY_BUF_THLD
        #[inline(always)]
        pub fn cmd_queue_ready_stat(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// IBI queue fulfils IBI_STATUS_THLD
        #[inline(always)]
        pub fn ibi_status_thld_stat(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// RX queue fulfils RX_BUF_THLD
        #[inline(always)]
        pub fn rx_thld_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// TX queue fulfils TX_BUF_THLD
        #[inline(always)]
        pub fn tx_thld_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrStatusWriteVal {
            PioIntrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusWriteVal(u32);
    impl PioIntrStatusWriteVal {
        /// Transfer error
        #[inline(always)]
        pub fn transfer_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Transfer aborted
        #[inline(always)]
        pub fn transfer_abort_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for PioIntrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusEnableReadVal(u32);
    impl PioIntrStatusEnableReadVal {
        /// Enable transfer error monitoring
        #[inline(always)]
        pub fn transfer_err_stat_en(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// Enable transfer abort monitoring
        #[inline(always)]
        pub fn transfer_abort_stat_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable response queue monitoring
        #[inline(always)]
        pub fn resp_ready_stat_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable command queue monitoring
        #[inline(always)]
        pub fn cmd_queue_ready_stat_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable IBI queue monitoring
        #[inline(always)]
        pub fn ibi_status_thld_stat_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable RX queue monitoring
        #[inline(always)]
        pub fn rx_thld_stat_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable TX queue monitoring
        #[inline(always)]
        pub fn tx_thld_stat_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> PioIntrStatusEnableWriteVal {
            PioIntrStatusEnableWriteVal(self.0)
        }
    }
    impl From<u32> for PioIntrStatusEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioIntrStatusEnableWriteVal(u32);
    impl PioIntrStatusEnableWriteVal {
        /// Enable transfer error monitoring
        #[inline(always)]
        pub fn transfer_err_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// Enable transfer abort monitoring
        #[inline(always)]
        pub fn transfer_abort_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable response queue monitoring
        #[inline(always)]
        pub fn resp_ready_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable command queue monitoring
        #[inline(always)]
        pub fn cmd_queue_ready_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable IBI queue monitoring
        #[inline(always)]
        pub fn ibi_status_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable RX queue monitoring
        #[inline(always)]
        pub fn rx_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable TX queue monitoring
        #[inline(always)]
        pub fn tx_thld_stat_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PioIntrStatusEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioIntrStatusEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: PioIntrStatusEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PioSectionOffsetReadVal(u32);
    impl PioSectionOffsetReadVal {
        /// PIO section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for PioSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PioSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: PioSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PresentStateReadVal(u32);
    impl PresentStateReadVal {
        /// Controller I3C state:
        ///
        /// 0 - not bus owner
        ///
        /// 1 - bus owner
        #[inline(always)]
        pub fn ac_current_own(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
    }
    impl From<u32> for PresentStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PresentStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: PresentStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ProtCap2ReadVal(u32);
    impl ProtCap2ReadVal {
        /// * Byte 0: Major version number = 0x1
        ///
        /// * Byte 1: Minor version number = 0x1
        #[inline(always)]
        pub fn rec_prot_version(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Agent capabilities:
        ///
        /// * bit 0: Identification (DEVICE_ID structure)
        ///
        /// * bit 1: Forced Recovery (From RESET)
        ///
        /// * bit 2: Mgmt reset (From RESET)
        ///
        /// * bit 3: Device Reset (From RESET)
        ///
        /// * bit 4: Device status (DEVICE_STATUS)
        ///
        /// * bit 5: Recovery memory access (INDIRECT_CTRL)
        ///
        /// * bit 6: Local C-image support
        ///
        /// * bit 7: Push C-image support
        ///
        /// * bit 8: Interface isolation
        ///
        /// * bit 9: Hardware status
        ///
        /// * bit 10: Vendor command
        ///
        /// * bit 11: Flashless boot (From RESET)
        ///
        /// * bit 12: FIFO CMS support (INDIRECT_FIFO_CTRL)
        ///
        /// * bits 13-15: Reserved
        #[inline(always)]
        pub fn agent_caps(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ProtCap2WriteVal {
            ProtCap2WriteVal(self.0)
        }
    }
    impl From<u32> for ProtCap2ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ProtCap2ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ProtCap2ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ProtCap2WriteVal(u32);
    impl ProtCap2WriteVal {
        /// * Byte 0: Major version number = 0x1
        ///
        /// * Byte 1: Minor version number = 0x1
        #[inline(always)]
        pub fn rec_prot_version(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// Agent capabilities:
        ///
        /// * bit 0: Identification (DEVICE_ID structure)
        ///
        /// * bit 1: Forced Recovery (From RESET)
        ///
        /// * bit 2: Mgmt reset (From RESET)
        ///
        /// * bit 3: Device Reset (From RESET)
        ///
        /// * bit 4: Device status (DEVICE_STATUS)
        ///
        /// * bit 5: Recovery memory access (INDIRECT_CTRL)
        ///
        /// * bit 6: Local C-image support
        ///
        /// * bit 7: Push C-image support
        ///
        /// * bit 8: Interface isolation
        ///
        /// * bit 9: Hardware status
        ///
        /// * bit 10: Vendor command
        ///
        /// * bit 11: Flashless boot (From RESET)
        ///
        /// * bit 12: FIFO CMS support (INDIRECT_FIFO_CTRL)
        ///
        /// * bits 13-15: Reserved
        #[inline(always)]
        pub fn agent_caps(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for ProtCap2WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ProtCap2WriteVal> for u32 {
        #[inline(always)]
        fn from(val: ProtCap2WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ProtCap3ReadVal(u32);
    impl ProtCap3ReadVal {
        /// 0-255: The total number of component memory space (CMS) regions a device supports. This number includes any logging, code and vendor defined regions
        #[inline(always)]
        pub fn num_of_cms_regions(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// 0-255: Maximum response time in 2^x microseconds(us).
        #[inline(always)]
        pub fn max_resp_time(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// 0-255: Heartbeat period, 2^x microseconds (us), 0 indicates not supported
        #[inline(always)]
        pub fn heartbeat_period(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ProtCap3WriteVal {
            ProtCap3WriteVal(self.0)
        }
    }
    impl From<u32> for ProtCap3ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ProtCap3ReadVal> for u32 {
        #[inline(always)]
        fn from(val: ProtCap3ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ProtCap3WriteVal(u32);
    impl ProtCap3WriteVal {
        /// 0-255: The total number of component memory space (CMS) regions a device supports. This number includes any logging, code and vendor defined regions
        #[inline(always)]
        pub fn num_of_cms_regions(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// 0-255: Maximum response time in 2^x microseconds(us).
        #[inline(always)]
        pub fn max_resp_time(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// 0-255: Heartbeat period, 2^x microseconds (us), 0 indicates not supported
        #[inline(always)]
        pub fn heartbeat_period(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
    }
    impl From<u32> for ProtCap3WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ProtCap3WriteVal> for u32 {
        #[inline(always)]
        fn from(val: ProtCap3WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueSizeReadVal(u32);
    impl QueueSizeReadVal {
        /// TX queue size is equal to 2^(N+1), where N is this field value
        #[inline(always)]
        pub fn tx_data_buffer_size(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// RX queue size is equal to 2^(N+1), where N is this field value
        #[inline(always)]
        pub fn rx_data_buffer_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// IBI Queue size is equal to N
        #[inline(always)]
        pub fn ibi_status_size(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Command/Response queue size is equal to N
        #[inline(always)]
        pub fn cr_queue_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for QueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlReadVal(u32);
    impl QueueThldCtrlReadVal {
        /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn ibi_status_thld(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// IBI Queue data segment size. Valida values are 1:63
        #[inline(always)]
        pub fn ibi_data_segment_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn resp_buf_thld(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
        #[inline(always)]
        pub fn cmd_empty_buf_thld(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> QueueThldCtrlWriteVal {
            QueueThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for QueueThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct QueueThldCtrlWriteVal(u32);
    impl QueueThldCtrlWriteVal {
        /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn ibi_status_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// IBI Queue data segment size. Valida values are 1:63
        #[inline(always)]
        pub fn ibi_data_segment_size(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
        #[inline(always)]
        pub fn resp_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
        #[inline(always)]
        pub fn cmd_empty_buf_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for QueueThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<QueueThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: QueueThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecoveryCtrlReadVal(u32);
    impl RecoveryCtrlReadVal {
        /// * 0-255: Selects a component memory space where the recovery image is. 0 is the default
        #[inline(always)]
        pub fn cms(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// * 0x0: No operation
        ///
        /// * 0x1: Use Recovery Image from memory window (CMS)
        ///
        /// * 0x2: Use Recovery Image stored on device (C-image)
        ///
        /// * 0x3-FF: reserved
        #[inline(always)]
        pub fn rec_img_sel(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// * 0x0: do not activate recovery image - after activation device will report this code.
        ///
        /// * 0xF: Activate recovery image
        ///
        /// * 0x10-FF-reserved
        #[inline(always)]
        pub fn activate_rec_img(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RecoveryCtrlWriteVal {
            RecoveryCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for RecoveryCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecoveryCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: RecoveryCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecoveryCtrlWriteVal(u32);
    impl RecoveryCtrlWriteVal {
        /// * 0-255: Selects a component memory space where the recovery image is. 0 is the default
        #[inline(always)]
        pub fn cms(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// * 0x0: No operation
        ///
        /// * 0x1: Use Recovery Image from memory window (CMS)
        ///
        /// * 0x2: Use Recovery Image stored on device (C-image)
        ///
        /// * 0x3-FF: reserved
        #[inline(always)]
        pub fn rec_img_sel(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// * 0x0: do not activate recovery image - after activation device will report this code.
        ///
        /// * 0xF: Activate recovery image
        ///
        /// * 0x10-FF-reserved
        #[inline(always)]
        pub fn activate_rec_img(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
    }
    impl From<u32> for RecoveryCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecoveryCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RecoveryCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecoveryStatusReadVal(u32);
    impl RecoveryStatusReadVal {
        /// * 0x0: Not in recovery mode
        ///
        /// * 0x1: Awaiting recovery image
        ///
        /// * 0x2: Booting recovery image
        ///
        /// * 0x3: Recovery successful
        ///
        /// * 0xc: Recovery failed
        ///
        /// * 0xd: Recovery image authentication error
        ///
        /// * 0xe: Error entering Recovery mode (might be administratively disabled)
        ///
        /// * 0xf: Invalid component address space
        #[inline(always)]
        pub fn dev_rec_status(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        #[inline(always)]
        pub fn rec_img_index(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        #[inline(always)]
        pub fn vendor_specific_status(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RecoveryStatusWriteVal {
            RecoveryStatusWriteVal(self.0)
        }
    }
    impl From<u32> for RecoveryStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecoveryStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: RecoveryStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecoveryStatusWriteVal(u32);
    impl RecoveryStatusWriteVal {
        /// * 0x0: Not in recovery mode
        ///
        /// * 0x1: Awaiting recovery image
        ///
        /// * 0x2: Booting recovery image
        ///
        /// * 0x3: Recovery successful
        ///
        /// * 0xc: Recovery failed
        ///
        /// * 0xd: Recovery image authentication error
        ///
        /// * 0xe: Error entering Recovery mode (might be administratively disabled)
        ///
        /// * 0xf: Invalid component address space
        #[inline(always)]
        pub fn dev_rec_status(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        #[inline(always)]
        pub fn rec_img_index(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
        #[inline(always)]
        pub fn vendor_specific_status(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for RecoveryStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecoveryStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RecoveryStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlReadVal(u32);
    impl ResetControlReadVal {
        /// Clear IBI queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn ibi_queue_rst(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Clear RX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn rx_fifo_rst(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Clear TX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn tx_fifo_rst(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Clear response queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn resp_queue_rst(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Clear command queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn cmd_queue_rst(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Reset controller from software.
        #[inline(always)]
        pub fn soft_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetControlWriteVal {
            ResetControlWriteVal(self.0)
        }
    }
    impl From<u32> for ResetControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ResetControlWriteVal(u32);
    impl ResetControlWriteVal {
        /// Clear IBI queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn ibi_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Clear RX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn rx_fifo_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Clear TX FIFO from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn tx_fifo_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Clear response queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn resp_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Clear command queue from software. Valid only in PIO mode.
        #[inline(always)]
        pub fn cmd_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Reset controller from software.
        #[inline(always)]
        pub fn soft_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ResetControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RingHeadersSectionOffsetReadVal(u32);
    impl RingHeadersSectionOffsetReadVal {
        /// DMA ring headers section offset. Invalid if 0.
        #[inline(always)]
        pub fn section_offset(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for RingHeadersSectionOffsetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RingHeadersSectionOffsetReadVal> for u32 {
        #[inline(always)]
        fn from(val: RingHeadersSectionOffsetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadAttrReadVal(u32);
    impl SocPadAttrReadVal {
        /// Select driver strength
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_strength(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Select driver slew rate
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_slew_rate(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SocPadAttrWriteVal {
            SocPadAttrWriteVal(self.0)
        }
    }
    impl From<u32> for SocPadAttrReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadAttrReadVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadAttrReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadAttrWriteVal(u32);
    impl SocPadAttrWriteVal {
        /// Select driver strength
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_strength(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Select driver slew rate
        ///
        /// '0 - lowest
        ///
        /// '1 - highest
        #[inline(always)]
        pub fn drive_slew_rate(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for SocPadAttrWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadAttrWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadAttrWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadConfReadVal(u32);
    impl SocPadConfReadVal {
        /// Select pad type
        ///
        /// 0 - Bidirectional
        ///
        /// 1 - Open-drain
        ///
        /// 2 - Input-only
        ///
        /// 3 - Analog input
        #[inline(always)]
        pub fn pad_type(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Enable virtual open drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn virtual_od_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Enable Open-Drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn od_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Invert I/O signal:
        ///
        /// 0 - signals pass-through
        ///
        /// 1 - signals are inverted
        #[inline(always)]
        pub fn io_inversion(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable Pull:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn pull_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Direction of the pull:
        ///
        /// 0 - Pull down
        ///
        /// 1 - Pull up
        #[inline(always)]
        pub fn pull_dir(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable the High-Keeper:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn keeper_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable the Schmitt Trigger:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn schmitt_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable input:
        ///
        /// 0 - enabled
        ///
        /// 1 - disabled
        #[inline(always)]
        pub fn input_enable(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SocPadConfWriteVal {
            SocPadConfWriteVal(self.0)
        }
    }
    impl From<u32> for SocPadConfReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadConfReadVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadConfReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SocPadConfWriteVal(u32);
    impl SocPadConfWriteVal {
        /// Select pad type
        ///
        /// 0 - Bidirectional
        ///
        /// 1 - Open-drain
        ///
        /// 2 - Input-only
        ///
        /// 3 - Analog input
        #[inline(always)]
        pub fn pad_type(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Enable virtual open drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn virtual_od_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// Enable Open-Drain:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn od_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Invert I/O signal:
        ///
        /// 0 - signals pass-through
        ///
        /// 1 - signals are inverted
        #[inline(always)]
        pub fn io_inversion(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable Pull:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn pull_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Direction of the pull:
        ///
        /// 0 - Pull down
        ///
        /// 1 - Pull up
        #[inline(always)]
        pub fn pull_dir(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable the High-Keeper:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn keeper_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable the Schmitt Trigger:
        ///
        /// 0 - disabled
        ///
        /// 1 - enabled
        #[inline(always)]
        pub fn schmitt_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable input:
        ///
        /// 0 - enabled
        ///
        /// 1 - disabled
        #[inline(always)]
        pub fn input_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SocPadConfWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SocPadConfWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SocPadConfWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Status of last IBI. Should be read after IBI_DONE interrupt.
        ///
        /// Values:
        ///
        /// 00 - Success: IBI was transmitted and ACK'd by the Active Controller.
        /// 01 - Failure: Active Controller NACK'd the IBI before any data was sent.
        /// The Target Device will retry sending the IBI once.
        /// 10 - Failure: Active Controller NACK'd the IBI after partial data was sent.
        /// Part of data in the IBI queue is considered corrupted and will be discarded.
        /// 11 - Failure: IBI was terminated after 1 retry.
        #[inline(always)]
        pub fn last_ibi_status(&self) -> u32 {
            (self.0 >> 14) & 3
        }
        /// Protocol error occurred in the past. This field can only be reset
        /// by the Controller, if it issues the GETSTATUS CCC.
        ///
        /// Values:
        ///
        /// 0 - no error occurred
        ///
        /// 1 - generic protocol error occurred in the past. It will be set until reception
        /// of the next GETSTATUS command.
        #[inline(always)]
        pub fn protocol_error(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCapabilitiesReadVal(u32);
    impl StbyCrCapabilitiesReadVal {
        /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_entdaa_support(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setdasa_support(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported
        #[inline(always)]
        pub fn daa_setaasa_support(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Defines whether an I3C Target Transaction Interface is supported.
        ///
        /// 1'b0: DISABLED: Not supported
        ///
        /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
        #[inline(always)]
        pub fn target_xact_support(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn simple_crr_support(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
    }
    impl From<u32> for StbyCrCapabilitiesReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCapabilitiesReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCapabilitiesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigGetcapsReadVal(u32);
    impl StbyCrCccConfigGetcapsReadVal {
        #[inline(always)]
        pub fn f2_crcap2_dev_interact(&self) -> u32 {
            (self.0 >> 8) & 0xf
        }
        #[inline(always)]
        pub fn f2_crcap1_bus_config(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrCccConfigGetcapsWriteVal {
            StbyCrCccConfigGetcapsWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrCccConfigGetcapsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigGetcapsReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigGetcapsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigGetcapsWriteVal(u32);
    impl StbyCrCccConfigGetcapsWriteVal {
        #[inline(always)]
        pub fn f2_crcap2_dev_interact(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
        }
        #[inline(always)]
        pub fn f2_crcap1_bus_config(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for StbyCrCccConfigGetcapsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigGetcapsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigGetcapsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigRstactParamsReadVal(u32);
    impl StbyCrCccConfigRstactParamsReadVal {
        /// If set to 1'b1, then the Secondary Controller Logic must clear its Dynamic
        /// Address in register STBY_CR_DEVICE_ADDR after receiving
        /// a Target Reset Pattern that followed a Broadcast or Direct SET RSTACT CCC sent
        /// to the Dynamic Address, with Defining Byte 0x01 or 0x02.
        /// Requires support for Dynamic Address Assignment with at least one supported
        /// method, such as the ENTDAA CCC, with field DAA_ENTDAA_ENABLE set to 1'b1 in
        /// register STBY_CR_CONTROL.
        /// If field ACR_FSM_OP_SELECT in register STBY_CR_CONTROL is set to 1'b1, then
        /// this field shall be cleared (i.e., readiness to accept the Controller Role
        /// shall be revoked) with this Target Reset Pattern.
        #[inline(always)]
        pub fn reset_dynamic_addr(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// For Direct GET CCC, this field is returned for Defining Byte 0x82.
        #[inline(always)]
        pub fn reset_time_target(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// For Direct GET CCC, this field is returned for Defining Byte 0x81.
        #[inline(always)]
        pub fn reset_time_peripheral(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Contains the Defining Byte received with the last Direct SET CCC sent by the Active Controller.
        #[inline(always)]
        pub fn rst_action(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrCccConfigRstactParamsWriteVal {
            StbyCrCccConfigRstactParamsWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrCccConfigRstactParamsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigRstactParamsReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigRstactParamsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrCccConfigRstactParamsWriteVal(u32);
    impl StbyCrCccConfigRstactParamsWriteVal {
        /// If set to 1'b1, then the Secondary Controller Logic must clear its Dynamic
        /// Address in register STBY_CR_DEVICE_ADDR after receiving
        /// a Target Reset Pattern that followed a Broadcast or Direct SET RSTACT CCC sent
        /// to the Dynamic Address, with Defining Byte 0x01 or 0x02.
        /// Requires support for Dynamic Address Assignment with at least one supported
        /// method, such as the ENTDAA CCC, with field DAA_ENTDAA_ENABLE set to 1'b1 in
        /// register STBY_CR_CONTROL.
        /// If field ACR_FSM_OP_SELECT in register STBY_CR_CONTROL is set to 1'b1, then
        /// this field shall be cleared (i.e., readiness to accept the Controller Role
        /// shall be revoked) with this Target Reset Pattern.
        #[inline(always)]
        pub fn reset_dynamic_addr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// For Direct GET CCC, this field is returned for Defining Byte 0x82.
        #[inline(always)]
        pub fn reset_time_target(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        /// For Direct GET CCC, this field is returned for Defining Byte 0x81.
        #[inline(always)]
        pub fn reset_time_peripheral(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
    }
    impl From<u32> for StbyCrCccConfigRstactParamsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrCccConfigRstactParamsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrCccConfigRstactParamsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrControlReadVal(u32);
    impl StbyCrControlReadVal {
        /// Enables or disables the Secondary Controller:
        ///
        /// 2'b00 - DISABLED: Secondary Controller is disabled.
        ///
        /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
        /// but Host Controller initializes in Active Controller mode.
        ///
        /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
        /// Host Controller initializes in Standby Controller mode.
        ///
        /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
        /// Host Controller conditionally becomes a Hot-Joining Device
        /// to receive its Dynamic Address before operating in Standby Controller mode.
        #[inline(always)]
        pub fn stby_cr_enable_init(&self) -> u32 {
            (self.0 >> 30) & 3
        }
        /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
        /// Defining Byte 0x02.
        ///
        /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
        ///
        /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
        #[inline(always)]
        pub fn rstact_defbyte_02(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// Indicates ENTDAA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_entdaa_enable(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// Indicates SETDASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setdasa_enable(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// Indicates SETAASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setaasa_enable(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
        /// an I3C Target Transaction Interface to software (Section 6.17.3).
        ///
        /// 1'b0: DISABLED: not available
        ///
        /// 1'b1: ENABLED: available for software
        #[inline(always)]
        pub fn target_xact_enable(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
        /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
        #[inline(always)]
        pub fn bast_ccc_ibi_ring(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
        /// report a return from Deep Sleep state to the Active Controller.
        /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
        /// after accepting the Controller Role and transitioning to Active Controller mode.
        #[inline(always)]
        pub fn handoff_deep_sleep(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        #[inline(always)]
        pub fn prime_accept_getacccr(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_fsm_op_select(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn handoff_delay_nack(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn pending_rx_nack(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrControlWriteVal {
            StbyCrControlWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrControlWriteVal(u32);
    impl StbyCrControlWriteVal {
        /// Enables or disables the Secondary Controller:
        ///
        /// 2'b00 - DISABLED: Secondary Controller is disabled.
        ///
        /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
        /// but Host Controller initializes in Active Controller mode.
        ///
        /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
        /// Host Controller initializes in Standby Controller mode.
        ///
        /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
        /// Host Controller conditionally becomes a Hot-Joining Device
        /// to receive its Dynamic Address before operating in Standby Controller mode.
        #[inline(always)]
        pub fn stby_cr_enable_init(self, val: u32) -> Self {
            Self((self.0 & !(3 << 30)) | ((val & 3) << 30))
        }
        /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
        /// Defining Byte 0x02.
        ///
        /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
        ///
        /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
        #[inline(always)]
        pub fn rstact_defbyte_02(self, val: bool) -> Self {
            Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
        }
        /// Indicates ENTDAA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_entdaa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// Indicates SETDASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setdasa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// Indicates SETAASA method is enabled.
        ///
        /// 1'b0: DISABLED: will not respond
        ///
        /// 1'b1: ENABLED: will respond
        #[inline(always)]
        pub fn daa_setaasa_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
        /// an I3C Target Transaction Interface to software (Section 6.17.3).
        ///
        /// 1'b0: DISABLED: not available
        ///
        /// 1'b1: ENABLED: available for software
        #[inline(always)]
        pub fn target_xact_enable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
        /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
        #[inline(always)]
        pub fn bast_ccc_ibi_ring(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
        /// to attempt to send a Controller Role Request to the I3C Bus.
        #[inline(always)]
        pub fn cr_request_send(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
        /// report a return from Deep Sleep state to the Active Controller.
        /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
        /// after accepting the Controller Role and transitioning to Active Controller mode.
        #[inline(always)]
        pub fn handoff_deep_sleep(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        #[inline(always)]
        pub fn prime_accept_getacccr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn acr_fsm_op_select(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn handoff_delay_nack(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn pending_rx_nack(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceAddrReadVal(u32);
    impl StbyCrDeviceAddrReadVal {
        /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
        /// 1'b0: DYNAMIC_ADDR field is not valid
        /// 1'b1: DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Contains the Host Controller Device’s Dynamic Address.
        #[inline(always)]
        pub fn dynamic_addr(&self) -> u32 {
            (self.0 >> 16) & 0x7f
        }
        /// Indicates whether or not the value in the STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Static Address field is not valid
        ///
        /// 1'b1: The Static Address field is valid
        #[inline(always)]
        pub fn static_addr_valid(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn static_addr(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrDeviceAddrWriteVal {
            StbyCrDeviceAddrWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrDeviceAddrReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceAddrReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceAddrReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceAddrWriteVal(u32);
    impl StbyCrDeviceAddrWriteVal {
        /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
        /// 1'b0: DYNAMIC_ADDR field is not valid
        /// 1'b1: DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn dynamic_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Contains the Host Controller Device’s Dynamic Address.
        #[inline(always)]
        pub fn dynamic_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
        }
        /// Indicates whether or not the value in the STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Static Address field is not valid
        ///
        /// 1'b1: The Static Address field is valid
        #[inline(always)]
        pub fn static_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn static_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 0)) | ((val & 0x7f) << 0))
        }
    }
    impl From<u32> for StbyCrDeviceAddrWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceAddrWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceAddrWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceCharReadVal(u32);
    impl StbyCrDeviceCharReadVal {
        /// Bus Characteristics, Fixed Part.
        ///
        /// Reset value is set to 3'b001, because this device is an I3C Target,
        /// which supports extended capabilities
        #[inline(always)]
        pub fn bcr_fixed(&self) -> u32 {
            (self.0 >> 29) & 7
        }
        /// Bus Characteristics, Variable Part.
        ///
        /// Reset value is set to 5'b00110, because this device:
        ///
        ///
        /// - [bit4] is not a Virtual  Target
        ///
        /// - [bit3] is not Offline Capable
        ///
        /// - [bit2] uses the MDB in the IBI Payload
        ///
        /// - [bit1] is capable of IBI requests
        ///
        /// - [bit0] has no speed limitation
        #[inline(always)]
        pub fn bcr_var(&self) -> u32 {
            (self.0 >> 24) & 0x1f
        }
        /// Device Characteristics Register. Value represents an OCP Recovery Device.
        #[inline(always)]
        pub fn dcr(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// High part of the 48-bit Target Device Provisioned ID.
        #[inline(always)]
        pub fn pid_hi(&self) -> u32 {
            (self.0 >> 1) & 0x7fff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrDeviceCharWriteVal {
            StbyCrDeviceCharWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrDeviceCharReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceCharReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceCharReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrDeviceCharWriteVal(u32);
    impl StbyCrDeviceCharWriteVal {
        /// Bus Characteristics, Fixed Part.
        ///
        /// Reset value is set to 3'b001, because this device is an I3C Target,
        /// which supports extended capabilities
        #[inline(always)]
        pub fn bcr_fixed(self, val: u32) -> Self {
            Self((self.0 & !(7 << 29)) | ((val & 7) << 29))
        }
        /// Bus Characteristics, Variable Part.
        ///
        /// Reset value is set to 5'b00110, because this device:
        ///
        ///
        /// - [bit4] is not a Virtual  Target
        ///
        /// - [bit3] is not Offline Capable
        ///
        /// - [bit2] uses the MDB in the IBI Payload
        ///
        /// - [bit1] is capable of IBI requests
        ///
        /// - [bit0] has no speed limitation
        #[inline(always)]
        pub fn bcr_var(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 24)) | ((val & 0x1f) << 24))
        }
        /// Device Characteristics Register. Value represents an OCP Recovery Device.
        #[inline(always)]
        pub fn dcr(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
        }
        /// High part of the 48-bit Target Device Provisioned ID.
        #[inline(always)]
        pub fn pid_hi(self, val: u32) -> Self {
            Self((self.0 & !(0x7fff << 1)) | ((val & 0x7fff) << 1))
        }
    }
    impl From<u32> for StbyCrDeviceCharWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrDeviceCharWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrDeviceCharWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrForceReadVal(u32);
    impl StbyCrIntrForceReadVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_force(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_force(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_param_modified_force(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_force(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_force(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_force(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_force(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn crr_response_force(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrForceWriteVal {
            StbyCrIntrForceWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrForceReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrForceReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrForceReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrForceWriteVal(u32);
    impl StbyCrIntrForceWriteVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn ccc_param_modified_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn stby_cr_op_rstact_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn crr_response_force(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
    }
    impl From<u32> for StbyCrIntrForceWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrForceWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrForceWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrSignalEnableReadVal(u32);
    impl StbyCrIntrSignalEnableReadVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_signal_en(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_signal_en(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_param_modified_signal_en(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_op_rstact_signal_en(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_signal_en(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_signal_en(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_signal_en(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_signal_en(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn crr_response_signal_en(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_err_m3_signal_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_err_fail_signal_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_ok_primed_signal_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_ok_remain_signal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrSignalEnableWriteVal {
            StbyCrIntrSignalEnableWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrSignalEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrSignalEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrSignalEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrSignalEnableWriteVal(u32);
    impl StbyCrIntrSignalEnableWriteVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn ccc_param_modified_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        #[inline(always)]
        pub fn stby_cr_op_rstact_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn crr_response_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn acr_handoff_err_m3_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn acr_handoff_err_fail_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn acr_handoff_ok_primed_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn acr_handoff_ok_remain_signal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrIntrSignalEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrSignalEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrSignalEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrStatusReadVal(u32);
    impl StbyCrIntrStatusReadVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_stat(&self) -> bool {
            ((self.0 >> 19) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_stat(&self) -> bool {
            ((self.0 >> 18) & 1) != 0
        }
        #[inline(always)]
        pub fn ccc_param_modified_stat(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
        /// The Host Controller shall write 1'b1 to this field to indicate that the
        /// Secondary Controller received a RSTACT CCC from the Active Controller, followed
        /// by the Target Reset Pattern.
        #[inline(always)]
        pub fn stby_cr_op_rstact_stat(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_stat(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_stat(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_stat(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_stat(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        #[inline(always)]
        pub fn crr_response_stat(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_err_m3_stat(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_err_fail_stat(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_ok_primed_stat(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        #[inline(always)]
        pub fn acr_handoff_ok_remain_stat(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrIntrStatusWriteVal {
            StbyCrIntrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrIntrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrIntrStatusWriteVal(u32);
    impl StbyCrIntrStatusWriteVal {
        #[inline(always)]
        pub fn ccc_fatal_rstdaa_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
        }
        #[inline(always)]
        pub fn ccc_unhandled_nack_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
        }
        #[inline(always)]
        pub fn ccc_param_modified_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
        }
        /// The Host Controller shall write 1'b1 to this field to indicate that the
        /// Secondary Controller received a RSTACT CCC from the Active Controller, followed
        /// by the Target Reset Pattern.
        #[inline(always)]
        pub fn stby_cr_op_rstact_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
        #[inline(always)]
        pub fn stby_cr_accept_err_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        #[inline(always)]
        pub fn stby_cr_accept_ok_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        #[inline(always)]
        pub fn stby_cr_accept_nacked_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        #[inline(always)]
        pub fn stby_cr_dyn_addr_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        #[inline(always)]
        pub fn crr_response_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        #[inline(always)]
        pub fn acr_handoff_err_m3_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        #[inline(always)]
        pub fn acr_handoff_err_fail_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        #[inline(always)]
        pub fn acr_handoff_ok_primed_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        #[inline(always)]
        pub fn acr_handoff_ok_remain_stat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for StbyCrIntrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrIntrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrIntrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrStatusReadVal(u32);
    impl StbyCrStatusReadVal {
        #[inline(always)]
        pub fn hj_req_status(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        #[inline(always)]
        pub fn simple_crr_status(&self) -> u32 {
            (self.0 >> 5) & 7
        }
        #[inline(always)]
        pub fn ac_current_own(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrStatusWriteVal {
            StbyCrStatusWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrStatusWriteVal(u32);
    impl StbyCrStatusWriteVal {
        #[inline(always)]
        pub fn hj_req_status(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        #[inline(always)]
        pub fn simple_crr_status(self, val: u32) -> Self {
            Self((self.0 & !(7 << 5)) | ((val & 7) << 5))
        }
        #[inline(always)]
        pub fn ac_current_own(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for StbyCrStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrVirtDeviceAddrReadVal(u32);
    impl StbyCrVirtDeviceAddrReadVal {
        /// Indicates whether or not the value in the VIRT_DYNAMIC_ADDR field is valid.
        /// 1'b0: VIRT_DYNAMIC_ADDR field is not valid
        /// 1'b1: VIRT_DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn virt_dynamic_addr_valid(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Contains the Controller Virtual Device’s Dynamic Address.
        #[inline(always)]
        pub fn virt_dynamic_addr(&self) -> u32 {
            (self.0 >> 16) & 0x7f
        }
        /// Indicates whether or not the value in the VIRT_STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Virtual Device Static Address field is not valid
        ///
        /// 1'b1: The Virtual Device Static Address field is valid
        #[inline(always)]
        pub fn virt_static_addr_valid(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn virt_static_addr(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> StbyCrVirtDeviceAddrWriteVal {
            StbyCrVirtDeviceAddrWriteVal(self.0)
        }
    }
    impl From<u32> for StbyCrVirtDeviceAddrReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrVirtDeviceAddrReadVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrVirtDeviceAddrReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StbyCrVirtDeviceAddrWriteVal(u32);
    impl StbyCrVirtDeviceAddrWriteVal {
        /// Indicates whether or not the value in the VIRT_DYNAMIC_ADDR field is valid.
        /// 1'b0: VIRT_DYNAMIC_ADDR field is not valid
        /// 1'b1: VIRT_DYNAMIC_ADDR field is valid
        #[inline(always)]
        pub fn virt_dynamic_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
        /// Contains the Controller Virtual Device’s Dynamic Address.
        #[inline(always)]
        pub fn virt_dynamic_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
        }
        /// Indicates whether or not the value in the VIRT_STATIC_ADDR field is valid.
        ///
        /// 1'b0: The Virtual Device Static Address field is not valid
        ///
        /// 1'b1: The Virtual Device Static Address field is valid
        #[inline(always)]
        pub fn virt_static_addr_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// This field contains the Host Controller Device’s Static Address.
        #[inline(always)]
        pub fn virt_static_addr(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 0)) | ((val & 0x7f) << 0))
        }
    }
    impl From<u32> for StbyCrVirtDeviceAddrWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StbyCrVirtDeviceAddrWriteVal> for u32 {
        #[inline(always)]
        fn from(val: StbyCrVirtDeviceAddrWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiDataBufferThldCtrlReadVal(u32);
    impl TtiDataBufferThldCtrlReadVal {
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_start_thld(&self) -> u32 {
            (self.0 >> 24) & 7
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_start_thld(&self) -> u32 {
            (self.0 >> 16) & 7
        }
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_data_thld(&self) -> u32 {
            (self.0 >> 8) & 7
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_data_thld(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TtiDataBufferThldCtrlWriteVal {
            TtiDataBufferThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for TtiDataBufferThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiDataBufferThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: TtiDataBufferThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiDataBufferThldCtrlWriteVal(u32);
    impl TtiDataBufferThldCtrlWriteVal {
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_start_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
        }
        /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
        #[inline(always)]
        pub fn rx_data_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
        }
        /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
        #[inline(always)]
        pub fn tx_data_thld(self, val: u32) -> Self {
            Self((self.0 & !(7 << 0)) | ((val & 7) << 0))
        }
    }
    impl From<u32> for TtiDataBufferThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiDataBufferThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TtiDataBufferThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiQueueSizeReadVal(u32);
    impl TtiQueueSizeReadVal {
        /// Transmit Data Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn tx_data_buffer_size(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Receive Data Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn rx_data_buffer_size(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
        /// TX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn tx_desc_buffer_size(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// RX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
        #[inline(always)]
        pub fn rx_desc_buffer_size(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for TtiQueueSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiQueueSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: TtiQueueSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiQueueThldCtrlReadVal(u32);
    impl TtiQueueThldCtrlReadVal {
        /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
        #[inline(always)]
        pub fn ibi_thld(&self) -> u32 {
            (self.0 >> 24) & 0xff
        }
        /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
        #[inline(always)]
        pub fn rx_desc_thld(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
        #[inline(always)]
        pub fn tx_desc_thld(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TtiQueueThldCtrlWriteVal {
            TtiQueueThldCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for TtiQueueThldCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiQueueThldCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: TtiQueueThldCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiQueueThldCtrlWriteVal(u32);
    impl TtiQueueThldCtrlWriteVal {
        /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
        #[inline(always)]
        pub fn ibi_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
        }
        /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
        #[inline(always)]
        pub fn rx_desc_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
        #[inline(always)]
        pub fn tx_desc_thld(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for TtiQueueThldCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiQueueThldCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TtiQueueThldCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiResetControlReadVal(u32);
    impl TtiResetControlReadVal {
        /// TTI IBI Queue Buffer Software Reset
        #[inline(always)]
        pub fn ibi_queue_rst(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// TTI RX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_data_rst(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// TTI TX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_data_rst(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// TTI RX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_desc_rst(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// TTI TX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_desc_rst(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Target Core Software Reset
        #[inline(always)]
        pub fn soft_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TtiResetControlWriteVal {
            TtiResetControlWriteVal(self.0)
        }
    }
    impl From<u32> for TtiResetControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiResetControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: TtiResetControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TtiResetControlWriteVal(u32);
    impl TtiResetControlWriteVal {
        /// TTI IBI Queue Buffer Software Reset
        #[inline(always)]
        pub fn ibi_queue_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// TTI RX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_data_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// TTI TX Data Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_data_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// TTI RX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn rx_desc_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// TTI TX Descriptor Queue Buffer Software Reset
        #[inline(always)]
        pub fn tx_desc_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Target Core Software Reset
        #[inline(always)]
        pub fn soft_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for TtiResetControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TtiResetControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TtiResetControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TFRegReadVal(u32);
    impl TFRegReadVal {
        /// Fall time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_f(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TFRegWriteVal {
            TFRegWriteVal(self.0)
        }
    }
    impl From<u32> for TFRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TFRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TFRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TFRegWriteVal(u32);
    impl TFRegWriteVal {
        /// Fall time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_f(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TFRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TFRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TFRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdDatRegReadVal(u32);
    impl THdDatRegReadVal {
        /// Data hold time in clock units
        #[inline(always)]
        pub fn t_hd_dat(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THdDatRegWriteVal {
            THdDatRegWriteVal(self.0)
        }
    }
    impl From<u32> for THdDatRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdDatRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: THdDatRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdDatRegWriteVal(u32);
    impl THdDatRegWriteVal {
        /// Data hold time in clock units
        #[inline(always)]
        pub fn t_hd_dat(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THdDatRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdDatRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: THdDatRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdStaRegReadVal(u32);
    impl THdStaRegReadVal {
        /// Hold time for (repeated) START in clock units
        #[inline(always)]
        pub fn t_hd_sta(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THdStaRegWriteVal {
            THdStaRegWriteVal(self.0)
        }
    }
    impl From<u32> for THdStaRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdStaRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: THdStaRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THdStaRegWriteVal(u32);
    impl THdStaRegWriteVal {
        /// Hold time for (repeated) START in clock units
        #[inline(always)]
        pub fn t_hd_sta(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THdStaRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THdStaRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: THdStaRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THighRegReadVal(u32);
    impl THighRegReadVal {
        #[inline(always)]
        pub fn t_high(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> THighRegWriteVal {
            THighRegWriteVal(self.0)
        }
    }
    impl From<u32> for THighRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THighRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: THighRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct THighRegWriteVal(u32);
    impl THighRegWriteVal {
        #[inline(always)]
        pub fn t_high(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for THighRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<THighRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: THighRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TLowRegReadVal(u32);
    impl TLowRegReadVal {
        /// Low period of the SCL in clock units
        #[inline(always)]
        pub fn t_low(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TLowRegWriteVal {
            TLowRegWriteVal(self.0)
        }
    }
    impl From<u32> for TLowRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TLowRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TLowRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TLowRegWriteVal(u32);
    impl TLowRegWriteVal {
        /// Low period of the SCL in clock units
        #[inline(always)]
        pub fn t_low(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TLowRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TLowRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TLowRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TRRegReadVal(u32);
    impl TRRegReadVal {
        /// Rise time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_r(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TRRegWriteVal {
            TRRegWriteVal(self.0)
        }
    }
    impl From<u32> for TRRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TRRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TRRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TRRegWriteVal(u32);
    impl TRRegWriteVal {
        /// Rise time of both SDA and SCL in clock units
        #[inline(always)]
        pub fn t_r(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TRRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TRRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TRRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuDatRegReadVal(u32);
    impl TSuDatRegReadVal {
        /// Data setup time in clock units
        #[inline(always)]
        pub fn t_su_dat(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuDatRegWriteVal {
            TSuDatRegWriteVal(self.0)
        }
    }
    impl From<u32> for TSuDatRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuDatRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuDatRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuDatRegWriteVal(u32);
    impl TSuDatRegWriteVal {
        /// Data setup time in clock units
        #[inline(always)]
        pub fn t_su_dat(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuDatRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuDatRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuDatRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStaRegReadVal(u32);
    impl TSuStaRegReadVal {
        /// Setup time for repeated START in clock units
        #[inline(always)]
        pub fn t_su_sta(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuStaRegWriteVal {
            TSuStaRegWriteVal(self.0)
        }
    }
    impl From<u32> for TSuStaRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStaRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStaRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStaRegWriteVal(u32);
    impl TSuStaRegWriteVal {
        /// Setup time for repeated START in clock units
        #[inline(always)]
        pub fn t_su_sta(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuStaRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStaRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStaRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStoRegReadVal(u32);
    impl TSuStoRegReadVal {
        /// Setup time for STOP in clock units
        #[inline(always)]
        pub fn t_su_sto(&self) -> u32 {
            (self.0 >> 0) & 0xfffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TSuStoRegWriteVal {
            TSuStoRegWriteVal(self.0)
        }
    }
    impl From<u32> for TSuStoRegReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStoRegReadVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStoRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TSuStoRegWriteVal(u32);
    impl TSuStoRegWriteVal {
        /// Setup time for STOP in clock units
        #[inline(always)]
        pub fn t_su_sto(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 0)) | ((val & 0xfffff) << 0))
        }
    }
    impl From<u32> for TSuStoRegWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<TSuStoRegWriteVal> for u32 {
        #[inline(always)]
        fn from(val: TSuStoRegWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type Dat = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Dct = ureg::ReadWriteReg32<0, u32, u32>;
    pub type I3cbaseHciVersion = ureg::ReadOnlyReg32<u32>;
    pub type I3cbaseHcControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::HcControlReadVal,
        crate::i3ccsr::regs::HcControlWriteVal,
    >;
    pub type I3cbaseControllerDeviceAddr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ControllerDeviceAddrReadVal,
        crate::i3ccsr::regs::ControllerDeviceAddrWriteVal,
    >;
    pub type I3cbaseHcCapabilities =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::HcCapabilitiesReadVal>;
    pub type I3cbaseResetControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ResetControlReadVal,
        crate::i3ccsr::regs::ResetControlWriteVal,
    >;
    pub type I3cbasePresentState = ureg::ReadOnlyReg32<crate::i3ccsr::regs::PresentStateReadVal>;
    pub type I3cbaseIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrStatusReadVal,
        crate::i3ccsr::regs::IntrStatusWriteVal,
    >;
    pub type I3cbaseIntrStatusEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrStatusEnableReadVal,
        crate::i3ccsr::regs::IntrStatusEnableWriteVal,
    >;
    pub type I3cbaseIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IntrSignalEnableReadVal,
        crate::i3ccsr::regs::IntrSignalEnableWriteVal,
    >;
    pub type I3cbaseIntrForce = ureg::WriteOnlyReg32<0, crate::i3ccsr::regs::IntrForceWriteVal>;
    pub type I3cbaseDatSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::DatSectionOffsetReadVal>;
    pub type I3cbaseDctSectionOffset = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DctSectionOffsetReadVal,
        crate::i3ccsr::regs::DctSectionOffsetWriteVal,
    >;
    pub type I3cbaseRingHeadersSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::RingHeadersSectionOffsetReadVal>;
    pub type I3cbasePioSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::PioSectionOffsetReadVal>;
    pub type I3cbaseExtCapsSectionOffset =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtCapsSectionOffsetReadVal>;
    pub type I3cbaseIntCtrlCmdsEn = ureg::ReadOnlyReg32<crate::i3ccsr::regs::IntCtrlCmdsEnReadVal>;
    pub type I3cbaseIbiNotifyCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IbiNotifyCtrlReadVal,
        crate::i3ccsr::regs::IbiNotifyCtrlWriteVal,
    >;
    pub type I3cbaseIbiDataAbortCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IbiDataAbortCtrlReadVal,
        crate::i3ccsr::regs::IbiDataAbortCtrlWriteVal,
    >;
    pub type I3cbaseDevCtxBaseLo = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DevCtxBaseLoReadVal,
        crate::i3ccsr::regs::DevCtxBaseLoWriteVal,
    >;
    pub type I3cbaseDevCtxBaseHi = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DevCtxBaseHiReadVal,
        crate::i3ccsr::regs::DevCtxBaseHiWriteVal,
    >;
    pub type I3cbaseDevCtxSg = ureg::ReadOnlyReg32<crate::i3ccsr::regs::DevCtxSgReadVal>;
    pub type PiocontrolCommandPort = ureg::WriteOnlyReg32<0, u32>;
    pub type PiocontrolResponsePort = ureg::ReadOnlyReg32<u32>;
    pub type PiocontrolTxDataPort = ureg::WriteOnlyReg32<0, u32>;
    pub type PiocontrolRxDataPort = ureg::ReadOnlyReg32<u32>;
    pub type PiocontrolIbiPort = ureg::ReadOnlyReg32<u32>;
    pub type PiocontrolQueueThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::QueueThldCtrlReadVal,
        crate::i3ccsr::regs::QueueThldCtrlWriteVal,
    >;
    pub type PiocontrolDataBufferThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DataBufferThldCtrlReadVal,
        crate::i3ccsr::regs::DataBufferThldCtrlWriteVal,
    >;
    pub type PiocontrolQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::QueueSizeReadVal>;
    pub type PiocontrolAltQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::AltQueueSizeReadVal>;
    pub type PiocontrolPioIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrStatusReadVal,
        crate::i3ccsr::regs::PioIntrStatusWriteVal,
    >;
    pub type PiocontrolPioIntrStatusEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrStatusEnableReadVal,
        crate::i3ccsr::regs::PioIntrStatusEnableWriteVal,
    >;
    pub type PiocontrolPioIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioIntrSignalEnableReadVal,
        crate::i3ccsr::regs::PioIntrSignalEnableWriteVal,
    >;
    pub type PiocontrolPioIntrForce =
        ureg::WriteOnlyReg32<0, crate::i3ccsr::regs::PioIntrForceWriteVal>;
    pub type PiocontrolPioControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::PioControlReadVal,
        crate::i3ccsr::regs::PioControlWriteVal,
    >;
    pub type I3cEcTerminationExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type SecfwrecoveryifExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type SecfwrecoveryifProtCap0 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifProtCap1 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifProtCap2 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ProtCap2ReadVal,
        crate::i3ccsr::regs::ProtCap2WriteVal,
    >;
    pub type SecfwrecoveryifProtCap3 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ProtCap3ReadVal,
        crate::i3ccsr::regs::ProtCap3WriteVal,
    >;
    pub type SecfwrecoveryifDeviceId0 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DeviceId0ReadVal,
        crate::i3ccsr::regs::DeviceId0WriteVal,
    >;
    pub type SecfwrecoveryifDeviceId1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceId5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifDeviceIdReserved = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifDeviceStatus0 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DeviceStatus0ReadVal,
        crate::i3ccsr::regs::DeviceStatus0WriteVal,
    >;
    pub type SecfwrecoveryifDeviceStatus1 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DeviceStatus1ReadVal,
        crate::i3ccsr::regs::DeviceStatus1WriteVal,
    >;
    pub type SecfwrecoveryifDeviceReset = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::DeviceResetReadVal,
        crate::i3ccsr::regs::DeviceResetWriteVal,
    >;
    pub type SecfwrecoveryifRecoveryCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::RecoveryCtrlReadVal,
        crate::i3ccsr::regs::RecoveryCtrlWriteVal,
    >;
    pub type SecfwrecoveryifRecoveryStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::RecoveryStatusReadVal,
        crate::i3ccsr::regs::RecoveryStatusWriteVal,
    >;
    pub type SecfwrecoveryifHwStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::HwStatusReadVal,
        crate::i3ccsr::regs::HwStatusWriteVal,
    >;
    pub type SecfwrecoveryifIndirectFifoCtrl0 = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::IndirectFifoCtrl0ReadVal,
        crate::i3ccsr::regs::IndirectFifoCtrl0WriteVal,
    >;
    pub type SecfwrecoveryifIndirectFifoCtrl1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SecfwrecoveryifIndirectFifoStatus0 =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::IndirectFifoStatus0ReadVal>;
    pub type SecfwrecoveryifIndirectFifoStatus1 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifIndirectFifoStatus2 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifIndirectFifoStatus3 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifIndirectFifoStatus4 = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifIndirectFifoReserved = ureg::ReadOnlyReg32<u32>;
    pub type SecfwrecoveryifIndirectFifoData = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeExtcapHeader =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type StdbyctrlmodeStbyCrControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrControlReadVal,
        crate::i3ccsr::regs::StbyCrControlWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDeviceAddr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrDeviceAddrReadVal,
        crate::i3ccsr::regs::StbyCrDeviceAddrWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCapabilities =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::StbyCrCapabilitiesReadVal>;
    pub type StdbyctrlmodeRsvd0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrStatusReadVal,
        crate::i3ccsr::regs::StbyCrStatusWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDeviceChar = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrDeviceCharReadVal,
        crate::i3ccsr::regs::StbyCrDeviceCharWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrDevicePidLo = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrIntrStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrStatusReadVal,
        crate::i3ccsr::regs::StbyCrIntrStatusWriteVal,
    >;
    pub type StdbyctrlmodeRsvd1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type StdbyctrlmodeStbyCrIntrSignalEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrSignalEnableReadVal,
        crate::i3ccsr::regs::StbyCrIntrSignalEnableWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrIntrForce = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrIntrForceReadVal,
        crate::i3ccsr::regs::StbyCrIntrForceWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCccConfigGetcaps = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrCccConfigGetcapsReadVal,
        crate::i3ccsr::regs::StbyCrCccConfigGetcapsWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrCccConfigRstactParams = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrCccConfigRstactParamsReadVal,
        crate::i3ccsr::regs::StbyCrCccConfigRstactParamsWriteVal,
    >;
    pub type StdbyctrlmodeStbyCrVirtDeviceAddr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::StbyCrVirtDeviceAddrReadVal,
        crate::i3ccsr::regs::StbyCrVirtDeviceAddrWriteVal,
    >;
    pub type StdbyctrlmodeRsvd3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type TtiExtcapHeader = ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type TtiControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::ControlReadVal,
        crate::i3ccsr::regs::ControlWriteVal,
    >;
    pub type TtiStatus = ureg::ReadOnlyReg32<crate::i3ccsr::regs::StatusReadVal>;
    pub type TtiTtiResetControl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TtiResetControlReadVal,
        crate::i3ccsr::regs::TtiResetControlWriteVal,
    >;
    pub type TtiInterruptStatus = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptStatusReadVal,
        crate::i3ccsr::regs::InterruptStatusWriteVal,
    >;
    pub type TtiInterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptEnableReadVal,
        crate::i3ccsr::regs::InterruptEnableWriteVal,
    >;
    pub type TtiInterruptForce = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::InterruptForceReadVal,
        crate::i3ccsr::regs::InterruptForceWriteVal,
    >;
    pub type TtiRxDescQueuePort = ureg::ReadOnlyReg32<u32>;
    pub type TtiRxDataPort = ureg::ReadOnlyReg32<u32>;
    pub type TtiTxDescQueuePort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiTxDataPort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiTtiIbiPort = ureg::WriteOnlyReg32<0, u32>;
    pub type TtiTtiQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::TtiQueueSizeReadVal>;
    pub type TtiIbiTtiQueueSize = ureg::ReadOnlyReg32<crate::i3ccsr::regs::IbiTtiQueueSizeReadVal>;
    pub type TtiTtiQueueThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TtiQueueThldCtrlReadVal,
        crate::i3ccsr::regs::TtiQueueThldCtrlWriteVal,
    >;
    pub type TtiTtiDataBufferThldCtrl = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TtiDataBufferThldCtrlReadVal,
        crate::i3ccsr::regs::TtiDataBufferThldCtrlWriteVal,
    >;
    pub type SocmgmtifExtcapHeader = ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type SocmgmtifSocMgmtControl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtRsvd3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocPadConf = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::SocPadConfReadVal,
        crate::i3ccsr::regs::SocPadConfWriteVal,
    >;
    pub type SocmgmtifSocPadAttr = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::SocPadAttrReadVal,
        crate::i3ccsr::regs::SocPadAttrWriteVal,
    >;
    pub type SocmgmtifSocMgmtFeature2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifSocMgmtFeature3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTRReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TRRegReadVal,
        crate::i3ccsr::regs::TRRegWriteVal,
    >;
    pub type SocmgmtifTFReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TFRegReadVal,
        crate::i3ccsr::regs::TFRegWriteVal,
    >;
    pub type SocmgmtifTSuDatReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuDatRegReadVal,
        crate::i3ccsr::regs::TSuDatRegWriteVal,
    >;
    pub type SocmgmtifTHdDatReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THdDatRegReadVal,
        crate::i3ccsr::regs::THdDatRegWriteVal,
    >;
    pub type SocmgmtifTHighReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THighRegReadVal,
        crate::i3ccsr::regs::THighRegWriteVal,
    >;
    pub type SocmgmtifTLowReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TLowRegReadVal,
        crate::i3ccsr::regs::TLowRegWriteVal,
    >;
    pub type SocmgmtifTHdStaReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::THdStaRegReadVal,
        crate::i3ccsr::regs::THdStaRegWriteVal,
    >;
    pub type SocmgmtifTSuStaReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuStaRegReadVal,
        crate::i3ccsr::regs::TSuStaRegWriteVal,
    >;
    pub type SocmgmtifTSuStoReg = ureg::ReadWriteReg32<
        0,
        crate::i3ccsr::regs::TSuStoRegReadVal,
        crate::i3ccsr::regs::TSuStoRegWriteVal,
    >;
    pub type SocmgmtifTFreeReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTAvalReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type SocmgmtifTIdleReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CtrlcfgExtcapHeader = ureg::ReadOnlyReg32<crate::i3ccsr::regs::ExtcapHeaderReadVal>;
    pub type CtrlcfgControllerConfig =
        ureg::ReadOnlyReg32<crate::i3ccsr::regs::ControllerConfigReadVal>;
}

/*++

Licensed under the Apache-2.0 license.

File Name:

	fmc.ld

Abstract:

	Test FMC Linker Script

--*/

OUTPUT_ARCH(riscv)
OUTPUT_FORMAT("elf32-littleriscv", "elf32-littleriscv", "elf32-littleriscv")
ENTRY(_start)

MBOX_ORG         = 0x30000000;
ICCM_ORG         = 0x40000000;
DCCM_ORG         = 0x50000000;
MAN1_ORG         = 0x50000000;
MAN2_ORG         = 0x50001000;
FHT_ORG          = 0x50002000;
LDEVID_TBS_ORG   = 0x50003000;
FMCALIAS_TBS_ORG = 0x50003400;
PCR_LOG_ORG      = 0x50003800;
DATA_ORG         = 0x50004000;
STACK_ORG        = 0x5001C000;
ESTACK_ORG       = 0x5001F800;
NSTACK_ORG       = 0x5001FC00;

MBOX_SIZE         = 128K;
ICCM_SIZE         = 8K;
DCCM_SIZE         = 128K;
MAN1_SIZE         = 4K;
MAN2_SIZE         = 4K;
FHT_SIZE          = 4K;
LDEVID_TBS_SIZE   = 1K;
FMCALIAS_TBS_SIZE = 1K;
PCR_LOG_SIZE      = 2K;
DATA_SIZE         = 96K;
STACK_SIZE        = 14K;
ESTACK_SIZE       = 1K;
NSTACK_SIZE       = 1K;

MEMORY
{
	MBOX         (rw) : ORIGIN = MBOX_ORG,         LENGTH = MBOX_SIZE
	ICCM         (rx) : ORIGIN = ICCM_ORG,         LENGTH = ICCM_SIZE
	MAN1         (rw) : ORIGIN = MAN1_ORG,         LENGTH = MAN1_SIZE
	MAN2         (rw) : ORIGIN = MAN2_ORG,         LENGTH = MAN2_SIZE
	FHT          (rw) : ORIGIN = FHT_ORG,          LENGTH = FHT_SIZE
	LDEVID_TBS   (rw) : ORIGIN = LDEVID_TBS_ORG,   LENGTH = LDEVID_TBS_SIZE
	FMCALIAS_TBS (rw) : ORIGIN = FMCALIAS_TBS_ORG, LENGTH = FMCALIAS_TBS_SIZE
	PCR_LOG      (rw) : ORIGIN = PCR_LOG_ORG,      LENGTH = PCR_LOG_SIZE
	DATA         (rw) : ORIGIN = DATA_ORG,         LENGTH = DATA_SIZE
	STACK        (rw) : ORIGIN = STACK_ORG,        LENGTH = STACK_SIZE
	ESTACK       (rw) : ORIGIN = ESTACK_ORG,       LENGTH = ESTACK_SIZE
	NSTACK       (rw) : ORIGIN = NSTACK_ORG,       LENGTH = NSTACK_SIZE
} 

SECTIONS 
{
	.text : ALIGN(4)
	{
        _stext = .;

		KEEP(*(.init .init.*));
        *(.text .text.*);
        KEEP(*(.vectors))

    	. = ALIGN(4);
        _etext = .;
  	} > ICCM

	.rodata : ALIGN(4)
	{
        _srodata = .;
		
		  *(.srodata .srodata.*);
    	*(.rodata .rodata.*);

    	. = ALIGN(4);
        _erodata = .;
	} > ICCM

	.data : ALIGN(4)
	{
		  _sidata = LOADADDR(.data);
	    _sdata = .;
		
	    /* Must be called __global_pointer$ for linker relaxations to work. */
	    PROVIDE(__global_pointer$ = . + 0x800);
   
		*(.sdata .sdata.* .sdata2 .sdata2.*);
	    *(.data .data.*);
	    
		. = ALIGN(4);
	    _edata = .;
	} > DATA AT> ICCM

	.bss (NOLOAD) : ALIGN(4) 
    {
		_sbss = .;

        *(.bss*)
        *(.sbss*)
        *(COMMON)
        . = ALIGN(4);
		
		_ebss = .;
    } > DATA

    .stack (NOLOAD): ALIGN(4)
    {
    	_estack = .;
		
        . = . + STACK_SIZE;

        . = ALIGN(4);
    	_sstack = .;
    } > STACK

	.estack (NOLOAD): ALIGN(4)
    {
    	_eestack = .;
		
        . = . + ESTACK_SIZE;

        . = ALIGN(4);
    	_sestack = .;
    } > ESTACK

    .nstack (NOLOAD): ALIGN(4)
    {
    	_enstack = .;
		
        . = . + NSTACK_SIZE;

        . = ALIGN(4);
    	_snstack = .;
    } > NSTACK

	.got (INFO) :
  	{
    	KEEP(*(.got .got.*));
  	}

  	.eh_frame (INFO) : 
	{ 
		KEEP(*(.eh_frame))
	}
	
  	.eh_frame_hdr (INFO) :
	{
		*(.eh_frame_hdr) 
	}
}

/*
_bss_len  = SIZEOF(.bss);
_data_len = SIZEOF(.data);
*/

ASSERT(SIZEOF(.got) == 0, ".got section detected in FMC");
ASSERT(SIZEOF(.data) == 0, ".data section detected in FMC");
ASSERT(SIZEOF(.bss) == 0, ".bss section detected in FMC");
ASSERT(SIZEOF(.stack) == STACK_SIZE, ".stack section overflow");
ASSERT(SIZEOF(.estack) == ESTACK_SIZE, ".estack section overflow");
ASSERT(SIZEOF(.nstack) == NSTACK_SIZE, ".nstack section overflow");


// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 020d3155f57155d6a25aebc3a121a361e4801047
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SpiHostReg {
    _priv: (),
}
impl SpiHostReg {
    pub const PTR: *mut u32 = 0x20000000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`spi_host::regs::InterruptStateReadVal`]; Write value: [`spi_host::regs::InterruptStateWriteVal`]
    #[inline(always)]
    pub fn interrupt_state(&self) -> ureg::RegRef<crate::spi_host::meta::InterruptState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::InterruptEnableReadVal`]; Write value: [`spi_host::regs::InterruptEnableWriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(&self) -> ureg::RegRef<crate::spi_host::meta::InterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::InterruptTestReadVal`]; Write value: [`spi_host::regs::InterruptTestWriteVal`]
    #[inline(always)]
    pub fn interrupt_test(&self) -> ureg::RegRef<crate::spi_host::meta::InterruptTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::AlertTestReadVal`]; Write value: [`spi_host::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::spi_host::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::ControlReadVal`]; Write value: [`spi_host::regs::ControlWriteVal`]
    #[inline(always)]
    pub fn control(&self) -> ureg::RegRef<crate::spi_host::meta::Control, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::StatusReadVal`]; Write value: [`spi_host::regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::spi_host::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::ConfigoptsReadVal`]; Write value: [`spi_host::regs::ConfigoptsWriteVal`]
    #[inline(always)]
    pub fn configopts(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::spi_host::meta::Configopts, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn csid(&self) -> ureg::RegRef<crate::spi_host::meta::Csid, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::CommandReadVal`]; Write value: [`spi_host::regs::CommandWriteVal`]
    #[inline(always)]
    pub fn command(&self) -> ureg::RegRef<crate::spi_host::meta::Command, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rxdata(&self) -> ureg::RegRef<crate::spi_host::meta::Rxdata, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn txdata(&self) -> ureg::RegRef<crate::spi_host::meta::Txdata, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::ErrorEnableReadVal`]; Write value: [`spi_host::regs::ErrorEnableWriteVal`]
    #[inline(always)]
    pub fn error_enable(&self) -> ureg::RegRef<crate::spi_host::meta::ErrorEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::ErrorStatusReadVal`]; Write value: [`spi_host::regs::ErrorStatusWriteVal`]
    #[inline(always)]
    pub fn error_status(&self) -> ureg::RegRef<crate::spi_host::meta::ErrorStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`spi_host::regs::EventEnableReadVal`]; Write value: [`spi_host::regs::EventEnableWriteVal`]
    #[inline(always)]
    pub fn event_enable(&self) -> ureg::RegRef<crate::spi_host::meta::EventEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_fault(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CommandWriteVal(u32);
    impl CommandWriteVal {
        /// Segment Length.
        ///
        /// For read or write segments, this field controls the
        /// number of 1-byte bursts to transmit and or receive in
        /// this command segment.  The number of cyles required
        /// to send or received a byte will depend on !!COMMAND.SPEED.
        /// For dummy segments, (!!COMMAND.DIRECTION == 0), this register
        /// controls the number of dummy cycles to issue.
        /// The number of bytes (or dummy cycles) in the segment will be
        /// equal to !!COMMAND.LEN + 1.
        #[inline(always)]
        pub fn len(self, val: u32) -> Self {
            Self((self.0 & !(0x1ff << 0)) | ((val & 0x1ff) << 0))
        }
        /// Chip select active after transaction.  If CSAAT = 0, the
        /// chip select line is raised immediately at the end of the
        /// command segment.   If !!COMMAND.CSAAT = 1, the chip select
        /// line is left low at the end of the current transaction
        /// segment.  This allows the creation longer, more
        /// complete SPI transactions, consisting of several separate
        /// segments for issuing instructions, pausing for dummy cycles,
        /// and transmitting or receiving data from the device.
        #[inline(always)]
        pub fn csaat(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// The speed for this command segment: "0" = Standard SPI. "1" = Dual SPI.
        /// "2"=Quad SPI,  "3": RESERVED.
        #[inline(always)]
        pub fn speed(self, val: u32) -> Self {
            Self((self.0 & !(3 << 10)) | ((val & 3) << 10))
        }
        /// The direction for the following command: "0" = Dummy cycles
        /// (no TX/RX). "1" = Rx only, "2" = Tx only, "3" = Bidirectional
        /// Tx/Rx (Standard SPI mode only).
        #[inline(always)]
        pub fn direction(self, val: u32) -> Self {
            Self((self.0 & !(3 << 12)) | ((val & 3) << 12))
        }
    }
    impl From<u32> for CommandWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CommandWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CommandWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ConfigoptsReadVal(u32);
    impl ConfigoptsReadVal {
        /// Core clock divider.  Slows down subsequent SPI transactions by a
        /// factor of (CLKDIV+1) relative to the core clock frequency.  The
        /// period of sck, T(sck) then becomes `2*(CLK_DIV+1)*T(core)`
        #[inline(always)]
        pub fn clkdiv(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Minimum idle time between commands. Indicates the minimum
        /// number of sck half-cycles to hold cs_n high between commands.
        /// Setting this register to zero creates a minimally-wide CS_N-high
        /// pulse of one-half sck cycle.
        #[inline(always)]
        pub fn csnidle(&self) -> u32 {
            (self.0 >> 16) & 0xf
        }
        /// CS_N Trailing Time.  Indicates the number of half sck cycles,
        /// CSNTRAIL+1, to leave between last edge of sck and the rising
        /// edge of cs_n. Setting this register to zero corresponds
        /// to the minimum delay of one-half sck cycle.
        #[inline(always)]
        pub fn csntrail(&self) -> u32 {
            (self.0 >> 20) & 0xf
        }
        /// CS_N Leading Time.  Indicates the number of half sck cycles,
        /// CSNLEAD+1, to leave between the falling edge of cs_n and
        /// the first edge of sck.  Setting this register to zero
        /// corresponds to the minimum delay of one-half sck cycle
        #[inline(always)]
        pub fn csnlead(&self) -> u32 {
            (self.0 >> 24) & 0xf
        }
        /// Full cycle.  Modifies the CPHA sampling behaviour to allow
        /// for longer device logic setup times.  Rather than sampling the SD
        /// bus a half cycle after shifting out data, the data is sampled
        /// a full cycle after shifting data out.  This means that if
        /// CPHA = 0, data is shifted out on the trailing edge, and
        /// sampled a full cycle later.  If CPHA = 1, data is shifted and
        /// sampled with the trailing edge, also separated by a
        /// full cycle.
        #[inline(always)]
        pub fn fullcyc(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// The phase of the sck clock signal relative to the data. When
        /// CPHA = 0, the data changes on the trailing edge of sck
        /// and is typically sampled on the leading edge.  Conversely
        /// if CPHA = 1 high, data lines change on the leading edge of
        /// sck and are typically sampled on the trailing edge.
        /// CPHA should be chosen to match the phase of the selected
        /// device.  The sampling behavior is modified by the
        /// !!CONFIGOPTS.FULLCYC bit.
        #[inline(always)]
        pub fn cpha(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// The polarity of the sck clock signal.  When CPOL is 0,
        /// sck is low when idle, and emits high pulses.   When CPOL
        /// is low, sck is high when idle, and emits a series of low
        /// pulses.
        #[inline(always)]
        pub fn cpol(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ConfigoptsWriteVal {
            ConfigoptsWriteVal(self.0)
        }
    }
    impl From<u32> for ConfigoptsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ConfigoptsReadVal> for u32 {
        #[inline(always)]
        fn from(val: ConfigoptsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ConfigoptsWriteVal(u32);
    impl ConfigoptsWriteVal {
        /// Core clock divider.  Slows down subsequent SPI transactions by a
        /// factor of (CLKDIV+1) relative to the core clock frequency.  The
        /// period of sck, T(sck) then becomes `2*(CLK_DIV+1)*T(core)`
        #[inline(always)]
        pub fn clkdiv(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// Minimum idle time between commands. Indicates the minimum
        /// number of sck half-cycles to hold cs_n high between commands.
        /// Setting this register to zero creates a minimally-wide CS_N-high
        /// pulse of one-half sck cycle.
        #[inline(always)]
        pub fn csnidle(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 16)) | ((val & 0xf) << 16))
        }
        /// CS_N Trailing Time.  Indicates the number of half sck cycles,
        /// CSNTRAIL+1, to leave between last edge of sck and the rising
        /// edge of cs_n. Setting this register to zero corresponds
        /// to the minimum delay of one-half sck cycle.
        #[inline(always)]
        pub fn csntrail(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 20)) | ((val & 0xf) << 20))
        }
        /// CS_N Leading Time.  Indicates the number of half sck cycles,
        /// CSNLEAD+1, to leave between the falling edge of cs_n and
        /// the first edge of sck.  Setting this register to zero
        /// corresponds to the minimum delay of one-half sck cycle
        #[inline(always)]
        pub fn csnlead(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 24)) | ((val & 0xf) << 24))
        }
        /// Full cycle.  Modifies the CPHA sampling behaviour to allow
        /// for longer device logic setup times.  Rather than sampling the SD
        /// bus a half cycle after shifting out data, the data is sampled
        /// a full cycle after shifting data out.  This means that if
        /// CPHA = 0, data is shifted out on the trailing edge, and
        /// sampled a full cycle later.  If CPHA = 1, data is shifted and
        /// sampled with the trailing edge, also separated by a
        /// full cycle.
        #[inline(always)]
        pub fn fullcyc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// The phase of the sck clock signal relative to the data. When
        /// CPHA = 0, the data changes on the trailing edge of sck
        /// and is typically sampled on the leading edge.  Conversely
        /// if CPHA = 1 high, data lines change on the leading edge of
        /// sck and are typically sampled on the trailing edge.
        /// CPHA should be chosen to match the phase of the selected
        /// device.  The sampling behavior is modified by the
        /// !!CONFIGOPTS.FULLCYC bit.
        #[inline(always)]
        pub fn cpha(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// The polarity of the sck clock signal.  When CPOL is 0,
        /// sck is low when idle, and emits high pulses.   When CPOL
        /// is low, sck is high when idle, and emits a series of low
        /// pulses.
        #[inline(always)]
        pub fn cpol(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for ConfigoptsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ConfigoptsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ConfigoptsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlReadVal(u32);
    impl ControlReadVal {
        /// If !!EVENT_ENABLE.RXWM is set, the IP will send
        /// an interrupt when the depth of the RX FIFO reaches
        /// RX_WATERMARK words (32b each).
        #[inline(always)]
        pub fn rx_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// If !!EVENT_ENABLE.TXWM is set, the IP will send
        /// an interrupt when the depth of the TX FIFO drops below
        /// TX_WATERMARK words (32b each).
        #[inline(always)]
        pub fn tx_watermark(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Enable the SPI host output buffers for the sck, csb, and sd lines.  This allows
        /// the SPI_HOST IP to connect to the same bus as other SPI controllers without
        /// interference.
        #[inline(always)]
        pub fn output_en(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Clears the entire IP to the reset state when set to 1, including
        /// the FIFOs, the CDC's, the core state machine and the shift register.
        /// In the current implementation, the CDC FIFOs are drained not reset.
        /// Therefore software must confirm that both FIFO's empty before releasing
        /// the IP from reset.
        #[inline(always)]
        pub fn sw_rst(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Enables the SPI host.  On reset, this field is 0, meaning
        /// that no transactions can proceed.
        #[inline(always)]
        pub fn spien(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControlWriteVal {
            ControlWriteVal(self.0)
        }
    }
    impl From<u32> for ControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: ControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlWriteVal(u32);
    impl ControlWriteVal {
        /// If !!EVENT_ENABLE.RXWM is set, the IP will send
        /// an interrupt when the depth of the RX FIFO reaches
        /// RX_WATERMARK words (32b each).
        #[inline(always)]
        pub fn rx_watermark(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
        /// If !!EVENT_ENABLE.TXWM is set, the IP will send
        /// an interrupt when the depth of the TX FIFO drops below
        /// TX_WATERMARK words (32b each).
        #[inline(always)]
        pub fn tx_watermark(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
        }
        /// Enable the SPI host output buffers for the sck, csb, and sd lines.  This allows
        /// the SPI_HOST IP to connect to the same bus as other SPI controllers without
        /// interference.
        #[inline(always)]
        pub fn output_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Clears the entire IP to the reset state when set to 1, including
        /// the FIFOs, the CDC's, the core state machine and the shift register.
        /// In the current implementation, the CDC FIFOs are drained not reset.
        /// Therefore software must confirm that both FIFO's empty before releasing
        /// the IP from reset.
        #[inline(always)]
        pub fn sw_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
        }
        /// Enables the SPI host.  On reset, this field is 0, meaning
        /// that no transactions can proceed.
        #[inline(always)]
        pub fn spien(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for ControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorEnableReadVal(u32);
    impl ErrorEnableReadVal {
        /// Command Error: If this bit is set, the block sends an error
        /// interrupt whenever a command is issued while busy (i.e. a 1 is
        /// when !!STATUS.READY is not asserted.)
        #[inline(always)]
        pub fn cmdbusy(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Overflow Errors: If this bit is set, the block sends an
        /// error interrupt whenever the TX FIFO overflows.
        #[inline(always)]
        pub fn overflow(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Underflow Errors: If this bit is set, the block sends an
        /// error interrupt whenever there is a read from !!RXDATA
        /// but the RX FIFO is empty.
        #[inline(always)]
        pub fn underflow(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Invalid Command Errors: If this bit is set, the block sends an
        /// error interrupt whenever a command is sent with invalid values for
        /// !!COMMAND.SPEED or !!COMMAND.DIRECTION.
        #[inline(always)]
        pub fn cmdinval(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Invalid CSID: If this bit is set, the block sends an error interrupt whenever
        /// a command is submitted, but CSID exceeds NumCS.
        #[inline(always)]
        pub fn csidinval(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorEnableWriteVal {
            ErrorEnableWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorEnableWriteVal(u32);
    impl ErrorEnableWriteVal {
        /// Command Error: If this bit is set, the block sends an error
        /// interrupt whenever a command is issued while busy (i.e. a 1 is
        /// when !!STATUS.READY is not asserted.)
        #[inline(always)]
        pub fn cmdbusy(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Overflow Errors: If this bit is set, the block sends an
        /// error interrupt whenever the TX FIFO overflows.
        #[inline(always)]
        pub fn overflow(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Underflow Errors: If this bit is set, the block sends an
        /// error interrupt whenever there is a read from !!RXDATA
        /// but the RX FIFO is empty.
        #[inline(always)]
        pub fn underflow(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Invalid Command Errors: If this bit is set, the block sends an
        /// error interrupt whenever a command is sent with invalid values for
        /// !!COMMAND.SPEED or !!COMMAND.DIRECTION.
        #[inline(always)]
        pub fn cmdinval(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Invalid CSID: If this bit is set, the block sends an error interrupt whenever
        /// a command is submitted, but CSID exceeds NumCS.
        #[inline(always)]
        pub fn csidinval(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
    }
    impl From<u32> for ErrorEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorStatusReadVal(u32);
    impl ErrorStatusReadVal {
        /// Indicates a write to !!COMMAND when !!STATUS.READY = 0.
        #[inline(always)]
        pub fn cmdbusy(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Indicates that firmware has overflowed the TX FIFO
        #[inline(always)]
        pub fn overflow(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Indicates that firmware has attempted to read from
        /// !!RXDATA when the RX FIFO is empty.
        #[inline(always)]
        pub fn underflow(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Indicates an invalid command segment, meaning either an invalid value of
        /// !!COMMAND.SPEED or a request for bidirectional data transfer at dual or quad
        /// speed
        #[inline(always)]
        pub fn cmdinval(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Indicates a command was attempted with an invalid value for !!CSID.
        #[inline(always)]
        pub fn csidinval(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Indicates that TLUL attempted to write to TXDATA with no bytes enabled. Such
        /// 'zero byte' writes are not supported.
        #[inline(always)]
        pub fn accessinval(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorStatusWriteVal {
            ErrorStatusWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorStatusWriteVal(u32);
    impl ErrorStatusWriteVal {
        /// Indicates a write to !!COMMAND when !!STATUS.READY = 0.
        #[inline(always)]
        pub fn cmdbusy(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Indicates that firmware has overflowed the TX FIFO
        #[inline(always)]
        pub fn overflow(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Indicates that firmware has attempted to read from
        /// !!RXDATA when the RX FIFO is empty.
        #[inline(always)]
        pub fn underflow(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Indicates an invalid command segment, meaning either an invalid value of
        /// !!COMMAND.SPEED or a request for bidirectional data transfer at dual or quad
        /// speed
        #[inline(always)]
        pub fn cmdinval(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Indicates a command was attempted with an invalid value for !!CSID.
        #[inline(always)]
        pub fn csidinval(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Indicates that TLUL attempted to write to TXDATA with no bytes enabled. Such
        /// 'zero byte' writes are not supported.
        #[inline(always)]
        pub fn accessinval(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for ErrorStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct EventEnableReadVal(u32);
    impl EventEnableReadVal {
        /// Assert to send a spi_event interrupt whenever !!STATUS.RXFULL
        /// goes high
        #[inline(always)]
        pub fn rxfull(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.TXEMPTY
        /// goes high
        #[inline(always)]
        pub fn txempty(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
        /// the RX FIFO is greater than !!CONTROL.RX_WATERMARK. To prevent the
        /// reassertion of this interrupt, read more data from the RX FIFO, or
        /// increase !!CONTROL.RX_WATERMARK.
        #[inline(always)]
        pub fn rxwm(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
        /// the TX FIFO is less than !!CONTROL.TX_WATERMARK.  To prevent the
        /// reassertion of this interrupt add more data to the TX FIFO, or
        /// reduce !!CONTROL.TX_WATERMARK.
        #[inline(always)]
        pub fn txwm(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.READY
        /// goes high
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.ACTIVE
        /// goes low
        #[inline(always)]
        pub fn idle(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> EventEnableWriteVal {
            EventEnableWriteVal(self.0)
        }
    }
    impl From<u32> for EventEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<EventEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: EventEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct EventEnableWriteVal(u32);
    impl EventEnableWriteVal {
        /// Assert to send a spi_event interrupt whenever !!STATUS.RXFULL
        /// goes high
        #[inline(always)]
        pub fn rxfull(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.TXEMPTY
        /// goes high
        #[inline(always)]
        pub fn txempty(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
        /// the RX FIFO is greater than !!CONTROL.RX_WATERMARK. To prevent the
        /// reassertion of this interrupt, read more data from the RX FIFO, or
        /// increase !!CONTROL.RX_WATERMARK.
        #[inline(always)]
        pub fn rxwm(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
        /// the TX FIFO is less than !!CONTROL.TX_WATERMARK.  To prevent the
        /// reassertion of this interrupt add more data to the TX FIFO, or
        /// reduce !!CONTROL.TX_WATERMARK.
        #[inline(always)]
        pub fn txwm(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.READY
        /// goes high
        #[inline(always)]
        pub fn ready(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Assert to send a spi_event interrupt whenever !!STATUS.ACTIVE
        /// goes low
        #[inline(always)]
        pub fn idle(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for EventEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<EventEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: EventEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableReadVal(u32);
    impl InterruptEnableReadVal {
        /// Enable interrupt when error is set.
        #[inline(always)]
        pub fn error(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable interrupt when spi_event is set.
        #[inline(always)]
        pub fn spi_event(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableWriteVal {
            InterruptEnableWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableWriteVal(u32);
    impl InterruptEnableWriteVal {
        /// Enable interrupt when error is set.
        #[inline(always)]
        pub fn error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable interrupt when spi_event is set.
        #[inline(always)]
        pub fn spi_event(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateReadVal(u32);
    impl InterruptStateReadVal {
        /// Error-related interrupts, see !!ERROR_ENABLE register for more
        /// information.
        #[inline(always)]
        pub fn error(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Event-related interrupts, see !!EVENT_ENABLE register for more
        /// information.
        #[inline(always)]
        pub fn spi_event(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStateWriteVal {
            InterruptStateWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateWriteVal(u32);
    impl InterruptStateWriteVal {
        /// Error-related interrupts, see !!ERROR_ENABLE register for more
        /// information.
        #[inline(always)]
        pub fn error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Event-related interrupts, see !!EVENT_ENABLE register for more
        /// information.
        #[inline(always)]
        pub fn spi_event(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptStateWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptTestWriteVal(u32);
    impl InterruptTestWriteVal {
        /// Write 1 to force error to 1.
        #[inline(always)]
        pub fn error(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to force spi_event to 1.
        #[inline(always)]
        pub fn spi_event(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for InterruptTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Transmit queue depth. Indicates how many unsent 32-bit words
        /// are currently in the TX FIFO.  When active, this result may
        /// be an overestimate due to synchronization delays,
        #[inline(always)]
        pub fn txqd(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Receive queue depth. Indicates how many unread 32-bit words are
        /// currently in the RX FIFO.  When active, this result may an
        /// underestimate due to synchronization delays.
        #[inline(always)]
        pub fn rxqd(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Command queue depth. Indicates how many unread 32-bit words are
        /// currently in the command segment queue.
        #[inline(always)]
        pub fn cmdqd(&self) -> u32 {
            (self.0 >> 16) & 0xf
        }
        /// If high, the number of 32-bits in the RX FIFO now exceeds the
        /// !!CONTROL.RX_WATERMARK entries (32b each).
        #[inline(always)]
        pub fn rxwm(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// The value of the ByteOrder parameter, provided so that firmware
        /// can confirm proper IP configuration.
        #[inline(always)]
        pub fn byteorder(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// If high, signifies that an ongoing transaction has stalled
        /// due to lack of available space in the RX FIFO
        #[inline(always)]
        pub fn rxstall(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// When high, indicates that the receive fifo is empty.
        /// Any reads from RX FIFO will cause an error interrupt.
        #[inline(always)]
        pub fn rxempty(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// When high, indicates that the receive fifo is full.  Any
        /// ongoing transactions will stall until firmware reads some
        /// data from !!RXDATA.
        #[inline(always)]
        pub fn rxfull(&self) -> bool {
            ((self.0 >> 25) & 1) != 0
        }
        /// If high, the amount of data in the TX FIFO has fallen below the
        /// level of !!CONTROL.TX_WATERMARK words (32b each).
        #[inline(always)]
        pub fn txwm(&self) -> bool {
            ((self.0 >> 26) & 1) != 0
        }
        /// If high, signifies that an ongoing transaction has stalled
        /// due to lack of data in the TX FIFO
        #[inline(always)]
        pub fn txstall(&self) -> bool {
            ((self.0 >> 27) & 1) != 0
        }
        /// When high, indicates that the transmit data fifo is empty.
        #[inline(always)]
        pub fn txempty(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// When high, indicates that the transmit data fifo is full.
        /// Any further writes to !!RXDATA will create an error interrupt.
        #[inline(always)]
        pub fn txfull(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// When high, indicates the SPI host is processing a previously
        /// issued command.
        #[inline(always)]
        pub fn active(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// When high, indicates the SPI host is ready to receive
        /// commands. Writing to COMMAND when READY is low is
        /// an error, and will trigger an interrupt.
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type InterruptState = ureg::ReadWriteReg32<
        0,
        crate::spi_host::regs::InterruptStateReadVal,
        crate::spi_host::regs::InterruptStateWriteVal,
    >;
    pub type InterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::spi_host::regs::InterruptEnableReadVal,
        crate::spi_host::regs::InterruptEnableWriteVal,
    >;
    pub type InterruptTest = ureg::WriteOnlyReg32<0, crate::spi_host::regs::InterruptTestWriteVal>;
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::spi_host::regs::AlertTestWriteVal>;
    pub type Control = ureg::ReadWriteReg32<
        0x7f,
        crate::spi_host::regs::ControlReadVal,
        crate::spi_host::regs::ControlWriteVal,
    >;
    pub type Status = ureg::ReadOnlyReg32<crate::spi_host::regs::StatusReadVal>;
    pub type Configopts = ureg::ReadWriteReg32<
        0,
        crate::spi_host::regs::ConfigoptsReadVal,
        crate::spi_host::regs::ConfigoptsWriteVal,
    >;
    pub type Csid = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Command = ureg::WriteOnlyReg32<0, crate::spi_host::regs::CommandWriteVal>;
    pub type Rxdata = ureg::ReadOnlyReg32<u32>;
    pub type Txdata = ureg::WriteOnlyReg32<0, u32>;
    pub type ErrorEnable = ureg::ReadWriteReg32<
        0x1f,
        crate::spi_host::regs::ErrorEnableReadVal,
        crate::spi_host::regs::ErrorEnableWriteVal,
    >;
    pub type ErrorStatus = ureg::ReadWriteReg32<
        0,
        crate::spi_host::regs::ErrorStatusReadVal,
        crate::spi_host::regs::ErrorStatusWriteVal,
    >;
    pub type EventEnable = ureg::ReadWriteReg32<
        0,
        crate::spi_host::regs::EventEnableReadVal,
        crate::spi_host::regs::EventEnableWriteVal,
    >;
}

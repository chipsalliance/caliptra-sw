// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at bbc9a329abb109abee5befc39419a5336672d036
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct EntropySrcReg {
    _priv: (),
}
impl EntropySrcReg {
    pub const PTR: *mut u32 = 0x20003000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`entropy_src::regs::InterruptStateReadVal`]; Write value: [`entropy_src::regs::InterruptStateWriteVal`]
    #[inline(always)]
    pub fn interrupt_state(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::InterruptState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::InterruptEnableReadVal`]; Write value: [`entropy_src::regs::InterruptEnableWriteVal`]
    #[inline(always)]
    pub fn interrupt_enable(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::InterruptEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::InterruptTestReadVal`]; Write value: [`entropy_src::regs::InterruptTestWriteVal`]
    #[inline(always)]
    pub fn interrupt_test(&self) -> ureg::RegRef<crate::entropy_src::meta::InterruptTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AlertTestReadVal`]; Write value: [`entropy_src::regs::AlertTestWriteVal`]
    #[inline(always)]
    pub fn alert_test(&self) -> ureg::RegRef<crate::entropy_src::meta::AlertTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MeRegwenReadVal`]; Write value: [`entropy_src::regs::MeRegwenWriteVal`]
    #[inline(always)]
    pub fn me_regwen(&self) -> ureg::RegRef<crate::entropy_src::meta::MeRegwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::SwRegupdReadVal`]; Write value: [`entropy_src::regs::SwRegupdWriteVal`]
    #[inline(always)]
    pub fn sw_regupd(&self) -> ureg::RegRef<crate::entropy_src::meta::SwRegupd, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RegwenReadVal`]; Write value: [`entropy_src::regs::RegwenWriteVal`]
    #[inline(always)]
    pub fn regwen(&self) -> ureg::RegRef<crate::entropy_src::meta::Regwen, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RevReadVal`]; Write value: [`entropy_src::regs::RevWriteVal`]
    #[inline(always)]
    pub fn rev(&self) -> ureg::RegRef<crate::entropy_src::meta::Rev, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ModuleEnableReadVal`]; Write value: [`entropy_src::regs::ModuleEnableWriteVal`]
    #[inline(always)]
    pub fn module_enable(&self) -> ureg::RegRef<crate::entropy_src::meta::ModuleEnable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ConfReadVal`]; Write value: [`entropy_src::regs::ConfWriteVal`]
    #[inline(always)]
    pub fn conf(&self) -> ureg::RegRef<crate::entropy_src::meta::Conf, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::EntropyControlReadVal`]; Write value: [`entropy_src::regs::EntropyControlWriteVal`]
    #[inline(always)]
    pub fn entropy_control(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::EntropyControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn entropy_data(&self) -> ureg::RegRef<crate::entropy_src::meta::EntropyData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::HealthTestWindowsReadVal`]; Write value: [`entropy_src::regs::HealthTestWindowsWriteVal`]
    #[inline(always)]
    pub fn health_test_windows(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::HealthTestWindows, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RepcntThresholdsReadVal`]; Write value: [`entropy_src::regs::RepcntThresholdsWriteVal`]
    #[inline(always)]
    pub fn repcnt_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RepcntsThresholdsReadVal`]; Write value: [`entropy_src::regs::RepcntsThresholdsWriteVal`]
    #[inline(always)]
    pub fn repcnts_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntsThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AdaptpHiThresholdsReadVal`]; Write value: [`entropy_src::regs::AdaptpHiThresholdsWriteVal`]
    #[inline(always)]
    pub fn adaptp_hi_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpHiThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AdaptpLoThresholdsReadVal`]; Write value: [`entropy_src::regs::AdaptpLoThresholdsWriteVal`]
    #[inline(always)]
    pub fn adaptp_lo_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpLoThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::BucketThresholdsReadVal`]; Write value: [`entropy_src::regs::BucketThresholdsWriteVal`]
    #[inline(always)]
    pub fn bucket_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::BucketThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MarkovHiThresholdsReadVal`]; Write value: [`entropy_src::regs::MarkovHiThresholdsWriteVal`]
    #[inline(always)]
    pub fn markov_hi_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovHiThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MarkovLoThresholdsReadVal`]; Write value: [`entropy_src::regs::MarkovLoThresholdsWriteVal`]
    #[inline(always)]
    pub fn markov_lo_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovLoThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ExthtHiThresholdsReadVal`]; Write value: [`entropy_src::regs::ExthtHiThresholdsWriteVal`]
    #[inline(always)]
    pub fn extht_hi_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtHiThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ExthtLoThresholdsReadVal`]; Write value: [`entropy_src::regs::ExthtLoThresholdsWriteVal`]
    #[inline(always)]
    pub fn extht_lo_thresholds(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtLoThresholds, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RepcntHiWatermarksReadVal`]; Write value: [`entropy_src::regs::RepcntHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn repcnt_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RepcntsHiWatermarksReadVal`]; Write value: [`entropy_src::regs::RepcntsHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn repcnts_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntsHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AdaptpHiWatermarksReadVal`]; Write value: [`entropy_src::regs::AdaptpHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn adaptp_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AdaptpLoWatermarksReadVal`]; Write value: [`entropy_src::regs::AdaptpLoWatermarksWriteVal`]
    #[inline(always)]
    pub fn adaptp_lo_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpLoWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ExthtHiWatermarksReadVal`]; Write value: [`entropy_src::regs::ExthtHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn extht_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ExthtLoWatermarksReadVal`]; Write value: [`entropy_src::regs::ExthtLoWatermarksWriteVal`]
    #[inline(always)]
    pub fn extht_lo_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtLoWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x6c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::BucketHiWatermarksReadVal`]; Write value: [`entropy_src::regs::BucketHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn bucket_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::BucketHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MarkovHiWatermarksReadVal`]; Write value: [`entropy_src::regs::MarkovHiWatermarksWriteVal`]
    #[inline(always)]
    pub fn markov_hi_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovHiWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x74 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MarkovLoWatermarksReadVal`]; Write value: [`entropy_src::regs::MarkovLoWatermarksWriteVal`]
    #[inline(always)]
    pub fn markov_lo_watermarks(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovLoWatermarks, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x78 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn repcnt_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x7c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn repcnts_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::RepcntsTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn adaptp_hi_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpHiTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x84 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn adaptp_lo_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AdaptpLoTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x88 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn bucket_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::BucketTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x8c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn markov_hi_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovHiTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x90 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn markov_lo_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::MarkovLoTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x94 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn extht_hi_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtHiTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x98 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn extht_lo_total_fails(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtLoTotalFails, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x9c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AlertThresholdReadVal`]; Write value: [`entropy_src::regs::AlertThresholdWriteVal`]
    #[inline(always)]
    pub fn alert_threshold(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AlertThreshold, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AlertSummaryFailCountsReadVal`]; Write value: [`entropy_src::regs::AlertSummaryFailCountsWriteVal`]
    #[inline(always)]
    pub fn alert_summary_fail_counts(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AlertSummaryFailCounts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::AlertFailCountsReadVal`]; Write value: [`entropy_src::regs::AlertFailCountsWriteVal`]
    #[inline(always)]
    pub fn alert_fail_counts(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::AlertFailCounts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ExthtFailCountsReadVal`]; Write value: [`entropy_src::regs::ExthtFailCountsWriteVal`]
    #[inline(always)]
    pub fn extht_fail_counts(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ExthtFailCounts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xac / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::FwOvControlReadVal`]; Write value: [`entropy_src::regs::FwOvControlWriteVal`]
    #[inline(always)]
    pub fn fw_ov_control(&self) -> ureg::RegRef<crate::entropy_src::meta::FwOvControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::FwOvSha3StartReadVal`]; Write value: [`entropy_src::regs::FwOvSha3StartWriteVal`]
    #[inline(always)]
    pub fn fw_ov_sha3_start(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::FwOvSha3Start, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::FwOvWrFifoFullReadVal`]; Write value: [`entropy_src::regs::FwOvWrFifoFullWriteVal`]
    #[inline(always)]
    pub fn fw_ov_wr_fifo_full(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::FwOvWrFifoFull, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::FwOvRdFifoOverflowReadVal`]; Write value: [`entropy_src::regs::FwOvRdFifoOverflowWriteVal`]
    #[inline(always)]
    pub fn fw_ov_rd_fifo_overflow(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::FwOvRdFifoOverflow, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xbc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_ov_rd_data(&self) -> ureg::RegRef<crate::entropy_src::meta::FwOvRdData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_ov_wr_data(&self) -> ureg::RegRef<crate::entropy_src::meta::FwOvWrData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ObserveFifoThreshReadVal`]; Write value: [`entropy_src::regs::ObserveFifoThreshWriteVal`]
    #[inline(always)]
    pub fn observe_fifo_thresh(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ObserveFifoThresh, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ObserveFifoDepthReadVal`]; Write value: [`entropy_src::regs::ObserveFifoDepthWriteVal`]
    #[inline(always)]
    pub fn observe_fifo_depth(
        &self,
    ) -> ureg::RegRef<crate::entropy_src::meta::ObserveFifoDepth, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xcc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::DebugStatusReadVal`]; Write value: [`entropy_src::regs::DebugStatusWriteVal`]
    #[inline(always)]
    pub fn debug_status(&self) -> ureg::RegRef<crate::entropy_src::meta::DebugStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::RecovAlertStsReadVal`]; Write value: [`entropy_src::regs::RecovAlertStsWriteVal`]
    #[inline(always)]
    pub fn recov_alert_sts(&self) -> ureg::RegRef<crate::entropy_src::meta::RecovAlertSts, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ErrCodeReadVal`]; Write value: [`entropy_src::regs::ErrCodeWriteVal`]
    #[inline(always)]
    pub fn err_code(&self) -> ureg::RegRef<crate::entropy_src::meta::ErrCode, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::ErrCodeTestReadVal`]; Write value: [`entropy_src::regs::ErrCodeTestWriteVal`]
    #[inline(always)]
    pub fn err_code_test(&self) -> ureg::RegRef<crate::entropy_src::meta::ErrCodeTest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xdc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`entropy_src::regs::MainSmStateReadVal`]; Write value: [`entropy_src::regs::MainSmStateWriteVal`]
    #[inline(always)]
    pub fn main_sm_state(&self) -> ureg::RegRef<crate::entropy_src::meta::MainSmState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct AdaptpHiThresholdsReadVal(u32);
    impl AdaptpHiThresholdsReadVal {
        /// This is the threshold size for the adaptive proportion health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the adaptive proportion health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> AdaptpHiThresholdsWriteVal {
            AdaptpHiThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for AdaptpHiThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpHiThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpHiThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AdaptpHiThresholdsWriteVal(u32);
    impl AdaptpHiThresholdsWriteVal {
        /// This is the threshold size for the adaptive proportion health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the adaptive proportion health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for AdaptpHiThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpHiThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpHiThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AdaptpHiWatermarksReadVal(u32);
    impl AdaptpHiWatermarksReadVal {
        /// High watermark value of the adaptive proportion test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the adaptive proportion test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for AdaptpHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AdaptpLoThresholdsReadVal(u32);
    impl AdaptpLoThresholdsReadVal {
        /// This is the threshold size for the adaptive proportion health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the adaptive proportion health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> AdaptpLoThresholdsWriteVal {
            AdaptpLoThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for AdaptpLoThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpLoThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpLoThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AdaptpLoThresholdsWriteVal(u32);
    impl AdaptpLoThresholdsWriteVal {
        /// This is the threshold size for the adaptive proportion health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the adaptive proportion health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for AdaptpLoThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpLoThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpLoThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AdaptpLoWatermarksReadVal(u32);
    impl AdaptpLoWatermarksReadVal {
        /// Low watermark value of the adaptive proportion test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Low watermark value of the adaptive proportion test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for AdaptpLoWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AdaptpLoWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: AdaptpLoWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AlertFailCountsReadVal(u32);
    impl AlertFailCountsReadVal {
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn repcnt_fail_count(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn adaptp_hi_fail_count(&self) -> u32 {
            (self.0 >> 8) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn adaptp_lo_fail_count(&self) -> u32 {
            (self.0 >> 12) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn bucket_fail_count(&self) -> u32 {
            (self.0 >> 16) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn markov_hi_fail_count(&self) -> u32 {
            (self.0 >> 20) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn markov_lo_fail_count(&self) -> u32 {
            (self.0 >> 24) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn repcnts_fail_count(&self) -> u32 {
            (self.0 >> 28) & 0xf
        }
    }
    impl From<u32> for AlertFailCountsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertFailCountsReadVal> for u32 {
        #[inline(always)]
        fn from(val: AlertFailCountsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AlertSummaryFailCountsReadVal(u32);
    impl AlertSummaryFailCountsReadVal {
        /// This field will hold a running count of
        /// the total alert count, which is a sum of all of the other
        /// counters in the !!ALERT_FAIL_COUNTS register.
        /// It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn any_fail_count(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
    }
    impl From<u32> for AlertSummaryFailCountsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertSummaryFailCountsReadVal> for u32 {
        #[inline(always)]
        fn from(val: AlertSummaryFailCountsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AlertTestWriteVal(u32);
    impl AlertTestWriteVal {
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn recov_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to trigger one alert event of this kind.
        #[inline(always)]
        pub fn fatal_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for AlertTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AlertThresholdReadVal(u32);
    impl AlertThresholdReadVal {
        /// This is the threshold size that will signal an alert when
        /// value is reached. A value of zero will disable alerts.
        /// The default value is 2.
        #[inline(always)]
        pub fn alert_threshold(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This should be set to the value above, but inverted.
        #[inline(always)]
        pub fn alert_threshold_inv(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> AlertThresholdWriteVal {
            AlertThresholdWriteVal(self.0)
        }
    }
    impl From<u32> for AlertThresholdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertThresholdReadVal> for u32 {
        #[inline(always)]
        fn from(val: AlertThresholdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct AlertThresholdWriteVal(u32);
    impl AlertThresholdWriteVal {
        /// This is the threshold size that will signal an alert when
        /// value is reached. A value of zero will disable alerts.
        /// The default value is 2.
        #[inline(always)]
        pub fn alert_threshold(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This should be set to the value above, but inverted.
        #[inline(always)]
        pub fn alert_threshold_inv(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for AlertThresholdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<AlertThresholdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: AlertThresholdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct BucketHiWatermarksReadVal(u32);
    impl BucketHiWatermarksReadVal {
        /// High watermark value of the bucket test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the bucket test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for BucketHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<BucketHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: BucketHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct BucketThresholdsReadVal(u32);
    impl BucketThresholdsReadVal {
        /// This is the threshold size for the bucket health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the bucket health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> BucketThresholdsWriteVal {
            BucketThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for BucketThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<BucketThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: BucketThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct BucketThresholdsWriteVal(u32);
    impl BucketThresholdsWriteVal {
        /// This is the threshold size for the bucket health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the bucket health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for BucketThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<BucketThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: BucketThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ConfReadVal(u32);
    impl ConfReadVal {
        /// Setting this field to kMultiBitBool4True will enable FIPS qualified entropy to be
        /// generated.
        #[inline(always)]
        pub fn fips_enable(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Setting this field to kMultiBitBool4True will enable reading entropy values from the
        /// ENTROPY_DATA register. This function also requires that the otp_en_entropy_src_fw_read
        /// input vector is set to the enable encoding.
        #[inline(always)]
        pub fn entropy_data_reg_enable(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        /// This field controls the scope (either by-line or by-sum) of the health checks.
        /// If set to kMultiBitBool4True, the Adaptive Proportion and Markov Tests will accumulate all
        /// RNG input lines into a single score, and thresholds will be applied to the sum all
        /// the entropy input lines.  If set to kMultiBitBool4False, the RNG input lines are all scored
        /// individually.  A statistical deviation in any one input line, be it due to
        /// coincidence or failure, will force rejection of the sample, and count toward the
        /// total alert count.
        #[inline(always)]
        pub fn threshold_scope(&self) -> u32 {
            (self.0 >> 12) & 0xf
        }
        /// Setting this field to kMultiBitBool4True enables the single RNG bit mode, where only
        /// one bit is sampled.
        #[inline(always)]
        pub fn rng_bit_enable(&self) -> u32 {
            (self.0 >> 20) & 0xf
        }
        /// When the above bit iset, this field selects which bit from the RNG bus will
        /// be processed when in single RNG bit mode.
        /// This two bit field selects the RNG bit stream:
        /// 0b00: RNG bit 0
        /// 0b01: RNG bit 1
        /// 0b10: RNG bit 2
        /// 0b11: RNG bit 3
        #[inline(always)]
        pub fn rng_bit_sel(&self) -> u32 {
            (self.0 >> 24) & 3
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ConfWriteVal {
            ConfWriteVal(self.0)
        }
    }
    impl From<u32> for ConfReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ConfReadVal> for u32 {
        #[inline(always)]
        fn from(val: ConfReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ConfWriteVal(u32);
    impl ConfWriteVal {
        /// Setting this field to kMultiBitBool4True will enable FIPS qualified entropy to be
        /// generated.
        #[inline(always)]
        pub fn fips_enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        /// Setting this field to kMultiBitBool4True will enable reading entropy values from the
        /// ENTROPY_DATA register. This function also requires that the otp_en_entropy_src_fw_read
        /// input vector is set to the enable encoding.
        #[inline(always)]
        pub fn entropy_data_reg_enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
        /// This field controls the scope (either by-line or by-sum) of the health checks.
        /// If set to kMultiBitBool4True, the Adaptive Proportion and Markov Tests will accumulate all
        /// RNG input lines into a single score, and thresholds will be applied to the sum all
        /// the entropy input lines.  If set to kMultiBitBool4False, the RNG input lines are all scored
        /// individually.  A statistical deviation in any one input line, be it due to
        /// coincidence or failure, will force rejection of the sample, and count toward the
        /// total alert count.
        #[inline(always)]
        pub fn threshold_scope(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 12)) | ((val & 0xf) << 12))
        }
        /// Setting this field to kMultiBitBool4True enables the single RNG bit mode, where only
        /// one bit is sampled.
        #[inline(always)]
        pub fn rng_bit_enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 20)) | ((val & 0xf) << 20))
        }
        /// When the above bit iset, this field selects which bit from the RNG bus will
        /// be processed when in single RNG bit mode.
        /// This two bit field selects the RNG bit stream:
        /// 0b00: RNG bit 0
        /// 0b01: RNG bit 1
        /// 0b10: RNG bit 2
        /// 0b11: RNG bit 3
        #[inline(always)]
        pub fn rng_bit_sel(self, val: u32) -> Self {
            Self((self.0 & !(3 << 24)) | ((val & 3) << 24))
        }
    }
    impl From<u32> for ConfWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ConfWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ConfWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct DebugStatusReadVal(u32);
    impl DebugStatusReadVal {
        /// This is the depth of the entropy source FIFO.
        #[inline(always)]
        pub fn entropy_fifo_depth(&self) -> u32 {
            (self.0 >> 0) & 7
        }
        /// This is the SHA3 finite state machine current state.
        #[inline(always)]
        pub fn sha3_fsm(&self) -> u32 {
            (self.0 >> 3) & 7
        }
        /// This is the SHA3 block processed signal current state.
        #[inline(always)]
        pub fn sha3_block_pr(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// This is the SHA3 squeezing signal current state.
        #[inline(always)]
        pub fn sha3_squeezing(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// This is the SHA3 absorbed signal current state.
        #[inline(always)]
        pub fn sha3_absorbed(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// This is a logic-or of all of the SHA3 error signals.
        #[inline(always)]
        pub fn sha3_err(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// The entropy_src main state machine is in the idle state.
        #[inline(always)]
        pub fn main_sm_idle(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// The entropy_src main state machine is in the boot phase done state.
        #[inline(always)]
        pub fn main_sm_boot_done(&self) -> bool {
            ((self.0 >> 17) & 1) != 0
        }
    }
    impl From<u32> for DebugStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<DebugStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: DebugStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct EntropyControlReadVal(u32);
    impl EntropyControlReadVal {
        /// Setting this field to kMultiBitBool4True routes the generated entropy value to the ENTROPY_DATA
        /// register to be read by firmware. When this field is kMultiBitBool4False, the generated
        /// entropy will be forwarded out of this module to the hardware interface.
        #[inline(always)]
        pub fn es_route(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Setting this field to kMultiBitBool4True will bypass the conditioning logic and bring raw entropy
        /// data to the ENTROPY_DATA register. When kMultiBitBool4False, FIPS compliant entropy
        /// will be brought the ENTROPY_DATA register, after being conditioned.
        #[inline(always)]
        pub fn es_type(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> EntropyControlWriteVal {
            EntropyControlWriteVal(self.0)
        }
    }
    impl From<u32> for EntropyControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<EntropyControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: EntropyControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct EntropyControlWriteVal(u32);
    impl EntropyControlWriteVal {
        /// Setting this field to kMultiBitBool4True routes the generated entropy value to the ENTROPY_DATA
        /// register to be read by firmware. When this field is kMultiBitBool4False, the generated
        /// entropy will be forwarded out of this module to the hardware interface.
        #[inline(always)]
        pub fn es_route(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        /// Setting this field to kMultiBitBool4True will bypass the conditioning logic and bring raw entropy
        /// data to the ENTROPY_DATA register. When kMultiBitBool4False, FIPS compliant entropy
        /// will be brought the ENTROPY_DATA register, after being conditioned.
        #[inline(always)]
        pub fn es_type(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
    }
    impl From<u32> for EntropyControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<EntropyControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: EntropyControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeReadVal(u32);
    impl ErrCodeReadVal {
        /// This bit will be set to one when an error has been detected for the
        /// esrng FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_esrng_err(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// observe FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_observe_err(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// This bit will be set to one when an error has been detected for the
        /// esfinal FIFO. The type of error is reflected in the type status
        /// bits (bits 28 through 30 of this register).
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sfifo_esfinal_err(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// ES ack stage state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn es_ack_sm_err(&self) -> bool {
            ((self.0 >> 20) & 1) != 0
        }
        /// This bit will be set to one when an illegal state has been detected for the
        /// ES main stage state machine. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn es_main_sm_err(&self) -> bool {
            ((self.0 >> 21) & 1) != 0
        }
        /// This bit will be set to one when a hardened counter has detected an error
        /// condition. This error will signal a fatal alert, and also
        /// an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn es_cntr_err(&self) -> bool {
            ((self.0 >> 22) & 1) != 0
        }
        /// This bit will be set to one when a SHA3 state error has been detected.
        /// This error will signal a fatal alert, and also an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sha3_state_err(&self) -> bool {
            ((self.0 >> 23) & 1) != 0
        }
        /// This bit will be set to one when a SHA3_RST_STORAGE_ERR signal being
        /// active has been detected.
        /// This error will signal a fatal alert, and also an interrupt if enabled.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn sha3_rst_storage_err(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any full FIFO that has been recieved a write pulse.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_write_err(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any empty FIFO that has recieved a read pulse.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_read_err(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
        /// this register) are asserted as a result of an error pulse generated from
        /// any FIFO where both the empty and full status bits are set.
        /// This bit will stay set until the next reset.
        #[inline(always)]
        pub fn fifo_state_err(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
    }
    impl From<u32> for ErrCodeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeTestReadVal(u32);
    impl ErrCodeTestReadVal {
        /// Setting this field will set the bit number for which an error
        /// will be forced in the hardware. This bit number is that same one
        /// found in the !!ERR_CODE register. The action of writing this
        /// register will force an error pulse. The sole purpose of this
        /// register is to test that any error properly propagates to either
        /// an interrupt or an alert.
        #[inline(always)]
        pub fn err_code_test(&self) -> u32 {
            (self.0 >> 0) & 0x1f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrCodeTestWriteVal {
            ErrCodeTestWriteVal(self.0)
        }
    }
    impl From<u32> for ErrCodeTestReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeTestReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeTestReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrCodeTestWriteVal(u32);
    impl ErrCodeTestWriteVal {
        /// Setting this field will set the bit number for which an error
        /// will be forced in the hardware. This bit number is that same one
        /// found in the !!ERR_CODE register. The action of writing this
        /// register will force an error pulse. The sole purpose of this
        /// register is to test that any error properly propagates to either
        /// an interrupt or an alert.
        #[inline(always)]
        pub fn err_code_test(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 0)) | ((val & 0x1f) << 0))
        }
    }
    impl From<u32> for ErrCodeTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrCodeTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrCodeTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtFailCountsReadVal(u32);
    impl ExthtFailCountsReadVal {
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn extht_hi_fail_count(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// This field will hold a running count of test failures that
        /// contribute to the total alert count. It will be reset after every
        /// passing test sequence. If an alert is signaled, this value
        /// will persist until it is cleared.
        #[inline(always)]
        pub fn extht_lo_fail_count(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
    }
    impl From<u32> for ExthtFailCountsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtFailCountsReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtFailCountsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtHiThresholdsReadVal(u32);
    impl ExthtHiThresholdsReadVal {
        /// This is the threshold size for the external health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the external health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ExthtHiThresholdsWriteVal {
            ExthtHiThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for ExthtHiThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtHiThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtHiThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtHiThresholdsWriteVal(u32);
    impl ExthtHiThresholdsWriteVal {
        /// This is the threshold size for the external health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the external health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for ExthtHiThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtHiThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtHiThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtHiWatermarksReadVal(u32);
    impl ExthtHiWatermarksReadVal {
        /// High watermark value of the external health test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the external health test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for ExthtHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtLoThresholdsReadVal(u32);
    impl ExthtLoThresholdsReadVal {
        /// This is the threshold size for the external health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the external health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ExthtLoThresholdsWriteVal {
            ExthtLoThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for ExthtLoThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtLoThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtLoThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtLoThresholdsWriteVal(u32);
    impl ExthtLoThresholdsWriteVal {
        /// This is the threshold size for the external health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the external health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for ExthtLoThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtLoThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtLoThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExthtLoWatermarksReadVal(u32);
    impl ExthtLoWatermarksReadVal {
        /// Low watermark value of the external health test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Low watermark value of the external health test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for ExthtLoWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExthtLoWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExthtLoWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvControlReadVal(u32);
    impl FwOvControlReadVal {
        /// Setting this field to kMultiBitBool4True will put the entropy flow in firmware override mode.
        /// In this mode, firmware can monitor the post-health test entropy by reading
        /// the observe FIFO. This function also requires that the otp_en_entropy_src_fw_over
        /// input vector is set to the enable encoding.
        #[inline(always)]
        pub fn fw_ov_mode(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Setting this field to kMultiBitBool4True will switch the input into the pre-conditioner
        /// packer FIFO. Firmware can directly write into the packer FIFO, enabling
        /// the ability to insert entropy bits back into the hardware flow. Firmware
        /// can read data from the health check packer FIFO, then do optional health
        /// checks or optional conditioning, then insert the results back into the flow.
        /// Also, the !!FW_OV_CONTROL.FW_OV_MODE bit must be set.
        #[inline(always)]
        pub fn fw_ov_entropy_insert(&self) -> u32 {
            (self.0 >> 4) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FwOvControlWriteVal {
            FwOvControlWriteVal(self.0)
        }
    }
    impl From<u32> for FwOvControlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvControlReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvControlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvControlWriteVal(u32);
    impl FwOvControlWriteVal {
        /// Setting this field to kMultiBitBool4True will put the entropy flow in firmware override mode.
        /// In this mode, firmware can monitor the post-health test entropy by reading
        /// the observe FIFO. This function also requires that the otp_en_entropy_src_fw_over
        /// input vector is set to the enable encoding.
        #[inline(always)]
        pub fn fw_ov_mode(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        /// Setting this field to kMultiBitBool4True will switch the input into the pre-conditioner
        /// packer FIFO. Firmware can directly write into the packer FIFO, enabling
        /// the ability to insert entropy bits back into the hardware flow. Firmware
        /// can read data from the health check packer FIFO, then do optional health
        /// checks or optional conditioning, then insert the results back into the flow.
        /// Also, the !!FW_OV_CONTROL.FW_OV_MODE bit must be set.
        #[inline(always)]
        pub fn fw_ov_entropy_insert(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 4)) | ((val & 0xf) << 4))
        }
    }
    impl From<u32> for FwOvControlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvControlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvControlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvRdFifoOverflowReadVal(u32);
    impl FwOvRdFifoOverflowReadVal {
        /// This bit is set by hardware whenever RNG data is lost due to an overflow condition
        /// in the Observe FIFO. The RNG data rate is slow enough that firmware should always
        /// be able to keep up. This register meanwhile provides an additional check to confirm
        /// that bytes read from the !!FW_OV_RD_DATA register represent contiguous RNG samples.
        /// If an overflow event occurs, this bit must be cleared by software.
        #[inline(always)]
        pub fn fw_ov_rd_fifo_overflow(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FwOvRdFifoOverflowWriteVal {
            FwOvRdFifoOverflowWriteVal(self.0)
        }
    }
    impl From<u32> for FwOvRdFifoOverflowReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvRdFifoOverflowReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvRdFifoOverflowReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvRdFifoOverflowWriteVal(u32);
    impl FwOvRdFifoOverflowWriteVal {
        /// This bit is set by hardware whenever RNG data is lost due to an overflow condition
        /// in the Observe FIFO. The RNG data rate is slow enough that firmware should always
        /// be able to keep up. This register meanwhile provides an additional check to confirm
        /// that bytes read from the !!FW_OV_RD_DATA register represent contiguous RNG samples.
        /// If an overflow event occurs, this bit must be cleared by software.
        #[inline(always)]
        pub fn fw_ov_rd_fifo_overflow(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for FwOvRdFifoOverflowWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvRdFifoOverflowWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvRdFifoOverflowWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvSha3StartReadVal(u32);
    impl FwOvSha3StartReadVal {
        /// Setting this field to kMultiBitBool4True will instruct the ENTROPY_SRC main state machine
        /// to start the SHA3 process and be ready to accept entropy data. This field should
        /// be set prior to writting the FW_OV_WR_DATA register. Once all data has been written,
        /// this field should be set to kMultiBitBool4False. Once that happened, the SHA3 block will finish
        /// processing and push the result into the ESFINAL FIFO.
        ///
        /// Note that clearing this bit to kMultiBitBool4False while there is still unprocessed
        /// entropy in the !!FW_OV_WR_DATA will start the SHA3 engine before data can be added
        /// to the input message, and will also signal a recoverable alert in
        /// !!RECOV_ALERT_STS.ES_FW_OV_DISABLE_ALERT.  To avoid this, check that
        /// !!FW_OV_WR_FIFO_FULL is clear before setting this field to kMultiBitBool4False.
        #[inline(always)]
        pub fn fw_ov_insert_start(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FwOvSha3StartWriteVal {
            FwOvSha3StartWriteVal(self.0)
        }
    }
    impl From<u32> for FwOvSha3StartReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvSha3StartReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvSha3StartReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvSha3StartWriteVal(u32);
    impl FwOvSha3StartWriteVal {
        /// Setting this field to kMultiBitBool4True will instruct the ENTROPY_SRC main state machine
        /// to start the SHA3 process and be ready to accept entropy data. This field should
        /// be set prior to writting the FW_OV_WR_DATA register. Once all data has been written,
        /// this field should be set to kMultiBitBool4False. Once that happened, the SHA3 block will finish
        /// processing and push the result into the ESFINAL FIFO.
        ///
        /// Note that clearing this bit to kMultiBitBool4False while there is still unprocessed
        /// entropy in the !!FW_OV_WR_DATA will start the SHA3 engine before data can be added
        /// to the input message, and will also signal a recoverable alert in
        /// !!RECOV_ALERT_STS.ES_FW_OV_DISABLE_ALERT.  To avoid this, check that
        /// !!FW_OV_WR_FIFO_FULL is clear before setting this field to kMultiBitBool4False.
        #[inline(always)]
        pub fn fw_ov_insert_start(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for FwOvSha3StartWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvSha3StartWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvSha3StartWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FwOvWrFifoFullReadVal(u32);
    impl FwOvWrFifoFullReadVal {
        /// "When this bit is clear, writes to the FW_OV_WR_DATA register are allowed.
        /// If this bit is set, it is the equivalent to a FIFO full condition, and writes
        /// to the FW_OV_WR_DATA register must be delayed until this bit is reset.
        #[inline(always)]
        pub fn fw_ov_wr_fifo_full(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for FwOvWrFifoFullReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwOvWrFifoFullReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwOvWrFifoFullReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HealthTestWindowsReadVal(u32);
    impl HealthTestWindowsReadVal {
        /// This is the window size for all health tests. This value is used in normal mode
        /// when entropy is being tested in FIPS/CC compliance mode.
        /// The default value is (2048 bits * 1 clock/4 bits);
        #[inline(always)]
        pub fn fips_window(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the window size for all health tests when running in bypass mode. This mode
        /// is active after reset for the first and only test run, or when this mode is
        /// programmed by firmware.
        /// The default value is (384 bits * 1 clock/4 bits);
        ///
        /// Note that currently only a window size of 384 is supported and tested (this
        /// corresponds to the register default value 0x60). Do not use any other values,
        /// unless you know what you are doing.
        #[inline(always)]
        pub fn bypass_window(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HealthTestWindowsWriteVal {
            HealthTestWindowsWriteVal(self.0)
        }
    }
    impl From<u32> for HealthTestWindowsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HealthTestWindowsReadVal> for u32 {
        #[inline(always)]
        fn from(val: HealthTestWindowsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct HealthTestWindowsWriteVal(u32);
    impl HealthTestWindowsWriteVal {
        /// This is the window size for all health tests. This value is used in normal mode
        /// when entropy is being tested in FIPS/CC compliance mode.
        /// The default value is (2048 bits * 1 clock/4 bits);
        #[inline(always)]
        pub fn fips_window(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the window size for all health tests when running in bypass mode. This mode
        /// is active after reset for the first and only test run, or when this mode is
        /// programmed by firmware.
        /// The default value is (384 bits * 1 clock/4 bits);
        ///
        /// Note that currently only a window size of 384 is supported and tested (this
        /// corresponds to the register default value 0x60). Do not use any other values,
        /// unless you know what you are doing.
        #[inline(always)]
        pub fn bypass_window(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for HealthTestWindowsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HealthTestWindowsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HealthTestWindowsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableReadVal(u32);
    impl InterruptEnableReadVal {
        /// Enable interrupt when es_entropy_valid is set.
        #[inline(always)]
        pub fn es_entropy_valid(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable interrupt when es_health_test_failed is set.
        #[inline(always)]
        pub fn es_health_test_failed(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable interrupt when es_observe_fifo_ready is set.
        #[inline(always)]
        pub fn es_observe_fifo_ready(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable interrupt when es_fatal_err is set.
        #[inline(always)]
        pub fn es_fatal_err(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptEnableWriteVal {
            InterruptEnableWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptEnableWriteVal(u32);
    impl InterruptEnableWriteVal {
        /// Enable interrupt when es_entropy_valid is set.
        #[inline(always)]
        pub fn es_entropy_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable interrupt when es_health_test_failed is set.
        #[inline(always)]
        pub fn es_health_test_failed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable interrupt when es_observe_fifo_ready is set.
        #[inline(always)]
        pub fn es_observe_fifo_ready(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable interrupt when es_fatal_err is set.
        #[inline(always)]
        pub fn es_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateReadVal(u32);
    impl InterruptStateReadVal {
        /// Asserted when entropy source bits are available.
        #[inline(always)]
        pub fn es_entropy_valid(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Asserted when the alert count has been met.
        #[inline(always)]
        pub fn es_health_test_failed(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Asserted when the observe FIFO has filled to the threshold level.
        #[inline(always)]
        pub fn es_observe_fifo_ready(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Asserted when a FIFO error occurs, or if an illegal state machine state is reached.
        #[inline(always)]
        pub fn es_fatal_err(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InterruptStateWriteVal {
            InterruptStateWriteVal(self.0)
        }
    }
    impl From<u32> for InterruptStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptStateWriteVal(u32);
    impl InterruptStateWriteVal {
        /// Asserted when entropy source bits are available.
        #[inline(always)]
        pub fn es_entropy_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Asserted when the alert count has been met.
        #[inline(always)]
        pub fn es_health_test_failed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Asserted when the observe FIFO has filled to the threshold level.
        #[inline(always)]
        pub fn es_observe_fifo_ready(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Asserted when a FIFO error occurs, or if an illegal state machine state is reached.
        #[inline(always)]
        pub fn es_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptStateWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptStateWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptStateWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InterruptTestWriteVal(u32);
    impl InterruptTestWriteVal {
        /// Write 1 to force es_entropy_valid to 1.
        #[inline(always)]
        pub fn es_entropy_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Write 1 to force es_health_test_failed to 1.
        #[inline(always)]
        pub fn es_health_test_failed(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Write 1 to force es_observe_fifo_ready to 1.
        #[inline(always)]
        pub fn es_observe_fifo_ready(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Write 1 to force es_fatal_err to 1.
        #[inline(always)]
        pub fn es_fatal_err(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
    }
    impl From<u32> for InterruptTestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InterruptTestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InterruptTestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MainSmStateReadVal(u32);
    impl MainSmStateReadVal {
        /// This is the state of the ENTROPY_SRC main state machine.
        /// See the RTL file `entropy_src_main_sm` for the meaning of the values.
        #[inline(always)]
        pub fn main_sm_state(&self) -> u32 {
            (self.0 >> 0) & 0x1ff
        }
    }
    impl From<u32> for MainSmStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MainSmStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: MainSmStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovHiThresholdsReadVal(u32);
    impl MarkovHiThresholdsReadVal {
        /// This is the threshold size for the Markov health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the Markov health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MarkovHiThresholdsWriteVal {
            MarkovHiThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for MarkovHiThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovHiThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovHiThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovHiThresholdsWriteVal(u32);
    impl MarkovHiThresholdsWriteVal {
        /// This is the threshold size for the Markov health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the Markov health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for MarkovHiThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovHiThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovHiThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovHiWatermarksReadVal(u32);
    impl MarkovHiWatermarksReadVal {
        /// High watermark value of the Markov test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the Markov test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for MarkovHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovLoThresholdsReadVal(u32);
    impl MarkovLoThresholdsReadVal {
        /// This is the threshold size for the Markov health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the Markov health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MarkovLoThresholdsWriteVal {
            MarkovLoThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for MarkovLoThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovLoThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovLoThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovLoThresholdsWriteVal(u32);
    impl MarkovLoThresholdsWriteVal {
        /// This is the threshold size for the Markov health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the Markov health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is greater than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for MarkovLoThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovLoThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovLoThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MarkovLoWatermarksReadVal(u32);
    impl MarkovLoWatermarksReadVal {
        /// Low watermark value of the Markov test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Low watermark value of the Markov test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for MarkovLoWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MarkovLoWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: MarkovLoWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MeRegwenReadVal(u32);
    impl MeRegwenReadVal {
        /// When true, the !!MODULE_ENABLE register can be modified.
        /// When false, it becomes read-only.
        #[inline(always)]
        pub fn me_regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> MeRegwenWriteVal {
            MeRegwenWriteVal(self.0)
        }
    }
    impl From<u32> for MeRegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MeRegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: MeRegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct MeRegwenWriteVal(u32);
    impl MeRegwenWriteVal {
        /// When true, the !!MODULE_ENABLE register can be modified.
        /// When false, it becomes read-only.
        #[inline(always)]
        pub fn me_regwen(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for MeRegwenWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<MeRegwenWriteVal> for u32 {
        #[inline(always)]
        fn from(val: MeRegwenWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ModuleEnableReadVal(u32);
    impl ModuleEnableReadVal {
        /// Setting this field to kMultiBitBool4True will enable the ENTROPY_SRC module. Setting
        /// this field to kMultiBitBool4False will effectively reset the module. The modules of
        /// the entropy complex may only be enabled and disabled in a specific order, see
        /// Programmers Guide for details.
        #[inline(always)]
        pub fn module_enable(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ModuleEnableWriteVal {
            ModuleEnableWriteVal(self.0)
        }
    }
    impl From<u32> for ModuleEnableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ModuleEnableReadVal> for u32 {
        #[inline(always)]
        fn from(val: ModuleEnableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ModuleEnableWriteVal(u32);
    impl ModuleEnableWriteVal {
        /// Setting this field to kMultiBitBool4True will enable the ENTROPY_SRC module. Setting
        /// this field to kMultiBitBool4False will effectively reset the module. The modules of
        /// the entropy complex may only be enabled and disabled in a specific order, see
        /// Programmers Guide for details.
        #[inline(always)]
        pub fn module_enable(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for ModuleEnableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ModuleEnableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ModuleEnableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ObserveFifoDepthReadVal(u32);
    impl ObserveFifoDepthReadVal {
        /// This field will hold the current depth of the Observe FIFO.
        #[inline(always)]
        pub fn observe_fifo_depth(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
    }
    impl From<u32> for ObserveFifoDepthReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ObserveFifoDepthReadVal> for u32 {
        #[inline(always)]
        fn from(val: ObserveFifoDepthReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ObserveFifoThreshReadVal(u32);
    impl ObserveFifoThreshReadVal {
        /// This field will set the threshold that the depth of the Observe FIFO
        /// will be compared with when setting the interrupt status bit.
        /// Note: a value of zero is reserved and not to be used.
        #[inline(always)]
        pub fn observe_fifo_thresh(&self) -> u32 {
            (self.0 >> 0) & 0x7f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ObserveFifoThreshWriteVal {
            ObserveFifoThreshWriteVal(self.0)
        }
    }
    impl From<u32> for ObserveFifoThreshReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ObserveFifoThreshReadVal> for u32 {
        #[inline(always)]
        fn from(val: ObserveFifoThreshReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ObserveFifoThreshWriteVal(u32);
    impl ObserveFifoThreshWriteVal {
        /// This field will set the threshold that the depth of the Observe FIFO
        /// will be compared with when setting the interrupt status bit.
        /// Note: a value of zero is reserved and not to be used.
        #[inline(always)]
        pub fn observe_fifo_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0x7f << 0)) | ((val & 0x7f) << 0))
        }
    }
    impl From<u32> for ObserveFifoThreshWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ObserveFifoThreshWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ObserveFifoThreshWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecovAlertStsReadVal(u32);
    impl RecovAlertStsReadVal {
        /// This bit is set when the FIPS_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fips_enable_field_alert(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// This bit is set when the ENTROPY_DATA_REG_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn entropy_data_reg_en_field_alert(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// This bit is set when the MODULE_ENABLE field in the !!MODULE_ENABLE register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn module_enable_field_alert(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// This bit is set when the THRESHOLD_SCOPE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn threshold_scope_field_alert(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// This bit is set when the RNG_BIT_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn rng_bit_enable_field_alert(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// This bit is set when the FW_OV_SHA3_START field in the !!FW_OV_SHA3_START register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_sha3_start_field_alert(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// This bit is set when the FW_OV_MODE field in the !!FW_OV_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_mode_field_alert(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// This bit is set when the FW_OV_ENTROPY_INSERT field in the !!FW_OV_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_entropy_insert_field_alert(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// This bit is set when the ES_ROUTE field in the !!ENTROPY_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_route_field_alert(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// This bit is set when the ES_TYPE field in the !!ENTROPY_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_type_field_alert(&self) -> bool {
            ((self.0 >> 11) & 1) != 0
        }
        /// This bit is set when the main state machine detects a threshhold failure state.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_main_sm_alert(&self) -> bool {
            ((self.0 >> 12) & 1) != 0
        }
        /// This bit is set when the interal entropy bus value is equal to the prior
        /// valid value on the bus, indicating a possible attack.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_bus_cmp_alert(&self) -> bool {
            ((self.0 >> 13) & 1) != 0
        }
        /// This bit is set when the !!ALERT_THRESHOLD register is not configured properly.
        /// The upper field must be the exact inverse of the lower field.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_thresh_cfg_alert(&self) -> bool {
            ((self.0 >> 14) & 1) != 0
        }
        /// This bit is set when the packer FIFO has been written but was full at the time,
        /// and in both FW_OV_MODE and FW_OV_ENTROPY_INSERT modes.
        /// This alert would normally be the result of not monitoring the !!FW_OV_WR_FIFO_FULL
        /// register before each write to the !!FW_OV_WR_DATA register.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_fw_ov_wr_alert(&self) -> bool {
            ((self.0 >> 15) & 1) != 0
        }
        /// This bit is set when !!FW_OV_SHA3_START has been set to MuBi4 False, without
        /// waiting for the FW_OV packer FIFO to clear.  The final entropy entry in the FIFO
        /// will not be included in the SHA3 digest. (Rather it will be added to the
        /// subsequent SHA3 digest.) To avoid this alert, monitor !!FW_OV_WR_FIFO_FULL before
        /// clearing !!FW_OV_SHA3_START. This alert only applies when both FW_OV_MODE and
        /// FW_OV_ENTROPY_INSERT are set to MuBi4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_fw_ov_disable_alert(&self) -> bool {
            ((self.0 >> 16) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RecovAlertStsWriteVal {
            RecovAlertStsWriteVal(self.0)
        }
    }
    impl From<u32> for RecovAlertStsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecovAlertStsReadVal> for u32 {
        #[inline(always)]
        fn from(val: RecovAlertStsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RecovAlertStsWriteVal(u32);
    impl RecovAlertStsWriteVal {
        /// This bit is set when the FIPS_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fips_enable_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// This bit is set when the ENTROPY_DATA_REG_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn entropy_data_reg_en_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// This bit is set when the MODULE_ENABLE field in the !!MODULE_ENABLE register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn module_enable_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// This bit is set when the THRESHOLD_SCOPE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn threshold_scope_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// This bit is set when the RNG_BIT_ENABLE field in the !!CONF register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn rng_bit_enable_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// This bit is set when the FW_OV_SHA3_START field in the !!FW_OV_SHA3_START register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_sha3_start_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// This bit is set when the FW_OV_MODE field in the !!FW_OV_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_mode_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// This bit is set when the FW_OV_ENTROPY_INSERT field in the !!FW_OV_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn fw_ov_entropy_insert_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// This bit is set when the ES_ROUTE field in the !!ENTROPY_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_route_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// This bit is set when the ES_TYPE field in the !!ENTROPY_CONTROL register is set to
        /// a value other than kMultiBitBool4False or kMultiBitBool4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_type_field_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
        }
        /// This bit is set when the main state machine detects a threshhold failure state.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_main_sm_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
        }
        /// This bit is set when the interal entropy bus value is equal to the prior
        /// valid value on the bus, indicating a possible attack.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_bus_cmp_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
        }
        /// This bit is set when the !!ALERT_THRESHOLD register is not configured properly.
        /// The upper field must be the exact inverse of the lower field.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_thresh_cfg_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
        }
        /// This bit is set when the packer FIFO has been written but was full at the time,
        /// and in both FW_OV_MODE and FW_OV_ENTROPY_INSERT modes.
        /// This alert would normally be the result of not monitoring the !!FW_OV_WR_FIFO_FULL
        /// register before each write to the !!FW_OV_WR_DATA register.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_fw_ov_wr_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
        }
        /// This bit is set when !!FW_OV_SHA3_START has been set to MuBi4 False, without
        /// waiting for the FW_OV packer FIFO to clear.  The final entropy entry in the FIFO
        /// will not be included in the SHA3 digest. (Rather it will be added to the
        /// subsequent SHA3 digest.) To avoid this alert, monitor !!FW_OV_WR_FIFO_FULL before
        /// clearing !!FW_OV_SHA3_START. This alert only applies when both FW_OV_MODE and
        /// FW_OV_ENTROPY_INSERT are set to MuBi4True.
        /// Writing a zero resets this status bit.
        #[inline(always)]
        pub fn es_fw_ov_disable_alert(self, val: bool) -> Self {
            Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
        }
    }
    impl From<u32> for RecovAlertStsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RecovAlertStsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RecovAlertStsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RegwenReadVal(u32);
    impl RegwenReadVal {
        /// This read-only write enable bit will allow write access
        /// to control and theshold registers that are associated with this bit,
        /// but only when the MODULE_ENABLE field is set to kMultiBitBool4False and the
        /// SW_REGUPD write enable bit is set to true.
        /// When read as false, these registers become read-only.
        #[inline(always)]
        pub fn regwen(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for RegwenReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RegwenReadVal> for u32 {
        #[inline(always)]
        fn from(val: RegwenReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntsHiWatermarksReadVal(u32);
    impl RepcntsHiWatermarksReadVal {
        /// High watermark value of the REPCNTS test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the REPCNTS test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for RepcntsHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntsHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntsHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntsThresholdsReadVal(u32);
    impl RepcntsThresholdsReadVal {
        /// This is the threshold size for the repetition count symbol health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the repetition count symbol health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RepcntsThresholdsWriteVal {
            RepcntsThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for RepcntsThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntsThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntsThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntsThresholdsWriteVal(u32);
    impl RepcntsThresholdsWriteVal {
        /// This is the threshold size for the repetition count symbol health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the repetition count symbol health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for RepcntsThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntsThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntsThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntHiWatermarksReadVal(u32);
    impl RepcntHiWatermarksReadVal {
        /// High watermark value of the REPCNT test in FIPS mode.
        #[inline(always)]
        pub fn fips_watermark(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// High watermark value of the REPCNT test in bypass mode.
        #[inline(always)]
        pub fn bypass_watermark(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for RepcntHiWatermarksReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntHiWatermarksReadVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntHiWatermarksReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntThresholdsReadVal(u32);
    impl RepcntThresholdsReadVal {
        /// This is the threshold size for the repetition count health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// This is the threshold size for the repetition count health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> RepcntThresholdsWriteVal {
            RepcntThresholdsWriteVal(self.0)
        }
    }
    impl From<u32> for RepcntThresholdsReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntThresholdsReadVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntThresholdsReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RepcntThresholdsWriteVal(u32);
    impl RepcntThresholdsWriteVal {
        /// This is the threshold size for the repetition count health test.
        /// This value is used in normal mode when entropy is being tested in
        /// FIPS/CC compliance mode.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn fips_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        /// This is the threshold size for the repetition count health test
        /// running in bypass mode. This mode is active after reset for the
        /// first and only test run, or when this mode is programmed by firmware.
        /// This register must be written before the module is enabled.
        /// Writing to this register will only update the register if the
        /// written value is less than the current value of this register.
        /// A read from this register always reflects the current value.
        #[inline(always)]
        pub fn bypass_thresh(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for RepcntThresholdsWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RepcntThresholdsWriteVal> for u32 {
        #[inline(always)]
        fn from(val: RepcntThresholdsWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct RevReadVal(u32);
    impl RevReadVal {
        /// Read of this register shows the ABI of this block.
        #[inline(always)]
        pub fn abi_revision(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Read of this register shows the revision of this block.
        #[inline(always)]
        pub fn hw_revision(&self) -> u32 {
            (self.0 >> 8) & 0xff
        }
        /// Read of this register shows the type of chip using this block.
        #[inline(always)]
        pub fn chip_type(&self) -> u32 {
            (self.0 >> 16) & 0xff
        }
    }
    impl From<u32> for RevReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<RevReadVal> for u32 {
        #[inline(always)]
        fn from(val: RevReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SwRegupdReadVal(u32);
    impl SwRegupdReadVal {
        /// When this bit true and the MODULE_ENABLE field is false,
        /// the REGWEN write enable bit read as true, and is distributed to
        /// all associated control and threshold registers.
        /// When false, these registers become read-only.
        #[inline(always)]
        pub fn sw_regupd(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> SwRegupdWriteVal {
            SwRegupdWriteVal(self.0)
        }
    }
    impl From<u32> for SwRegupdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SwRegupdReadVal> for u32 {
        #[inline(always)]
        fn from(val: SwRegupdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct SwRegupdWriteVal(u32);
    impl SwRegupdWriteVal {
        /// When this bit true and the MODULE_ENABLE field is false,
        /// the REGWEN write enable bit read as true, and is distributed to
        /// all associated control and threshold registers.
        /// When false, these registers become read-only.
        #[inline(always)]
        pub fn sw_regupd(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for SwRegupdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<SwRegupdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: SwRegupdWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type InterruptState = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::InterruptStateReadVal,
        crate::entropy_src::regs::InterruptStateWriteVal,
    >;
    pub type InterruptEnable = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::InterruptEnableReadVal,
        crate::entropy_src::regs::InterruptEnableWriteVal,
    >;
    pub type InterruptTest =
        ureg::WriteOnlyReg32<0, crate::entropy_src::regs::InterruptTestWriteVal>;
    pub type AlertTest = ureg::WriteOnlyReg32<0, crate::entropy_src::regs::AlertTestWriteVal>;
    pub type MeRegwen = ureg::ReadWriteReg32<
        1,
        crate::entropy_src::regs::MeRegwenReadVal,
        crate::entropy_src::regs::MeRegwenWriteVal,
    >;
    pub type SwRegupd = ureg::ReadWriteReg32<
        1,
        crate::entropy_src::regs::SwRegupdReadVal,
        crate::entropy_src::regs::SwRegupdWriteVal,
    >;
    pub type Regwen = ureg::ReadOnlyReg32<crate::entropy_src::regs::RegwenReadVal>;
    pub type Rev = ureg::ReadOnlyReg32<crate::entropy_src::regs::RevReadVal>;
    pub type ModuleEnable = ureg::ReadWriteReg32<
        9,
        crate::entropy_src::regs::ModuleEnableReadVal,
        crate::entropy_src::regs::ModuleEnableWriteVal,
    >;
    pub type Conf = ureg::ReadWriteReg32<
        0x909099,
        crate::entropy_src::regs::ConfReadVal,
        crate::entropy_src::regs::ConfWriteVal,
    >;
    pub type EntropyControl = ureg::ReadWriteReg32<
        0x99,
        crate::entropy_src::regs::EntropyControlReadVal,
        crate::entropy_src::regs::EntropyControlWriteVal,
    >;
    pub type EntropyData = ureg::ReadOnlyReg32<u32>;
    pub type HealthTestWindows = ureg::ReadWriteReg32<
        0x600200,
        crate::entropy_src::regs::HealthTestWindowsReadVal,
        crate::entropy_src::regs::HealthTestWindowsWriteVal,
    >;
    pub type RepcntThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::RepcntThresholdsReadVal,
        crate::entropy_src::regs::RepcntThresholdsWriteVal,
    >;
    pub type RepcntsThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::RepcntsThresholdsReadVal,
        crate::entropy_src::regs::RepcntsThresholdsWriteVal,
    >;
    pub type AdaptpHiThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::AdaptpHiThresholdsReadVal,
        crate::entropy_src::regs::AdaptpHiThresholdsWriteVal,
    >;
    pub type AdaptpLoThresholds = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::AdaptpLoThresholdsReadVal,
        crate::entropy_src::regs::AdaptpLoThresholdsWriteVal,
    >;
    pub type BucketThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::BucketThresholdsReadVal,
        crate::entropy_src::regs::BucketThresholdsWriteVal,
    >;
    pub type MarkovHiThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::MarkovHiThresholdsReadVal,
        crate::entropy_src::regs::MarkovHiThresholdsWriteVal,
    >;
    pub type MarkovLoThresholds = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::MarkovLoThresholdsReadVal,
        crate::entropy_src::regs::MarkovLoThresholdsWriteVal,
    >;
    pub type ExthtHiThresholds = ureg::ReadWriteReg32<
        0xffffffff,
        crate::entropy_src::regs::ExthtHiThresholdsReadVal,
        crate::entropy_src::regs::ExthtHiThresholdsWriteVal,
    >;
    pub type ExthtLoThresholds = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::ExthtLoThresholdsReadVal,
        crate::entropy_src::regs::ExthtLoThresholdsWriteVal,
    >;
    pub type RepcntHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::RepcntHiWatermarksReadVal>;
    pub type RepcntsHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::RepcntsHiWatermarksReadVal>;
    pub type AdaptpHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::AdaptpHiWatermarksReadVal>;
    pub type AdaptpLoWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::AdaptpLoWatermarksReadVal>;
    pub type ExthtHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::ExthtHiWatermarksReadVal>;
    pub type ExthtLoWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::ExthtLoWatermarksReadVal>;
    pub type BucketHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::BucketHiWatermarksReadVal>;
    pub type MarkovHiWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::MarkovHiWatermarksReadVal>;
    pub type MarkovLoWatermarks =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::MarkovLoWatermarksReadVal>;
    pub type RepcntTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type RepcntsTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type AdaptpHiTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type AdaptpLoTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type BucketTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type MarkovHiTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type MarkovLoTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type ExthtHiTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type ExthtLoTotalFails = ureg::ReadOnlyReg32<u32>;
    pub type AlertThreshold = ureg::ReadWriteReg32<
        0xfffd0002,
        crate::entropy_src::regs::AlertThresholdReadVal,
        crate::entropy_src::regs::AlertThresholdWriteVal,
    >;
    pub type AlertSummaryFailCounts =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::AlertSummaryFailCountsReadVal>;
    pub type AlertFailCounts =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::AlertFailCountsReadVal>;
    pub type ExthtFailCounts =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::ExthtFailCountsReadVal>;
    pub type FwOvControl = ureg::ReadWriteReg32<
        0x99,
        crate::entropy_src::regs::FwOvControlReadVal,
        crate::entropy_src::regs::FwOvControlWriteVal,
    >;
    pub type FwOvSha3Start = ureg::ReadWriteReg32<
        9,
        crate::entropy_src::regs::FwOvSha3StartReadVal,
        crate::entropy_src::regs::FwOvSha3StartWriteVal,
    >;
    pub type FwOvWrFifoFull = ureg::ReadOnlyReg32<crate::entropy_src::regs::FwOvWrFifoFullReadVal>;
    pub type FwOvRdFifoOverflow = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::FwOvRdFifoOverflowReadVal,
        crate::entropy_src::regs::FwOvRdFifoOverflowWriteVal,
    >;
    pub type FwOvRdData = ureg::ReadOnlyReg32<u32>;
    pub type FwOvWrData = ureg::WriteOnlyReg32<0, u32>;
    pub type ObserveFifoThresh = ureg::ReadWriteReg32<
        0x20,
        crate::entropy_src::regs::ObserveFifoThreshReadVal,
        crate::entropy_src::regs::ObserveFifoThreshWriteVal,
    >;
    pub type ObserveFifoDepth =
        ureg::ReadOnlyReg32<crate::entropy_src::regs::ObserveFifoDepthReadVal>;
    pub type DebugStatus = ureg::ReadOnlyReg32<crate::entropy_src::regs::DebugStatusReadVal>;
    pub type RecovAlertSts = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::RecovAlertStsReadVal,
        crate::entropy_src::regs::RecovAlertStsWriteVal,
    >;
    pub type ErrCode = ureg::ReadOnlyReg32<crate::entropy_src::regs::ErrCodeReadVal>;
    pub type ErrCodeTest = ureg::ReadWriteReg32<
        0,
        crate::entropy_src::regs::ErrCodeTestReadVal,
        crate::entropy_src::regs::ErrCodeTestWriteVal,
    >;
    pub type MainSmState = ureg::ReadOnlyReg32<crate::entropy_src::regs::MainSmStateReadVal>;
}

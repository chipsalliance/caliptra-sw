// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at c1c08303a2420f3005019b49f0a02a6caa554a69
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio> = ureg::RealMmio> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl RegisterBlock<ureg::RealMmio> {
    pub fn soc_ifc_reg() -> Self {
        unsafe { Self::new(0x30030000 as *mut u32) }
    }
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Indicates fatal hardware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal hardware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal firmware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal firmware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for hardware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_enc(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_enc(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Firmware Extended Error information for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_extended_error_info(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::CptraFwExtendedErrorInfo, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the boot status.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_boot_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of the firmware flows.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraFlowStatusReadVal`]; Write value: [`soc_ifc::regs::CptraFlowStatusWriteVal`]
    pub fn cptra_flow_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFlowStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates to ROM the originating cause for the PC to be reset to 0.
    /// Only reset during cold-boot (sticky).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraResetReasonReadVal`]; Write value: [`soc_ifc::regs::CptraResetReasonWriteVal`]
    pub fn cptra_reset_reason(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraResetReason, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates current hardware security state.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraSecurityStateReadVal`]; Write value: [`soc_ifc::regs::CptraSecurityStateWriteVal`]
    pub fn cptra_security_state(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraSecurityState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked by PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_valid_pauser(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraValidPauser, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// Each bit corresponds to locking the associated  VALID_PAUSER register.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::PauserLockReadVal`]; Write value: [`soc_ifc::regs::PauserLockWriteVal`]
    pub fn cptra_pauser_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraPauserLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for TRNG on SoC APB Interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked by TRNG_PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_trng_valid_pauser(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngValidPauser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// Each bit corresponds to locking the associated VALID_PAUSER register.
    /// Caliptra FW RW access for survivability but cannot unlock once locked
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::PauserLockReadVal`]; Write value: [`soc_ifc::regs::PauserLockWriteVal`]
    pub fn cptra_trng_pauser_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngPauserLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x74 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Storage for the requested TRNG Data.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_trng_data(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::CptraTrngData, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x78 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TRNG Status register to indicate request and done
    ///
    /// Read value: [`soc_ifc::regs::CptraTrngStatusReadVal`]; Write value: [`soc_ifc::regs::CptraTrngStatusWriteVal`]
    pub fn cptra_trng_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Writes to fuse registers are completed. After the done bit is set, any subsequent writes to a fuse register will be dropped unless there is a power cycle or a warm reset or caliptra FW allows a write (negotiated through a mailbox command).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW1-S
    ///
    /// Read value: [`soc_ifc::regs::CptraFuseWrDoneReadVal`]; Write value: [`soc_ifc::regs::CptraFuseWrDoneWriteVal`]
    pub fn cptra_fuse_wr_done(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFuseWrDone, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xac / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides the clock period of the system clock.
    /// Used to standardize the RISC-V Standard MTIME count register.
    /// Clock Period is indicated as an integer number of picoseconds.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_timer_config(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTimerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates that the BootFSM can continue to execute to bring the uController out of reset
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`soc_ifc::regs::CptraBootfsmGoReadVal`]; Write value: [`soc_ifc::regs::CptraBootfsmGoWriteVal`]
    pub fn cptra_bootfsm_go(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootfsmGo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// JTAG in debug/manuf mode or SOC can write to this register for ROM/FW defined skips or services; ROM/FW maintains the defintion of these bits.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_dbg_manuf_service_reg(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraDbgManufServiceReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to enable or disable all of the caliptra clk gating. Default is 0 (disabled).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`soc_ifc::regs::CptraClkGatingEnReadVal`]; Write value: [`soc_ifc::regs::CptraClkGatingEnWriteVal`]
    pub fn cptra_clk_gating_en(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraClkGatingEn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xbc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic input wires connected to SoC interface.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_generic_input_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericInputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xc0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic output wires connected to SoC interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_generic_output_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericOutputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xc8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra HW revision ID that matches the official final release milestone
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_rev_id(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra FW revision ID
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_rev_id(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraFwRevId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xd4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra HW Configuration
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraHwConfigReadVal`]; Write value: [`soc_ifc::regs::CptraHwConfigWriteVal`]
    pub fn cptra_hw_config(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xdc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Obfuscated UDS.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_uds_seed(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseUdsSeed, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Obfuscated Field Entropy.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_field_entropy(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::FuseFieldEntropy, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x230 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Key Manifest PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_key_manifest_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHash, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x250 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Key Manifest Mask Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal`]; Write value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal`]
    pub fn fuse_key_manifest_pk_hash_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHashMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x280 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Owner PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_owner_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseOwnerPkHash, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x284 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// FMC Security Version Number.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_fmc_key_manifest_svn(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseFmcKeyManifestSvn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2b4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime SVN Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_runtime_svn(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseRuntimeSvn, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x2b8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Anti Rollback Disable Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseAntiRollbackDisableReadVal`]; Write value: [`soc_ifc::regs::FuseAntiRollbackDisableWriteVal`]
    pub fn fuse_anti_rollback_disable(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseAntiRollbackDisable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Manufacturer IEEE IDevID Certificate Gen Attributes.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_idevid_cert_attr(
        &self,
    ) -> ureg::Array<24, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidCertAttr, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x2cc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Manufacturer IDEVID Manufacturer’s HSM identifier (this is used to find the certificate chain from the boot media)
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_idevid_manuf_hsm_id(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidManufHsmId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x32c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra Boot Media Integrated mode usage only. SOCs that build with a Boot Media Independent profile don’t have to account for these fuses.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseLifeCycleReadVal`]; Write value: [`soc_ifc::regs::FuseLifeCycleWriteVal`]
    pub fn fuse_life_cycle(&self) -> ureg::RegRef<crate::soc_ifc::meta::FuseLifeCycle, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x33c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Stored De-Obfuscation key, not accessible by software.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      -
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn internal_obf_key(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::InternalObfKey, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x600 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Lock feature gates writes to the ICCM. When lock is set to
    /// 1, writes are blocked. When cleared to 0, writes allowed.
    /// Write-once, meaning only a reset can clear it once set to 1.
    /// [br]Caliptra Access: RW1
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalIccmLockReadVal`]; Write value: [`soc_ifc::regs::InternalIccmLockWriteVal`]
    pub fn internal_iccm_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalIccmLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x620 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to assert FW update reset. When cleared to
    /// 0, no reset is triggered. When set to 1, uc-only reset is asserted.
    /// Field automatically clears 1 cycle after being set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWriteVal`]
    pub fn internal_fw_update_reset(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateReset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x624 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to set the number of cycles for which FW update reset must be asserted. Default is 5. Max value is 255 (8 bit).
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal`]
    pub fn internal_fw_update_reset_wait_cycles(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateResetWaitCycles, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x628 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
    /// Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
    /// Bit [0] is ignored to enforce half-word alignment of address.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn internal_nmi_vector(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalNmiVector, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x62c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoReadVal(u32);
    impl CptraBootfsmGoReadVal {
        ///
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraBootfsmGoWriteVal {
            CptraBootfsmGoWriteVal(self.0)
        }
    }
    impl From<u32> for CptraBootfsmGoReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoReadVal> for u32 {
        fn from(val: CptraBootfsmGoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoWriteVal(u32);
    impl CptraBootfsmGoWriteVal {
        ///
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraBootfsmGoWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoWriteVal> for u32 {
        fn from(val: CptraBootfsmGoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnReadVal(u32);
    impl CptraClkGatingEnReadVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraClkGatingEnWriteVal {
            CptraClkGatingEnWriteVal(self.0)
        }
    }
    impl From<u32> for CptraClkGatingEnReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnReadVal> for u32 {
        fn from(val: CptraClkGatingEnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnWriteVal(u32);
    impl CptraClkGatingEnWriteVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraClkGatingEnWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnWriteVal> for u32 {
        fn from(val: CptraClkGatingEnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusReadVal(u32);
    impl CptraFlowStatusReadVal {
        ///
        #[inline(always)]
        pub fn status(&self) -> u32 {
            (self.0 >> 0) & 0xfffffff
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Indicates Caliptra is ready for Runtime Firmware Download
        #[inline(always)]
        pub fn ready_for_runtime(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Indicates Caliptra is ready for Fuses to be programmed.
        /// Read-only to both Caliptra and SOC.
        #[inline(always)]
        pub fn ready_for_fuses(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraFlowStatusWriteVal {
            CptraFlowStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFlowStatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusReadVal> for u32 {
        fn from(val: CptraFlowStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusWriteVal(u32);
    impl CptraFlowStatusWriteVal {
        ///
        #[inline(always)]
        pub fn status(self, val: u32) -> Self {
            Self((self.0 & !(0xfffffff << 0)) | ((val & 0xfffffff) << 0))
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Indicates Caliptra is ready for Runtime Firmware Download
        #[inline(always)]
        pub fn ready_for_runtime(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for CptraFlowStatusWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusWriteVal> for u32 {
        fn from(val: CptraFlowStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneReadVal(u32);
    impl CptraFuseWrDoneReadVal {
        ///
        #[inline(always)]
        pub fn done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraFuseWrDoneWriteVal {
            CptraFuseWrDoneWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFuseWrDoneReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneReadVal> for u32 {
        fn from(val: CptraFuseWrDoneReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneWriteVal(u32);
    impl CptraFuseWrDoneWriteVal {
        ///
        #[inline(always)]
        pub fn done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraFuseWrDoneWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneWriteVal> for u32 {
        fn from(val: CptraFuseWrDoneWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwConfigReadVal(u32);
    impl CptraHwConfigReadVal {
        ///
        #[inline(always)]
        pub fn i_trng_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn qspi_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn i3_c_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
    }
    impl From<u32> for CptraHwConfigReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwConfigReadVal> for u32 {
        fn from(val: CptraHwConfigReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraResetReasonReadVal(u32);
    impl CptraResetReasonReadVal {
        /// FW update reset has been executed
        #[inline(always)]
        pub fn fw_upd_reset(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for CptraResetReasonReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraResetReasonReadVal> for u32 {
        fn from(val: CptraResetReasonReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraSecurityStateReadVal(u32);
    impl CptraSecurityStateReadVal {
        /// Device Lifecycle
        #[inline(always)]
        pub fn device_lifecycle(&self) -> super::enums::DeviceLifecycleE {
            super::enums::DeviceLifecycleE::try_from((self.0 >> 0) & 3).unwrap()
        }
        /// Debug Locked
        #[inline(always)]
        pub fn debug_locked(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// scan mode signal observed at caliptra interface - only for debug mode as its used to flush assets -
        /// when truly in scan mode, everything will be BROKEN for functional reads!
        #[inline(always)]
        pub fn scan_mode(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 4) & 0xfffffff
        }
    }
    impl From<u32> for CptraSecurityStateReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraSecurityStateReadVal> for u32 {
        fn from(val: CptraSecurityStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngStatusReadVal(u32);
    impl CptraTrngStatusReadVal {
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn data_req(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RO
        /// [br]SOC Access:      RW
        #[inline(always)]
        pub fn data_wr_done(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraTrngStatusWriteVal {
            CptraTrngStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraTrngStatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngStatusReadVal> for u32 {
        fn from(val: CptraTrngStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngStatusWriteVal(u32);
    impl CptraTrngStatusWriteVal {
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn data_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RO
        /// [br]SOC Access:      RW
        #[inline(always)]
        pub fn data_wr_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CptraTrngStatusWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngStatusWriteVal> for u32 {
        fn from(val: CptraTrngStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PauserLockReadVal(u32);
    impl PauserLockReadVal {
        ///
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> PauserLockWriteVal {
            PauserLockWriteVal(self.0)
        }
    }
    impl From<u32> for PauserLockReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PauserLockReadVal> for u32 {
        fn from(val: PauserLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PauserLockWriteVal(u32);
    impl PauserLockWriteVal {
        ///
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PauserLockWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PauserLockWriteVal> for u32 {
        fn from(val: PauserLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableReadVal(u32);
    impl FuseAntiRollbackDisableReadVal {
        ///
        #[inline(always)]
        pub fn dis(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseAntiRollbackDisableWriteVal {
            FuseAntiRollbackDisableWriteVal(self.0)
        }
    }
    impl From<u32> for FuseAntiRollbackDisableReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableReadVal> for u32 {
        fn from(val: FuseAntiRollbackDisableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableWriteVal(u32);
    impl FuseAntiRollbackDisableWriteVal {
        ///
        #[inline(always)]
        pub fn dis(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for FuseAntiRollbackDisableWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableWriteVal> for u32 {
        fn from(val: FuseAntiRollbackDisableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskReadVal(u32);
    impl FuseKeyManifestPkHashMaskReadVal {
        ///
        #[inline(always)]
        pub fn mask(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseKeyManifestPkHashMaskWriteVal {
            FuseKeyManifestPkHashMaskWriteVal(self.0)
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskReadVal> for u32 {
        fn from(val: FuseKeyManifestPkHashMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskWriteVal(u32);
    impl FuseKeyManifestPkHashMaskWriteVal {
        ///
        #[inline(always)]
        pub fn mask(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskWriteVal> for u32 {
        fn from(val: FuseKeyManifestPkHashMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleReadVal(u32);
    impl FuseLifeCycleReadVal {
        ///
        #[inline(always)]
        pub fn life_cycle(&self) -> u32 {
            (self.0 >> 0) & 3
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseLifeCycleWriteVal {
            FuseLifeCycleWriteVal(self.0)
        }
    }
    impl From<u32> for FuseLifeCycleReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleReadVal> for u32 {
        fn from(val: FuseLifeCycleReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleWriteVal(u32);
    impl FuseLifeCycleWriteVal {
        ///
        #[inline(always)]
        pub fn life_cycle(self, val: u32) -> Self {
            Self((self.0 & !(3 << 0)) | ((val & 3) << 0))
        }
    }
    impl From<u32> for FuseLifeCycleWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleWriteVal> for u32 {
        fn from(val: FuseLifeCycleWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetReadVal(u32);
    impl InternalFwUpdateResetReadVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalFwUpdateResetWriteVal {
            InternalFwUpdateResetWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetReadVal> for u32 {
        fn from(val: InternalFwUpdateResetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWriteVal(u32);
    impl InternalFwUpdateResetWriteVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWriteVal> for u32 {
        fn from(val: InternalFwUpdateResetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesReadVal(u32);
    impl InternalFwUpdateResetWaitCyclesReadVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalFwUpdateResetWaitCyclesWriteVal {
            InternalFwUpdateResetWaitCyclesWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesReadVal> for u32 {
        fn from(val: InternalFwUpdateResetWaitCyclesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesWriteVal(u32);
    impl InternalFwUpdateResetWaitCyclesWriteVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesWriteVal> for u32 {
        fn from(val: InternalFwUpdateResetWaitCyclesWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockReadVal(u32);
    impl InternalIccmLockReadVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalIccmLockWriteVal {
            InternalIccmLockWriteVal(self.0)
        }
    }
    impl From<u32> for InternalIccmLockReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockReadVal> for u32 {
        fn from(val: InternalIccmLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockWriteVal(u32);
    impl InternalIccmLockWriteVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalIccmLockWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockWriteVal> for u32 {
        fn from(val: InternalIccmLockWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum DeviceLifecycleE {
        DeviceUnprovisioned = 0,
        DeviceManufacturing = 1,
        Reserved2 = 2,
        DeviceProduction = 3,
    }
    impl DeviceLifecycleE {
        #[inline(always)]
        pub fn device_unprovisioned(&self) -> bool {
            *self == Self::DeviceUnprovisioned
        }
        #[inline(always)]
        pub fn device_manufacturing(&self) -> bool {
            *self == Self::DeviceManufacturing
        }
        #[inline(always)]
        pub fn device_production(&self) -> bool {
            *self == Self::DeviceProduction
        }
    }
    impl TryFrom<u32> for DeviceLifecycleE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<DeviceLifecycleE, ()> {
            match val {
                0 => Ok(Self::DeviceUnprovisioned),
                1 => Ok(Self::DeviceManufacturing),
                2 => Ok(Self::Reserved2),
                3 => Ok(Self::DeviceProduction),
                _ => Err(()),
            }
        }
    }
    impl From<DeviceLifecycleE> for u32 {
        fn from(val: DeviceLifecycleE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct DeviceLifecycleESelector();
        impl DeviceLifecycleESelector {
            #[inline(always)]
            pub fn device_unprovisioned(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceUnprovisioned
            }
            #[inline(always)]
            pub fn device_manufacturing(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceManufacturing
            }
            #[inline(always)]
            pub fn device_production(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceProduction
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type CptraHwErrorFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwErrorNonFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwErrorFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwErrorNonFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwExtendedErrorInfo = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraBootStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFlowStatus = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraFlowStatusReadVal,
        crate::soc_ifc::regs::CptraFlowStatusWriteVal,
    >;
    pub type CptraResetReason = ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraResetReasonReadVal>;
    pub type CptraSecurityState =
        ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraSecurityStateReadVal>;
    pub type CptraValidPauser = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraPauserLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::PauserLockReadVal,
        crate::soc_ifc::regs::PauserLockWriteVal,
    >;
    pub type CptraTrngValidPauser = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraTrngPauserLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::PauserLockReadVal,
        crate::soc_ifc::regs::PauserLockWriteVal,
    >;
    pub type CptraTrngData = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraTrngStatus = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraTrngStatusReadVal,
        crate::soc_ifc::regs::CptraTrngStatusWriteVal,
    >;
    pub type CptraFuseWrDone = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraFuseWrDoneReadVal,
        crate::soc_ifc::regs::CptraFuseWrDoneWriteVal,
    >;
    pub type CptraTimerConfig = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraBootfsmGo = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraBootfsmGoReadVal,
        crate::soc_ifc::regs::CptraBootfsmGoWriteVal,
    >;
    pub type CptraDbgManufServiceReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraClkGatingEn = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraClkGatingEnReadVal,
        crate::soc_ifc::regs::CptraClkGatingEnWriteVal,
    >;
    pub type CptraGenericInputWires = ureg::ReadOnlyReg32<u32>;
    pub type CptraGenericOutputWires = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwRevId = ureg::ReadOnlyReg32<u32>;
    pub type CptraFwRevId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwConfig = ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraHwConfigReadVal>;
    pub type FuseUdsSeed = ureg::WriteOnlyReg32<0, u32>;
    pub type FuseFieldEntropy = ureg::WriteOnlyReg32<0, u32>;
    pub type FuseKeyManifestPkHash = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseKeyManifestPkHashMask = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal,
        crate::soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal,
    >;
    pub type FuseOwnerPkHash = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseFmcKeyManifestSvn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseRuntimeSvn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseAntiRollbackDisable = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseAntiRollbackDisableReadVal,
        crate::soc_ifc::regs::FuseAntiRollbackDisableWriteVal,
    >;
    pub type FuseIdevidCertAttr = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseIdevidManufHsmId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseLifeCycle = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseLifeCycleReadVal,
        crate::soc_ifc::regs::FuseLifeCycleWriteVal,
    >;
    pub type InternalObfKey = ureg::WriteOnlyReg32<0, u32>;
    pub type InternalIccmLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalIccmLockReadVal,
        crate::soc_ifc::regs::InternalIccmLockWriteVal,
    >;
    pub type InternalFwUpdateReset = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalFwUpdateResetReadVal,
        crate::soc_ifc::regs::InternalFwUpdateResetWriteVal,
    >;
    pub type InternalFwUpdateResetWaitCycles = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal,
        crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal,
    >;
    pub type InternalNmiVector = ureg::ReadWriteReg32<0, u32, u32>;
}

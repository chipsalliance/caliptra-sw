// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 532117f67c755af24bf5dfbebbe5a2bef4f20e00
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct SocIfcReg {
    _priv: (),
}
impl SocIfcReg {
    pub const PTR: *mut u32 = 0x30030000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Indicates fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// cptra_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only a Caliptra reset will clear the fatal error interrupt.
    /// [br]Caliptra Access: RW1C
    /// [br]SOC Access:      RW1C
    ///
    /// Read value: [`soc_ifc::regs::CptraHwErrorFatalReadVal`]; Write value: [`soc_ifc::regs::CptraHwErrorFatalWriteVal`]
    #[inline(always)]
    pub fn cptra_hw_error_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// cptra_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the cptra_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] CPTRA_HW_ERROR_NON_FATAL
    /// [br] [*] CPTRA_FW_ERROR_NON_FATAL
    /// [br] [*] internal_hw_error_non_fatal_mask
    /// [br] [*] internal_fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW1C
    /// [br]SOC Access:      RW1C
    ///
    /// Read value: [`soc_ifc::regs::CptraHwErrorNonFatalReadVal`]; Write value: [`soc_ifc::regs::CptraHwErrorNonFatalWriteVal`]
    #[inline(always)]
    pub fn cptra_hw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// cptra_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only a Caliptra reset will clear the fatal error interrupt.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fw_error_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// cptra_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the cptra_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] CPTRA_HW_ERROR_NON_FATAL
    /// [br] [*] CPTRA_FW_ERROR_NON_FATAL
    /// [br] [*] internal_hw_error_non_fatal_mask
    /// [br] [*] internal_fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for hardware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_hw_error_enc(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Encoded error value for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fw_error_enc(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorEnc, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Firmware Extended Error information for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fw_extended_error_info(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::CptraFwExtendedErrorInfo, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the boot status.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_boot_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of the firmware flows.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraFlowStatusReadVal`]; Write value: [`soc_ifc::regs::CptraFlowStatusWriteVal`]
    #[inline(always)]
    pub fn cptra_flow_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFlowStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates to ROM the originating cause for the PC to be reset to 0.
    /// Only reset during cold-boot (sticky).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraResetReasonReadVal`]; Write value: [`soc_ifc::regs::CptraResetReasonWriteVal`]
    #[inline(always)]
    pub fn cptra_reset_reason(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraResetReason, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates current hardware security state.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraSecurityStateReadVal`]; Write value: [`soc_ifc::regs::CptraSecurityStateWriteVal`]
    #[inline(always)]
    pub fn cptra_security_state(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraSecurityState, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface. Only valid once LOCK is set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked by PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_mbox_valid_pauser(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraMboxValidPauser, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// [br]Each bit corresponds to locking the associated MBOX_VALID_PAUSER register.
    /// [br]Associated MBOX_VALID_PAUSER register is only valid once locked by this bit.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::CptraXxxxPauserLockReadVal`]; Write value: [`soc_ifc::regs::CptraXxxxPauserLockWriteVal`]
    #[inline(always)]
    pub fn cptra_mbox_pauser_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraMboxPauserLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for TRNG on SoC APB Interface. Only valid once LOCK is set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]Read-Only once locked by TRNG_PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_trng_valid_pauser(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngValidPauser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// [br]Each bit corresponds to locking the associated TRNG_VALID_PAUSER register.
    /// [br]Associated TRNG_VALID_PAUSER register is only valid once locked by this bit.
    /// [br]Caliptra FW RW access for survivability but cannot unlock once locked
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::CptraXxxxPauserLockReadVal`]; Write value: [`soc_ifc::regs::CptraXxxxPauserLockWriteVal`]
    #[inline(always)]
    pub fn cptra_trng_pauser_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngPauserLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x74 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// TRNG Control register to clear data registers
    ///
    /// Read value: [`soc_ifc::regs::CptraTrngCtrlReadVal`]; Write value: [`soc_ifc::regs::CptraTrngCtrlWriteVal`]
    #[inline(always)]
    pub fn cptra_trng_ctrl(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Writes to fuse registers are completed. After the done bit is set, any subsequent writes to a fuse register will be dropped unless there is a power cycle or a warm reset or caliptra FW allows a write (negotiated through a mailbox command).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW1-S
    ///
    /// Read value: [`soc_ifc::regs::CptraFuseWrDoneReadVal`]; Write value: [`soc_ifc::regs::CptraFuseWrDoneWriteVal`]
    #[inline(always)]
    pub fn cptra_fuse_wr_done(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFuseWrDone, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides the clock period of the system clock.
    /// Used to standardize the RISC-V Standard MTIME count register.
    /// Clock Period is indicated as an integer number of picoseconds.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_timer_config(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTimerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates that the BootFSM can continue to execute to bring the uController out of reset
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`soc_ifc::regs::CptraBootfsmGoReadVal`]; Write value: [`soc_ifc::regs::CptraBootfsmGoWriteVal`]
    #[inline(always)]
    pub fn cptra_bootfsm_go(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootfsmGo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xb8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// JTAG in debug/manuf mode or SOC can write to this register for ROM/FW defined skips or services; ROM/FW maintains the defintion of these bits.
    /// [br]
    /// [br]Field decode:
    /// [br] [lb]0[rb]     MFG_FLAG_GEN_IDEV_CSR: Enable bit for Caliptra to generate an IDEV CSR
    /// [br] [lb]1[rb]     MFG_FLAG_RNG_UNAVAIL: Random Number Generator Unavailable
    /// [br] [lb]15:2[rb]  MFG_FLAG_RSVD
    /// [br] [lb]30:16[rb] FAKE_ROM_RSVD
    /// [br] [lb]31[rb]    FAKE_ROM_IMAGE_VERIFY_EN: Enable bit to perform image verification within the fake-rom feature
    /// [br]
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_dbg_manuf_service_reg(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraDbgManufServiceReg, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xbc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to enable or disable all of the caliptra clk gating. Default is 0 (disabled).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`soc_ifc::regs::CptraClkGatingEnReadVal`]; Write value: [`soc_ifc::regs::CptraClkGatingEnWriteVal`]
    #[inline(always)]
    pub fn cptra_clk_gating_en(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraClkGatingEn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic input wires connected to SoC interface.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_generic_input_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericInputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xc4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Generic output wires connected to SoC interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_generic_output_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericOutputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xcc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra HW revision ID that matches the official final release milestone
    /// SoC stepping ID is repopulated with the value in the fuse register on every warm reset
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraHwRevIdReadVal`]; Write value: [`soc_ifc::regs::CptraHwRevIdWriteVal`]
    #[inline(always)]
    pub fn cptra_hw_rev_id(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xd4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra FW revision ID
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fw_rev_id(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraFwRevId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xd8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra HW Configuration
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraHwConfigReadVal`]; Write value: [`soc_ifc::regs::CptraHwConfigWriteVal`]
    #[inline(always)]
    pub fn cptra_hw_config(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer1 enable register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraWdtTimer1EnReadVal`]; Write value: [`soc_ifc::regs::CptraWdtTimer1EnWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_timer1_en(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer1En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer1 control register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraWdtTimer1CtrlReadVal`]; Write value: [`soc_ifc::regs::CptraWdtTimer1CtrlWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_timer1_ctrl(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer1Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xe8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer1 timeout register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_wdt_timer1_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer1TimeoutPeriod, &TMmio>>
    {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xec / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer2 enable register. Note: Setting this to 1 will disable the default cascaded mode and will have both timers count independently.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraWdtTimer2EnReadVal`]; Write value: [`soc_ifc::regs::CptraWdtTimer2EnWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_timer2_en(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer2En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xf4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer2 control register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraWdtTimer2CtrlReadVal`]; Write value: [`soc_ifc::regs::CptraWdtTimer2CtrlWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_timer2_ctrl(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer2Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xf8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer2 timeout register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_wdt_timer2_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraWdtTimer2TimeoutPeriod, &TMmio>>
    {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xfc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra watchdog timer status register
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraWdtStatusReadVal`]; Write value: [`soc_ifc::regs::CptraWdtStatusWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraWdtStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for FUSE on SoC APB Interface. Only valid once LOCK is set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]Read-Only once locked by FUSE_PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_fuse_valid_pauser(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFuseValidPauser, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// [br]Each bit corresponds to locking the associated FUSE_VALID_PAUSER register.
    /// [br]Associated FUSE_VALID_PAUSER register is only valid once locked by this bit.
    /// [br]Caliptra FW RW access for survivability but cannot unlock once locked
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::CptraXxxxPauserLockReadVal`]; Write value: [`soc_ifc::regs::CptraXxxxPauserLockWriteVal`]
    #[inline(always)]
    pub fn cptra_fuse_pauser_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFusePauserLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SOC provided count in cycles for WDT1 timeout.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_wdt_cfg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraWdtCfg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Adaptive threshold values for entropy source health tests.
    ///
    /// Read value: [`soc_ifc::regs::CptraItrngEntropyConfig0ReadVal`]; Write value: [`soc_ifc::regs::CptraItrngEntropyConfig0WriteVal`]
    #[inline(always)]
    pub fn cptra_i_trng_entropy_config_0(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraItrngEntropyConfig0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x118 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Repetition count value for entropy source health tests.
    ///
    /// Read value: [`soc_ifc::regs::CptraItrngEntropyConfig1ReadVal`]; Write value: [`soc_ifc::regs::CptraItrngEntropyConfig1WriteVal`]
    #[inline(always)]
    pub fn cptra_i_trng_entropy_config_1(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraItrngEntropyConfig1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x11c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn cptra_rsvd_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraRsvdReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x120 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Obfuscated UDS.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_uds_seed(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseUdsSeed, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Obfuscated Field Entropy.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_field_entropy(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::FuseFieldEntropy, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x230 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Key Manifest PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_key_manifest_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHash, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x250 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Key Manifest Mask Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal`]; Write value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal`]
    #[inline(always)]
    pub fn fuse_key_manifest_pk_hash_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHashMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x280 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Owner PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_owner_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseOwnerPkHash, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x284 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// FMC Security Version Number.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_fmc_key_manifest_svn(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseFmcKeyManifestSvn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2b4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Runtime SVN Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_runtime_svn(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseRuntimeSvn, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x2b8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Anti Rollback Disable Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseAntiRollbackDisableReadVal`]; Write value: [`soc_ifc::regs::FuseAntiRollbackDisableWriteVal`]
    #[inline(always)]
    pub fn fuse_anti_rollback_disable(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseAntiRollbackDisable, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Manufacturer IEEE IDevID Certificate Gen Attributes.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_idevid_cert_attr(
        &self,
    ) -> ureg::Array<24, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidCertAttr, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x2cc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Manufacturer IDEVID Manufacturer’s HSM identifier (this is used to find the certificate chain from the boot media)
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_idevid_manuf_hsm_id(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidManufHsmId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x32c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Caliptra Boot Media Integrated mode usage only. SOCs that build with a Boot Media Independent profile don’t have to account for these fuses.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseLifeCycleReadVal`]; Write value: [`soc_ifc::regs::FuseLifeCycleWriteVal`]
    #[inline(always)]
    pub fn fuse_life_cycle(&self) -> ureg::RegRef<crate::soc_ifc::meta::FuseLifeCycle, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x33c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 0 - Verify Caliptra firmware images with ECDSA-only; 1 - Verify Caliptra firmware images with both ECDSA and LMS
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseLmsVerifyReadVal`]; Write value: [`soc_ifc::regs::FuseLmsVerifyWriteVal`]
    #[inline(always)]
    pub fn fuse_lms_verify(&self) -> ureg::RegRef<crate::soc_ifc::meta::FuseLmsVerify, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x340 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bits for revoking LMS public keys in the key manifest
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fuse_lms_revocation(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseLmsRevocation, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x344 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SOC stepping ID
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseSocSteppingIdReadVal`]; Write value: [`soc_ifc::regs::FuseSocSteppingIdWriteVal`]
    #[inline(always)]
    pub fn fuse_soc_stepping_id(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseSocSteppingId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x348 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Stored De-Obfuscation key, not accessible by software.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      -
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_obf_key(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::InternalObfKey, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x600 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Lock feature gates writes to the ICCM. When lock is set to
    /// 1, writes are blocked. When cleared to 0, writes allowed.
    /// Write-once, meaning only a reset can clear it once set to 1.
    /// [br]Caliptra Access: RW1
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalIccmLockReadVal`]; Write value: [`soc_ifc::regs::InternalIccmLockWriteVal`]
    #[inline(always)]
    pub fn internal_iccm_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalIccmLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x620 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to assert FW update reset. When cleared to
    /// 0, no reset is triggered. When set to 1, uc-only reset is asserted.
    /// Field automatically clears 1 cycle after being set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWriteVal`]
    #[inline(always)]
    pub fn internal_fw_update_reset(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateReset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x624 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Control register to set the number of cycles for which FW update reset must be asserted. Default is 5. Max value is 255 (8 bit).
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal`]
    #[inline(always)]
    pub fn internal_fw_update_reset_wait_cycles(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateResetWaitCycles, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x628 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// 32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
    /// Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
    /// Bit [0] is ignored to enforce half-word alignment of address.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_nmi_vector(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalNmiVector, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x62c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register CPTRA_HW_ERROR_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// cptra_error_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in CPTRA_HW_ERROR_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set and was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Firmware can not cause the interrupt output to deassert by setting
    /// mask bits for fatal error conditions that have already triggered the
    /// interrupt.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalHwErrorFatalMaskReadVal`]; Write value: [`soc_ifc::regs::InternalHwErrorFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_hw_error_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalHwErrorFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x630 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register CPTRA_HW_ERROR_NON_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// cptra_error_non_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in CPTRA_HW_ERROR_NON_FATAL will not produce an interrupt
    /// output assertion. If a hardware error bit is set that was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error condition reoccurring while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Any change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the cptra_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] CPTRA_HW_ERROR_NON_FATAL
    /// [br] [*] CPTRA_FW_ERROR_NON_FATAL
    /// [br] [*] internal_hw_error_non_fatal_mask
    /// [br] [*] internal_fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalHwErrorNonFatalMaskReadVal`]; Write value: [`soc_ifc::regs::InternalHwErrorNonFatalMaskWriteVal`]
    #[inline(always)]
    pub fn internal_hw_error_non_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalHwErrorNonFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x634 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register CPTRA_FW_ERROR_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// cptra_error_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in CPTRA_FW_ERROR_FATAL will not produce an interrupt
    /// output assertion. If a firmware error bit is set and was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error bit being cleared then set again while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Firmware can not cause the interrupt output to deassert by setting
    /// mask bits for fatal error conditions that have already triggered the
    /// interrupt.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_fw_error_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwErrorFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x638 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Bit mask for the register CPTRA_FW_ERROR_NON_FATAL to determine
    /// which bits are disabled for interrupt generation on the
    /// cptra_error_non_fatal output signal.
    /// [br]A value of 1 in a field of this register means the corresponding bit
    /// position in CPTRA_FW_ERROR_NON_FATAL will not produce an interrupt
    /// output assertion. If a firmware error bit is set that was previously
    /// masked, and firmware performs a write to clear the corresponding mask
    /// bit in this register, the interrupt output will not be asserted. Only
    /// the same error bit being cleared then set again while it is unmasked will cause
    /// a new assertion of the interrupt output.
    /// [br]Any change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the cptra_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] CPTRA_HW_ERROR_NON_FATAL
    /// [br] [*] CPTRA_FW_ERROR_NON_FATAL
    /// [br] [*] internal_hw_error_non_fatal_mask
    /// [br] [*] internal_fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_fw_error_non_fatal_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwErrorNonFatalMask, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x63c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter, lower 32-bits.
    /// [br]Frequency of counter is indicated in CPTRA_TIMER_CONFIG.clk_period.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_rv_mtime_l(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalRvMtimeL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x640 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter, upper 32-bits.
    /// [br]Frequency of counter is indicated in CPTRA_TIMER_CONFIG.clk_period.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_rv_mtime_h(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalRvMtimeH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x644 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter Compare Value, lower 32-bits.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_rv_mtimecmp_l(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalRvMtimecmpL, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x648 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// RISC-V Standard Machine-mode Time Counter Compare Value, upper 32-bits.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn internal_rv_mtimecmp_h(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalRvMtimecmpH, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    #[inline(always)]
    pub fn intr_block_rf(&self) -> IntrBlockRfBlock<&TMmio> {
        IntrBlockRfBlock {
            ptr: unsafe { self.ptr.add(0x800 / core::mem::size_of::<u32>()) },
            mmio: core::borrow::Borrow::borrow(&self.mmio),
        }
    }
}
#[derive(Clone, Copy)]
pub struct IntrBlockRfBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio> IntrBlockRfBlock<TMmio> {
    /// Dedicated register with one bit for each event type that may produce an interrupt.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrEnTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrEnTWriteVal`]
    #[inline(always)]
    pub fn global_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfGlobalIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`soc_ifc::regs::ErrorIntrEnTReadVal`]; Write value: [`soc_ifc::regs::ErrorIntrEnTWriteVal`]
    #[inline(always)]
    pub fn error_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dedicated register with one bit for each event that may produce an interrupt.
    ///
    /// Read value: [`soc_ifc::regs::NotifIntrEnTReadVal`]; Write value: [`soc_ifc::regs::NotifIntrEnTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_en_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifIntrEnR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn error_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of any interrupt event
    /// of a given type. E.g. Notifications and Errors may drive
    /// to two separate interrupt registers. There may be
    /// multiple sources of Notifications or Errors that are
    /// aggregated into a single interrupt pin for that
    /// respective type. That pin feeds through this register
    /// in order to apply a global enablement of that interrupt
    /// event type.
    /// Nonsticky assertion.
    ///
    /// Read value: [`sha512_acc::regs::GlobalIntrTReadVal`]; Write value: [`sha512_acc::regs::GlobalIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_global_intr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifGlobalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`soc_ifc::regs::ErrorIntrTReadVal`]; Write value: [`soc_ifc::regs::ErrorIntrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit indicating occurrence of each interrupt event.
    /// Sticky, level assertion, write-1-to-clear.
    ///
    /// Read value: [`soc_ifc::regs::NotifIntrTReadVal`]; Write value: [`soc_ifc::regs::NotifIntrTWriteVal`]
    #[inline(always)]
    pub fn notif_internal_intr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifInternalIntrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`soc_ifc::regs::ErrorIntrTrigTReadVal`]; Write value: [`soc_ifc::regs::ErrorIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn error_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Single bit for each interrupt event allows SW to manually
    /// trigger occurrence of that event. Upon SW write, the trigger bit
    /// will pulse for 1 cycle then clear to 0. The pulse on the
    /// trigger register bit results in the corresponding interrupt
    /// status bit being set to 1.
    ///
    /// Read value: [`soc_ifc::regs::NotifIntrTrigTReadVal`]; Write value: [`soc_ifc::regs::NotifIntrTrigTWriteVal`]
    #[inline(always)]
    pub fn notif_intr_trig_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifIntrTrigR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_internal_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorInternalIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_inv_dev_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorInvDevIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_cmd_fail_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorCmdFailIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_bad_fuse_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorBadFuseIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_iccm_blocked_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorIccmBlockedIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_mbox_ecc_unc_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorMboxEccUncIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x114 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_wdt_timer1_timeout_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorWdtTimer1TimeoutIntrCountR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x118 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn error_wdt_timer2_timeout_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorWdtTimer2TimeoutIntrCountR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x11c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_cmd_avail_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifCmdAvailIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_mbox_ecc_cor_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifMboxEccCorIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x184 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_debug_locked_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifDebugLockedIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x188 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_scan_mode_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifScanModeIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_soc_req_lock_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifSocReqLockIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x190 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides statistics about the number of events that have
    /// occurred.
    /// Will not overflow ('incrsaturate').
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn notif_gen_in_toggle_intr_count_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifGenInToggleIntrCountR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x194 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_internal_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorInternalIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x200 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_inv_dev_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorInvDevIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x204 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_cmd_fail_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorCmdFailIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x208 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_bad_fuse_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorBadFuseIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_iccm_blocked_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorIccmBlockedIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x210 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_mbox_ecc_unc_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorMboxEccUncIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x214 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_wdt_timer1_timeout_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorWdtTimer1TimeoutIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x218 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn error_wdt_timer2_timeout_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfErrorWdtTimer2TimeoutIntrCountIncrR, &TMmio>
    {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x21c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_cmd_avail_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifCmdAvailIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x220 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_mbox_ecc_cor_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifMboxEccCorIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x224 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_debug_locked_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifDebugLockedIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x228 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_scan_mode_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifScanModeIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x22c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_soc_req_lock_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifSocReqLockIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x230 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Trigger the event counter to increment based on observing
    /// the rising edge of an interrupt event input from the
    /// Hardware. The same input signal that causes an interrupt
    /// event to be set (sticky) also causes this signal to pulse
    /// for 1 clock cycle, resulting in the event counter
    /// incrementing by 1 for every interrupt event.
    /// This is implemented as a down-counter (1-bit) that will
    /// decrement immediately on being set - resulting in a pulse
    ///
    /// Read value: [`sha512_acc::regs::IntrCountIncrTReadVal`]; Write value: [`sha512_acc::regs::IntrCountIncrTWriteVal`]
    #[inline(always)]
    pub fn notif_gen_in_toggle_intr_count_incr_r(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::IntrBlockRfNotifGenInToggleIntrCountIncrR, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x234 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoReadVal(u32);
    impl CptraBootfsmGoReadVal {
        ///
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraBootfsmGoWriteVal {
            CptraBootfsmGoWriteVal(self.0)
        }
    }
    impl From<u32> for CptraBootfsmGoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraBootfsmGoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoWriteVal(u32);
    impl CptraBootfsmGoWriteVal {
        ///
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraBootfsmGoWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraBootfsmGoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnReadVal(u32);
    impl CptraClkGatingEnReadVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraClkGatingEnWriteVal {
            CptraClkGatingEnWriteVal(self.0)
        }
    }
    impl From<u32> for CptraClkGatingEnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraClkGatingEnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnWriteVal(u32);
    impl CptraClkGatingEnWriteVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraClkGatingEnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraClkGatingEnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusReadVal(u32);
    impl CptraFlowStatusReadVal {
        ///
        #[inline(always)]
        pub fn status(&self) -> u32 {
            (self.0 >> 0) & 0xffffff
        }
        /// DEV ID CSR ready
        #[inline(always)]
        pub fn idevid_csr_ready(&self) -> bool {
            ((self.0 >> 24) & 1) != 0
        }
        /// Boot FSM State
        #[inline(always)]
        pub fn boot_fsm_ps(&self) -> u32 {
            (self.0 >> 25) & 7
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Indicates Caliptra is ready for RT flows
        #[inline(always)]
        pub fn ready_for_runtime(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Indicates Caliptra is ready for Fuses to be programmed.
        /// Read-only to both Caliptra and SOC.
        #[inline(always)]
        pub fn ready_for_fuses(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraFlowStatusWriteVal {
            CptraFlowStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFlowStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraFlowStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusWriteVal(u32);
    impl CptraFlowStatusWriteVal {
        ///
        #[inline(always)]
        pub fn status(self, val: u32) -> Self {
            Self((self.0 & !(0xffffff << 0)) | ((val & 0xffffff) << 0))
        }
        /// DEV ID CSR ready
        #[inline(always)]
        pub fn idevid_csr_ready(self, val: bool) -> Self {
            Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Indicates Caliptra is ready for RT flows
        #[inline(always)]
        pub fn ready_for_runtime(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for CptraFlowStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraFlowStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneReadVal(u32);
    impl CptraFuseWrDoneReadVal {
        ///
        #[inline(always)]
        pub fn done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraFuseWrDoneWriteVal {
            CptraFuseWrDoneWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFuseWrDoneReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraFuseWrDoneReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneWriteVal(u32);
    impl CptraFuseWrDoneWriteVal {
        ///
        #[inline(always)]
        pub fn done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraFuseWrDoneWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraFuseWrDoneWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwConfigReadVal(u32);
    impl CptraHwConfigReadVal {
        ///
        #[inline(always)]
        pub fn i_trng_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn qspi_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn i3_c_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn uart_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
    }
    impl From<u32> for CptraHwConfigReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwConfigReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwConfigReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorFatalReadVal(u32);
    impl CptraHwErrorFatalReadVal {
        ///
        #[inline(always)]
        pub fn iccm_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn dccm_ecc_unc(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn nmi_pin(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraHwErrorFatalWriteVal {
            CptraHwErrorFatalWriteVal(self.0)
        }
    }
    impl From<u32> for CptraHwErrorFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwErrorFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwErrorFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorFatalWriteVal(u32);
    impl CptraHwErrorFatalWriteVal {
        ///
        #[inline(always)]
        pub fn iccm_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn dccm_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn nmi_pin(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for CptraHwErrorFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwErrorFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwErrorFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorNonFatalReadVal(u32);
    impl CptraHwErrorNonFatalReadVal {
        ///
        #[inline(always)]
        pub fn mbox_prot_no_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mbox_prot_ooo(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mbox_ecc_unc(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraHwErrorNonFatalWriteVal {
            CptraHwErrorNonFatalWriteVal(self.0)
        }
    }
    impl From<u32> for CptraHwErrorNonFatalReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwErrorNonFatalReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwErrorNonFatalReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorNonFatalWriteVal(u32);
    impl CptraHwErrorNonFatalWriteVal {
        ///
        #[inline(always)]
        pub fn mbox_prot_no_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn mbox_prot_ooo(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn mbox_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for CptraHwErrorNonFatalWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwErrorNonFatalWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwErrorNonFatalWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwRevIdReadVal(u32);
    impl CptraHwRevIdReadVal {
        ///
        #[inline(always)]
        pub fn cptra_generation(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        ///
        #[inline(always)]
        pub fn soc_stepping_id(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for CptraHwRevIdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraHwRevIdReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraHwRevIdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraResetReasonReadVal(u32);
    impl CptraResetReasonReadVal {
        /// FW update reset has been executed
        #[inline(always)]
        pub fn fw_upd_reset(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for CptraResetReasonReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraResetReasonReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraResetReasonReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraSecurityStateReadVal(u32);
    impl CptraSecurityStateReadVal {
        /// Device Lifecycle
        #[inline(always)]
        pub fn device_lifecycle(&self) -> super::enums::DeviceLifecycleE {
            super::enums::DeviceLifecycleE::try_from((self.0 >> 0) & 3).unwrap()
        }
        /// Debug Locked
        #[inline(always)]
        pub fn debug_locked(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// scan mode signal observed at caliptra interface - only for debug mode as its used to flush assets -
        /// when truly in scan mode, everything will be BROKEN for functional reads!
        #[inline(always)]
        pub fn scan_mode(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 4) & 0xfffffff
        }
    }
    impl From<u32> for CptraSecurityStateReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraSecurityStateReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraSecurityStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngCtrlReadVal(u32);
    impl CptraTrngCtrlReadVal {
        /// Indicates that TRNG Data can be cleared
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn clear(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraTrngCtrlWriteVal {
            CptraTrngCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CptraTrngCtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngCtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraTrngCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngCtrlWriteVal(u32);
    impl CptraTrngCtrlWriteVal {
        /// Indicates that TRNG Data can be cleared
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn clear(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraTrngCtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngCtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraTrngCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtStatusReadVal(u32);
    impl CptraWdtStatusReadVal {
        /// Timer1 timed out, timer2 enabled
        #[inline(always)]
        pub fn t1_timeout(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Timer2 timed out
        #[inline(always)]
        pub fn t2_timeout(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtStatusWriteVal {
            CptraWdtStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtStatusWriteVal(u32);
    impl CptraWdtStatusWriteVal {
        /// Timer1 timed out, timer2 enabled
        #[inline(always)]
        pub fn t1_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Timer2 timed out
        #[inline(always)]
        pub fn t2_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CptraWdtStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer1CtrlReadVal(u32);
    impl CptraWdtTimer1CtrlReadVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtTimer1CtrlWriteVal {
            CptraWdtTimer1CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtTimer1CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer1CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer1CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer1CtrlWriteVal(u32);
    impl CptraWdtTimer1CtrlWriteVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraWdtTimer1CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer1CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer1CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer1EnReadVal(u32);
    impl CptraWdtTimer1EnReadVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtTimer1EnWriteVal {
            CptraWdtTimer1EnWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtTimer1EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer1EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer1EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer1EnWriteVal(u32);
    impl CptraWdtTimer1EnWriteVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraWdtTimer1EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer1EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer1EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer2CtrlReadVal(u32);
    impl CptraWdtTimer2CtrlReadVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtTimer2CtrlWriteVal {
            CptraWdtTimer2CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtTimer2CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer2CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer2CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer2CtrlWriteVal(u32);
    impl CptraWdtTimer2CtrlWriteVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraWdtTimer2CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer2CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer2CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer2EnReadVal(u32);
    impl CptraWdtTimer2EnReadVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtTimer2EnWriteVal {
            CptraWdtTimer2EnWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtTimer2EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer2EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer2EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraWdtTimer2EnWriteVal(u32);
    impl CptraWdtTimer2EnWriteVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraWdtTimer2EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtTimer2EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtTimer2EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraXxxxPauserLockReadVal(u32);
    impl CptraXxxxPauserLockReadVal {
        ///
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraXxxxPauserLockWriteVal {
            CptraXxxxPauserLockWriteVal(self.0)
        }
    }
    impl From<u32> for CptraXxxxPauserLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraXxxxPauserLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraXxxxPauserLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraXxxxPauserLockWriteVal(u32);
    impl CptraXxxxPauserLockWriteVal {
        ///
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraXxxxPauserLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraXxxxPauserLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraXxxxPauserLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraItrngEntropyConfig0ReadVal(u32);
    impl CptraItrngEntropyConfig0ReadVal {
        ///
        #[inline(always)]
        pub fn low_threshold(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        ///
        #[inline(always)]
        pub fn high_threshold(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraItrngEntropyConfig0WriteVal {
            CptraItrngEntropyConfig0WriteVal(self.0)
        }
    }
    impl From<u32> for CptraItrngEntropyConfig0ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraItrngEntropyConfig0ReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraItrngEntropyConfig0ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraItrngEntropyConfig0WriteVal(u32);
    impl CptraItrngEntropyConfig0WriteVal {
        ///
        #[inline(always)]
        pub fn low_threshold(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        ///
        #[inline(always)]
        pub fn high_threshold(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for CptraItrngEntropyConfig0WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraItrngEntropyConfig0WriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraItrngEntropyConfig0WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraItrngEntropyConfig1ReadVal(u32);
    impl CptraItrngEntropyConfig1ReadVal {
        ///
        #[inline(always)]
        pub fn repetition_count(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        ///
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraItrngEntropyConfig1WriteVal {
            CptraItrngEntropyConfig1WriteVal(self.0)
        }
    }
    impl From<u32> for CptraItrngEntropyConfig1ReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraItrngEntropyConfig1ReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraItrngEntropyConfig1ReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraItrngEntropyConfig1WriteVal(u32);
    impl CptraItrngEntropyConfig1WriteVal {
        ///
        #[inline(always)]
        pub fn repetition_count(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
        ///
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
        }
    }
    impl From<u32> for CptraItrngEntropyConfig1WriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraItrngEntropyConfig1WriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraItrngEntropyConfig1WriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTReadVal(u32);
    impl ErrorIntrEnTReadVal {
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for Invalid Device in Pauser field
        #[inline(always)]
        pub fn error_inv_dev_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for Failed Commands (invalid protocol or FW Fail Status)
        #[inline(always)]
        pub fn error_cmd_fail_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for Bad Fuse received from SoC
        #[inline(always)]
        pub fn error_bad_fuse_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for ICCM access blocked by lock
        #[inline(always)]
        pub fn error_iccm_blocked_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox_ecc_unc_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Enable bit for WDT Timer1 timeout
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_en(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_en(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrEnTWriteVal {
            ErrorIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrEnTWriteVal(u32);
    impl ErrorIntrEnTWriteVal {
        /// Enable bit for Internal Errors
        #[inline(always)]
        pub fn error_internal_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for Invalid Device in Pauser field
        #[inline(always)]
        pub fn error_inv_dev_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for Failed Commands (invalid protocol or FW Fail Status)
        #[inline(always)]
        pub fn error_cmd_fail_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for Bad Fuse received from SoC
        #[inline(always)]
        pub fn error_bad_fuse_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for ICCM access blocked by lock
        #[inline(always)]
        pub fn error_iccm_blocked_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit for Mailbox ECC Double-bit Error (uncorrectable)
        #[inline(always)]
        pub fn error_mbox_ecc_unc_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// Enable bit for WDT Timer1 timeout
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
    }
    impl From<u32> for ErrorIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTReadVal(u32);
    impl ErrorIntrTReadVal {
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Invalid Device in Pauser field status bit
        #[inline(always)]
        pub fn error_inv_dev_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Failed Commands status bit (invalid protocol or FW Fail Status)
        #[inline(always)]
        pub fn error_cmd_fail_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Bad Fuse received from SoC status bit
        #[inline(always)]
        pub fn error_bad_fuse_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// ICCM access blocked by lock status bit
        #[inline(always)]
        pub fn error_iccm_blocked_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox_ecc_unc_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// WDT Timer1 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_sts(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// WDT Timer2 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_sts(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTWriteVal {
            ErrorIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTWriteVal(u32);
    impl ErrorIntrTWriteVal {
        /// Internal Errors status bit
        #[inline(always)]
        pub fn error_internal_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Invalid Device in Pauser field status bit
        #[inline(always)]
        pub fn error_inv_dev_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Failed Commands status bit (invalid protocol or FW Fail Status)
        #[inline(always)]
        pub fn error_cmd_fail_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Bad Fuse received from SoC status bit
        #[inline(always)]
        pub fn error_bad_fuse_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// ICCM access blocked by lock status bit
        #[inline(always)]
        pub fn error_iccm_blocked_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) status bit
        #[inline(always)]
        pub fn error_mbox_ecc_unc_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// WDT Timer1 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// WDT Timer2 timeout status bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
    }
    impl From<u32> for ErrorIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTReadVal(u32);
    impl ErrorIntrTrigTReadVal {
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Invalid Device in Pauser field trigger bit
        #[inline(always)]
        pub fn error_inv_dev_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Failed Commands trigger bit
        #[inline(always)]
        pub fn error_cmd_fail_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Bad Fuse received from SoC trigger bit
        #[inline(always)]
        pub fn error_bad_fuse_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// ICCM access blocked by lock trigger bit
        #[inline(always)]
        pub fn error_iccm_blocked_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox_ecc_unc_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// WDT Timer1 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_trig(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// WDT Timer2 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_trig(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ErrorIntrTrigTWriteVal {
            ErrorIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for ErrorIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ErrorIntrTrigTWriteVal(u32);
    impl ErrorIntrTrigTWriteVal {
        /// Internal Errors trigger bit
        #[inline(always)]
        pub fn error_internal_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Invalid Device in Pauser field trigger bit
        #[inline(always)]
        pub fn error_inv_dev_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Failed Commands trigger bit
        #[inline(always)]
        pub fn error_cmd_fail_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Bad Fuse received from SoC trigger bit
        #[inline(always)]
        pub fn error_bad_fuse_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// ICCM access blocked by lock trigger bit
        #[inline(always)]
        pub fn error_iccm_blocked_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Mailbox ECC Double-bit Error (uncorrectable) trigger bit
        #[inline(always)]
        pub fn error_mbox_ecc_unc_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// WDT Timer1 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer1_timeout_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// WDT Timer2 timeout trigger bit
        #[inline(always)]
        pub fn error_wdt_timer2_timeout_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
    }
    impl From<u32> for ErrorIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ErrorIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ErrorIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableReadVal(u32);
    impl FuseAntiRollbackDisableReadVal {
        ///
        #[inline(always)]
        pub fn dis(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FuseAntiRollbackDisableWriteVal {
            FuseAntiRollbackDisableWriteVal(self.0)
        }
    }
    impl From<u32> for FuseAntiRollbackDisableReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableReadVal> for u32 {
        #[inline(always)]
        fn from(val: FuseAntiRollbackDisableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableWriteVal(u32);
    impl FuseAntiRollbackDisableWriteVal {
        ///
        #[inline(always)]
        pub fn dis(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for FuseAntiRollbackDisableWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FuseAntiRollbackDisableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskReadVal(u32);
    impl FuseKeyManifestPkHashMaskReadVal {
        ///
        #[inline(always)]
        pub fn mask(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FuseKeyManifestPkHashMaskWriteVal {
            FuseKeyManifestPkHashMaskWriteVal(self.0)
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: FuseKeyManifestPkHashMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskWriteVal(u32);
    impl FuseKeyManifestPkHashMaskWriteVal {
        ///
        #[inline(always)]
        pub fn mask(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FuseKeyManifestPkHashMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleReadVal(u32);
    impl FuseLifeCycleReadVal {
        ///
        #[inline(always)]
        pub fn life_cycle(&self) -> u32 {
            (self.0 >> 0) & 3
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FuseLifeCycleWriteVal {
            FuseLifeCycleWriteVal(self.0)
        }
    }
    impl From<u32> for FuseLifeCycleReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleReadVal> for u32 {
        #[inline(always)]
        fn from(val: FuseLifeCycleReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleWriteVal(u32);
    impl FuseLifeCycleWriteVal {
        ///
        #[inline(always)]
        pub fn life_cycle(self, val: u32) -> Self {
            Self((self.0 & !(3 << 0)) | ((val & 3) << 0))
        }
    }
    impl From<u32> for FuseLifeCycleWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FuseLifeCycleWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLmsVerifyReadVal(u32);
    impl FuseLmsVerifyReadVal {
        ///
        #[inline(always)]
        pub fn lms_verify(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FuseLmsVerifyWriteVal {
            FuseLmsVerifyWriteVal(self.0)
        }
    }
    impl From<u32> for FuseLmsVerifyReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLmsVerifyReadVal> for u32 {
        #[inline(always)]
        fn from(val: FuseLmsVerifyReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLmsVerifyWriteVal(u32);
    impl FuseLmsVerifyWriteVal {
        ///
        #[inline(always)]
        pub fn lms_verify(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for FuseLmsVerifyWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLmsVerifyWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FuseLmsVerifyWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseSocSteppingIdReadVal(u32);
    impl FuseSocSteppingIdReadVal {
        ///
        #[inline(always)]
        pub fn soc_stepping_id(&self) -> u32 {
            (self.0 >> 0) & 0xffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FuseSocSteppingIdWriteVal {
            FuseSocSteppingIdWriteVal(self.0)
        }
    }
    impl From<u32> for FuseSocSteppingIdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseSocSteppingIdReadVal> for u32 {
        #[inline(always)]
        fn from(val: FuseSocSteppingIdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseSocSteppingIdWriteVal(u32);
    impl FuseSocSteppingIdWriteVal {
        ///
        #[inline(always)]
        pub fn soc_stepping_id(self, val: u32) -> Self {
            Self((self.0 & !(0xffff << 0)) | ((val & 0xffff) << 0))
        }
    }
    impl From<u32> for FuseSocSteppingIdWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseSocSteppingIdWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FuseSocSteppingIdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetReadVal(u32);
    impl InternalFwUpdateResetReadVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalFwUpdateResetWriteVal {
            InternalFwUpdateResetWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalFwUpdateResetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWriteVal(u32);
    impl InternalFwUpdateResetWriteVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalFwUpdateResetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesReadVal(u32);
    impl InternalFwUpdateResetWaitCyclesReadVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalFwUpdateResetWaitCyclesWriteVal {
            InternalFwUpdateResetWaitCyclesWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalFwUpdateResetWaitCyclesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesWriteVal(u32);
    impl InternalFwUpdateResetWaitCyclesWriteVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalFwUpdateResetWaitCyclesWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorFatalMaskReadVal(u32);
    impl InternalHwErrorFatalMaskReadVal {
        ///
        #[inline(always)]
        pub fn mask_iccm_ecc_unc(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mask_dccm_ecc_unc(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mask_nmi_pin(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalHwErrorFatalMaskWriteVal {
            InternalHwErrorFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalHwErrorFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorFatalMaskWriteVal(u32);
    impl InternalHwErrorFatalMaskWriteVal {
        ///
        #[inline(always)]
        pub fn mask_iccm_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn mask_dccm_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn mask_nmi_pin(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for InternalHwErrorFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorNonFatalMaskReadVal(u32);
    impl InternalHwErrorNonFatalMaskReadVal {
        ///
        #[inline(always)]
        pub fn mask_mbox_prot_no_lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mask_mbox_prot_ooo(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mask_mbox_ecc_unc(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalHwErrorNonFatalMaskWriteVal {
            InternalHwErrorNonFatalMaskWriteVal(self.0)
        }
    }
    impl From<u32> for InternalHwErrorNonFatalMaskReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorNonFatalMaskReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorNonFatalMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalHwErrorNonFatalMaskWriteVal(u32);
    impl InternalHwErrorNonFatalMaskWriteVal {
        ///
        #[inline(always)]
        pub fn mask_mbox_prot_no_lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn mask_mbox_prot_ooo(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn mask_mbox_ecc_unc(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
    }
    impl From<u32> for InternalHwErrorNonFatalMaskWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalHwErrorNonFatalMaskWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalHwErrorNonFatalMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockReadVal(u32);
    impl InternalIccmLockReadVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> InternalIccmLockWriteVal {
            InternalIccmLockWriteVal(self.0)
        }
    }
    impl From<u32> for InternalIccmLockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockReadVal> for u32 {
        #[inline(always)]
        fn from(val: InternalIccmLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockWriteVal(u32);
    impl InternalIccmLockWriteVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalIccmLockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: InternalIccmLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTReadVal(u32);
    impl NotifIntrEnTReadVal {
        /// Enable bit for Command Available
        #[inline(always)]
        pub fn notif_cmd_avail_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_en(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Enable bit for Security State, Debug Locked transition
        #[inline(always)]
        pub fn notif_debug_locked_en(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Enable bit for Scan mode
        #[inline(always)]
        pub fn notif_scan_mode_en(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Enable bit for SoC requested the mailbox while locked
        #[inline(always)]
        pub fn notif_soc_req_lock_en(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Enable bit for Generic Input Wires Toggle
        #[inline(always)]
        pub fn notif_gen_in_toggle_en(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrEnTWriteVal {
            NotifIntrEnTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrEnTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrEnTWriteVal(u32);
    impl NotifIntrEnTWriteVal {
        /// Enable bit for Command Available
        #[inline(always)]
        pub fn notif_cmd_avail_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Enable bit for Mailbox ECC Single-bit Error (correctable)
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Enable bit for Security State, Debug Locked transition
        #[inline(always)]
        pub fn notif_debug_locked_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Enable bit for Scan mode
        #[inline(always)]
        pub fn notif_scan_mode_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// Enable bit for SoC requested the mailbox while locked
        #[inline(always)]
        pub fn notif_soc_req_lock_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Enable bit for Generic Input Wires Toggle
        #[inline(always)]
        pub fn notif_gen_in_toggle_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for NotifIntrEnTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrEnTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrEnTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTReadVal(u32);
    impl NotifIntrTReadVal {
        /// Command Available status bit
        #[inline(always)]
        pub fn notif_cmd_avail_sts(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_sts(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Security State, Debug Locked transition status bit
        #[inline(always)]
        pub fn notif_debug_locked_sts(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Scan mode status bit
        #[inline(always)]
        pub fn notif_scan_mode_sts(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// SoC requested the mailbox while locked status bit
        #[inline(always)]
        pub fn notif_soc_req_lock_sts(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Generic Input Wires Toggle status bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_sts(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTWriteVal {
            NotifIntrTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTWriteVal(u32);
    impl NotifIntrTWriteVal {
        /// Command Available status bit
        #[inline(always)]
        pub fn notif_cmd_avail_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Mailbox ECC Single-bit Error (correctable) status bit
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Security State, Debug Locked transition status bit
        #[inline(always)]
        pub fn notif_debug_locked_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Scan mode status bit
        #[inline(always)]
        pub fn notif_scan_mode_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// SoC requested the mailbox while locked status bit
        #[inline(always)]
        pub fn notif_soc_req_lock_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Generic Input Wires Toggle status bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_sts(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for NotifIntrTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTReadVal(u32);
    impl NotifIntrTrigTReadVal {
        /// Command Available trigger bit
        #[inline(always)]
        pub fn notif_cmd_avail_trig(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_trig(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Security State, Debug Locked transition trigger bit
        #[inline(always)]
        pub fn notif_debug_locked_trig(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Scan mode trigger bit
        #[inline(always)]
        pub fn notif_scan_mode_trig(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// SoC requested the mailbox while locked trigger bit
        #[inline(always)]
        pub fn notif_soc_req_lock_trig(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Generic Input Wires Toggle trigger bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_trig(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> NotifIntrTrigTWriteVal {
            NotifIntrTrigTWriteVal(self.0)
        }
    }
    impl From<u32> for NotifIntrTrigTReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTReadVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct NotifIntrTrigTWriteVal(u32);
    impl NotifIntrTrigTWriteVal {
        /// Command Available trigger bit
        #[inline(always)]
        pub fn notif_cmd_avail_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Mailbox ECC Single-bit Error (correctable) trigger bit
        #[inline(always)]
        pub fn notif_mbox_ecc_cor_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Security State, Debug Locked transition trigger bit
        #[inline(always)]
        pub fn notif_debug_locked_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        /// Scan mode trigger bit
        #[inline(always)]
        pub fn notif_scan_mode_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        /// SoC requested the mailbox while locked trigger bit
        #[inline(always)]
        pub fn notif_soc_req_lock_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Generic Input Wires Toggle trigger bit
        #[inline(always)]
        pub fn notif_gen_in_toggle_trig(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
    }
    impl From<u32> for NotifIntrTrigTWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<NotifIntrTrigTWriteVal> for u32 {
        #[inline(always)]
        fn from(val: NotifIntrTrigTWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum DeviceLifecycleE {
        Unprovisioned = 0,
        Manufacturing = 1,
        Reserved2 = 2,
        Production = 3,
    }
    impl DeviceLifecycleE {
        #[inline(always)]
        pub fn unprovisioned(&self) -> bool {
            *self == Self::Unprovisioned
        }
        #[inline(always)]
        pub fn manufacturing(&self) -> bool {
            *self == Self::Manufacturing
        }
        #[inline(always)]
        pub fn production(&self) -> bool {
            *self == Self::Production
        }
    }
    impl TryFrom<u32> for DeviceLifecycleE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<DeviceLifecycleE, ()> {
            if val < 4 {
                Ok(unsafe { core::mem::transmute(val) })
            } else {
                Err(())
            }
        }
    }
    impl From<DeviceLifecycleE> for u32 {
        fn from(val: DeviceLifecycleE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct DeviceLifecycleESelector();
        impl DeviceLifecycleESelector {
            #[inline(always)]
            pub fn unprovisioned(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::Unprovisioned
            }
            #[inline(always)]
            pub fn manufacturing(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::Manufacturing
            }
            #[inline(always)]
            pub fn production(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::Production
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type CptraHwErrorFatal = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraHwErrorFatalReadVal,
        crate::soc_ifc::regs::CptraHwErrorFatalWriteVal,
    >;
    pub type CptraHwErrorNonFatal = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraHwErrorNonFatalReadVal,
        crate::soc_ifc::regs::CptraHwErrorNonFatalWriteVal,
    >;
    pub type CptraFwErrorFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwErrorNonFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwErrorEnc = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFwExtendedErrorInfo = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraBootStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraFlowStatus = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraFlowStatusReadVal,
        crate::soc_ifc::regs::CptraFlowStatusWriteVal,
    >;
    pub type CptraResetReason = ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraResetReasonReadVal>;
    pub type CptraSecurityState =
        ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraSecurityStateReadVal>;
    pub type CptraMboxValidPauser = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraMboxPauserLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraXxxxPauserLockReadVal,
        crate::soc_ifc::regs::CptraXxxxPauserLockWriteVal,
    >;
    pub type CptraTrngValidPauser = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraTrngPauserLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraXxxxPauserLockReadVal,
        crate::soc_ifc::regs::CptraXxxxPauserLockWriteVal,
    >;
    pub type CptraTrngCtrl = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraTrngCtrlReadVal,
        crate::soc_ifc::regs::CptraTrngCtrlWriteVal,
    >;
    pub type CptraFuseWrDone = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraFuseWrDoneReadVal,
        crate::soc_ifc::regs::CptraFuseWrDoneWriteVal,
    >;
    pub type CptraTimerConfig = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraBootfsmGo = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraBootfsmGoReadVal,
        crate::soc_ifc::regs::CptraBootfsmGoWriteVal,
    >;
    pub type CptraDbgManufServiceReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraClkGatingEn = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraClkGatingEnReadVal,
        crate::soc_ifc::regs::CptraClkGatingEnWriteVal,
    >;
    pub type CptraGenericInputWires = ureg::ReadOnlyReg32<u32>;
    pub type CptraGenericOutputWires = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwRevId = ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraHwRevIdReadVal>;
    pub type CptraFwRevId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraHwConfig = ureg::ReadOnlyReg32<crate::soc_ifc::regs::CptraHwConfigReadVal>;
    pub type CptraWdtTimer1En = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraWdtTimer1EnReadVal,
        crate::soc_ifc::regs::CptraWdtTimer1EnWriteVal,
    >;
    pub type CptraWdtTimer1Ctrl = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraWdtTimer1CtrlReadVal,
        crate::soc_ifc::regs::CptraWdtTimer1CtrlWriteVal,
    >;
    pub type CptraWdtTimer1TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraWdtTimer2En = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraWdtTimer2EnReadVal,
        crate::soc_ifc::regs::CptraWdtTimer2EnWriteVal,
    >;
    pub type CptraWdtTimer2Ctrl = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraWdtTimer2CtrlReadVal,
        crate::soc_ifc::regs::CptraWdtTimer2CtrlWriteVal,
    >;
    pub type CptraWdtTimer2TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraWdtStatus = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraWdtStatusReadVal,
        crate::soc_ifc::regs::CptraWdtStatusWriteVal,
    >;
    pub type CptraFuseValidPauser = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraFusePauserLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraXxxxPauserLockReadVal,
        crate::soc_ifc::regs::CptraXxxxPauserLockWriteVal,
    >;
    pub type CptraWdtCfg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type CptraItrngEntropyConfig0 = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraItrngEntropyConfig0ReadVal,
        crate::soc_ifc::regs::CptraItrngEntropyConfig0WriteVal,
    >;
    pub type CptraItrngEntropyConfig1 = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::CptraItrngEntropyConfig1ReadVal,
        crate::soc_ifc::regs::CptraItrngEntropyConfig1WriteVal,
    >;
    pub type CptraRsvdReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseUdsSeed = ureg::WriteOnlyReg32<0, u32>;
    pub type FuseFieldEntropy = ureg::WriteOnlyReg32<0, u32>;
    pub type FuseKeyManifestPkHash = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseKeyManifestPkHashMask = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal,
        crate::soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal,
    >;
    pub type FuseOwnerPkHash = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseFmcKeyManifestSvn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseRuntimeSvn = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseAntiRollbackDisable = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseAntiRollbackDisableReadVal,
        crate::soc_ifc::regs::FuseAntiRollbackDisableWriteVal,
    >;
    pub type FuseIdevidCertAttr = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseIdevidManufHsmId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseLifeCycle = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseLifeCycleReadVal,
        crate::soc_ifc::regs::FuseLifeCycleWriteVal,
    >;
    pub type FuseLmsVerify = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseLmsVerifyReadVal,
        crate::soc_ifc::regs::FuseLmsVerifyWriteVal,
    >;
    pub type FuseLmsRevocation = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FuseSocSteppingId = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::FuseSocSteppingIdReadVal,
        crate::soc_ifc::regs::FuseSocSteppingIdWriteVal,
    >;
    pub type InternalObfKey = ureg::WriteOnlyReg32<0, u32>;
    pub type InternalIccmLock = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalIccmLockReadVal,
        crate::soc_ifc::regs::InternalIccmLockWriteVal,
    >;
    pub type InternalFwUpdateReset = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalFwUpdateResetReadVal,
        crate::soc_ifc::regs::InternalFwUpdateResetWriteVal,
    >;
    pub type InternalFwUpdateResetWaitCycles = ureg::ReadWriteReg32<
        5,
        crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal,
        crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal,
    >;
    pub type InternalNmiVector = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalHwErrorFatalMask = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalHwErrorFatalMaskReadVal,
        crate::soc_ifc::regs::InternalHwErrorFatalMaskWriteVal,
    >;
    pub type InternalHwErrorNonFatalMask = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::InternalHwErrorNonFatalMaskReadVal,
        crate::soc_ifc::regs::InternalHwErrorNonFatalMaskWriteVal,
    >;
    pub type InternalFwErrorFatalMask = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalFwErrorNonFatalMask = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalRvMtimeL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalRvMtimeH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalRvMtimecmpL = ureg::ReadWriteReg32<0, u32, u32>;
    pub type InternalRvMtimecmpH = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfGlobalIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::sha512_acc::regs::GlobalIntrEnTReadVal,
        crate::sha512_acc::regs::GlobalIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::ErrorIntrEnTReadVal,
        crate::soc_ifc::regs::ErrorIntrEnTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrEnR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::NotifIntrEnTReadVal,
        crate::soc_ifc::regs::NotifIntrEnTWriteVal,
    >;
    pub type IntrBlockRfErrorGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfNotifGlobalIntrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::GlobalIntrTReadVal>;
    pub type IntrBlockRfErrorInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::ErrorIntrTReadVal,
        crate::soc_ifc::regs::ErrorIntrTWriteVal,
    >;
    pub type IntrBlockRfNotifInternalIntrR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::NotifIntrTReadVal,
        crate::soc_ifc::regs::NotifIntrTWriteVal,
    >;
    pub type IntrBlockRfErrorIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::ErrorIntrTrigTReadVal,
        crate::soc_ifc::regs::ErrorIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfNotifIntrTrigR = ureg::ReadWriteReg32<
        0,
        crate::soc_ifc::regs::NotifIntrTrigTReadVal,
        crate::soc_ifc::regs::NotifIntrTrigTWriteVal,
    >;
    pub type IntrBlockRfErrorInternalIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorInvDevIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorCmdFailIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorBadFuseIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorIccmBlockedIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorMboxEccUncIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorWdtTimer1TimeoutIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorWdtTimer2TimeoutIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifCmdAvailIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifMboxEccCorIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifDebugLockedIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifScanModeIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifSocReqLockIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfNotifGenInToggleIntrCountR = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IntrBlockRfErrorInternalIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorInvDevIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorCmdFailIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorBadFuseIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorIccmBlockedIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorMboxEccUncIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorWdtTimer1TimeoutIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfErrorWdtTimer2TimeoutIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifCmdAvailIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifMboxEccCorIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifDebugLockedIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifScanModeIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifSocReqLockIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
    pub type IntrBlockRfNotifGenInToggleIntrCountIncrR =
        ureg::ReadOnlyReg32<crate::sha512_acc::regs::IntrCountIncrTReadVal>;
}

// Licensed under the Apache-2.0 license.

use std::collections::HashMap;
use std::fmt::Write;
use std::path::PathBuf;
use std::rc::Rc;
use std::{error::Error, path::Path, process::Command};

use quote::__private::TokenStream;
use quote::{format_ident, quote};
use ureg_schema::{Enum, EnumVariant, Register, RegisterBlock};

static HEADER_PREFIX: &str = r"/*
Licensed under the Apache-2.0 license.
";

static HEADER_SUFFIX: &str = r"
*/
";

static CALIPTRA_RDL_FILES: &[&str] = &[
    "src/libs/rtl/interrupt_regs.rdl",
    "src/keyvault/rtl/kv_def.rdl",
    "src/keyvault/rtl/kv_reg.rdl",
    "src/doe/rtl/doe_reg.rdl",
    "src/ecc/rtl/ecc_reg.rdl",
    "src/hmac/rtl/hmac_reg.rdl",
    "src/sha256/rtl/sha256_reg.rdl",
    "src/sha512/rtl/sha512_reg.rdl",
    "src/soc_ifc/rtl/mbox_csr.rdl",
    "src/soc_ifc/rtl/soc_ifc_reg.rdl",
    "src/soc_ifc/rtl/sha512_acc_csr.rdl",
    "src/integration/rtl/caliptra_reg.rdl",
];

fn run_cmd(cmd: &mut Command) -> Result<(), Box<dyn Error>> {
    let status = cmd.status()?;
    if status.success() {
        Ok(())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?}",
            cmd.get_program(),
            cmd.get_args(),
            status.code()
        )
        .into())
    }
}

fn run_cmd_stdout(cmd: &mut Command) -> Result<String, Box<dyn Error>> {
    let out = cmd.output()?;
    if out.status.success() {
        Ok(String::from_utf8_lossy(&out.stdout).into())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?} stderr {}",
            cmd.get_program(),
            cmd.get_args(),
            out.status.code(),
            String::from_utf8_lossy(&out.stderr)
        )
        .into())
    }
}

fn remove_reg_prefixes(registers: &mut [Rc<Register>], prefix: &str) {
    for reg in registers.iter_mut() {
        if reg.name.to_ascii_lowercase().starts_with(prefix) {
            let reg = Rc::make_mut(reg);
            reg.name = reg.name[prefix.len()..].to_string();
        }
    }
}

fn write_and_format(dest_file: &Path, contents: &str) -> Result<(), Box<dyn Error>> {
    println!("Writing to {dest_file:?}");
    std::fs::write(dest_file, contents)?;
    run_cmd(
        Command::new("rustfmt")
            .arg(dest_file)
            .arg("--config=normalize_comments=true,normalize_doc_attributes=true"),
    )?;
    Ok(())
}

fn real_main() -> Result<(), Box<dyn Error>> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 3 {
        Err("Usage: codegen <caliptra_rtl_dir> <dest_dir>")?;
    }

    let rtl_dir = Path::new(&args[1]);
    let rdl_files: Vec<PathBuf> = CALIPTRA_RDL_FILES
        .iter()
        .map(|p| rtl_dir.join(p))
        .filter(|p| p.exists())
        .collect();

    let rtl_commit_id = run_cmd_stdout(
        Command::new("git")
            .current_dir(rtl_dir)
            .arg("rev-parse")
            .arg("HEAD"),
    )?;
    let rtl_git_status = run_cmd_stdout(
        Command::new("git")
            .current_dir(rtl_dir)
            .arg("status")
            .arg("--porcelain"),
    )?;
    let mut header = HEADER_PREFIX.to_string();
    write!(
        &mut header,
        "\n generated by caliptra_registers_generator with rtl-caliptra repo at {rtl_commit_id}"
    )?;
    if !rtl_git_status.is_empty() {
        write!(
            &mut header,
            "\n\nWarning: rtl-caliptra was dirty:{rtl_git_status}"
        )?;
    }
    header.push_str(HEADER_SUFFIX);

    let dest_dir = Path::new(&args[args.len() - 1]);

    let file_source = caliptra_systemrdl::FsFileSource::new();
    let scope = caliptra_systemrdl::Scope::parse_root(&file_source, &rdl_files)
        .map_err(|s| s.to_string())?;
    let scope = scope.as_parent();

    let addrmap = scope.lookup_typedef("clp").unwrap();

    // These are types like kv_read_ctrl_reg that are used by multiple crates
    let root_block = RegisterBlock {
        declared_register_types: ureg_systemrdl::translate_types(scope)?,
        ..Default::default()
    };
    let mut root_block = root_block.validate_and_dedup()?;

    let mut extern_types = HashMap::new();
    ureg_codegen::build_extern_types(&root_block, quote! { crate }, &mut extern_types);

    let blocks = ureg_systemrdl::translate_addrmap(addrmap)?;

    let mut validated_blocks = vec![];
    for mut block in blocks {
        if block.name.ends_with("_reg") || block.name.ends_with("_csr") {
            block.name = block.name[0..block.name.len() - 4].to_string();
        }
        if block.name == "hmac" {
            remove_reg_prefixes(&mut block.registers, "hmac384_");
        } else {
            remove_reg_prefixes(
                &mut block.registers,
                &format!("{}_", block.name.to_ascii_lowercase()),
            );
        }
        let mut block = block.validate_and_dedup()?;

        if block.block().name == "ecc" {
            block.transform(|t| {
                // [TODO]: Put this enumeration into the RDL and remove this hack
                t.set_register_enum(
                    "CTRL",
                    "CTRL",
                    Rc::new(Enum {
                        name: Some("Ctrl".into()),
                        variants: vec![
                            EnumVariant {
                                name: "NONE".into(),
                                value: 0,
                            },
                            EnumVariant {
                                name: "KEYGEN".into(),
                                value: 1,
                            },
                            EnumVariant {
                                name: "SIGNING".into(),
                                value: 2,
                            },
                            EnumVariant {
                                name: "VERIFYING".into(),
                                value: 3,
                            },
                        ],
                        bit_width: 2,
                    }),
                );
            });
        }
        let module_ident = format_ident!("{}", block.block().name);
        ureg_codegen::build_extern_types(
            &block,
            quote! { crate::#module_ident },
            &mut extern_types,
        );
        validated_blocks.push(block);
    }
    let mut root_submod_tokens = TokenStream::new();

    let mut all_blocks: Vec<_> = std::iter::once(&mut root_block)
        .chain(validated_blocks.iter_mut())
        .collect();
    ureg_schema::filter_unused_types(&mut all_blocks);

    for block in validated_blocks {
        let module_ident = format_ident!("{}", block.block().name);
        let dest_file = dest_dir.join(format!("{}.rs", block.block().name));

        let tokens = ureg_codegen::generate_code(
            &block,
            ureg_codegen::Options {
                extern_types: extern_types.clone(),
                module: quote! { #module_ident },
            },
        );
        root_submod_tokens.extend(quote! { pub mod #module_ident; });
        write_and_format(&dest_file, &(header.clone() + &tokens.to_string()))?;
    }
    let root_type_tokens = ureg_codegen::generate_code(
        &root_block,
        ureg_codegen::Options {
            extern_types: extern_types.clone(),
            ..Default::default()
        },
    );
    let root_tokens = quote! { #root_type_tokens #root_submod_tokens };
    write_and_format(
        &dest_dir.join("lib.rs"),
        &(header.clone() + &root_tokens.to_string()),
    )?;
    Ok(())
}

fn main() {
    if let Err(err) = real_main() {
        eprintln!("{}", err);
        std::process::exit(1);
    }
}
